#!/usr/bin/env bash

# system_info.sh
# Written by:   Ken Cormack, unixken@yahoo.com
# Copyright (c) 2020, Ken Cormack
# github:       https://github.com/kencormack/system_info
# license:      GPL 3.0
# Contributor:  William Stearns, william.l.stearns@gmail.com
#
# This script attempts to perform a fairly complete audit of the current
# configuration of a Raspberry Pi.  The target hardware is any variant or
# model of Pi, up to and including the Pi 4B, 400, and CM4 modules.
#
# Supported OS versions include Raspbian Stretch and Buster (including
# the newly renamed "Raspberry Pi OS", in 32-bit.)  Expect things not to
# work on the 64-bit OS, while it is still beta.  No attempts will be made
# to back-port this to Jessie or older, nor will I attempt to port this to
# Ubuntu, OSMC, LibreELEC, or any other OS distribution available for the Pi.
#
# See the README.md file, at the github link above, for additional info.
#
##################################################

#---------------
# Called by fnMAIN
#
fnGET_HELP()
{
  # This line, included in every function, is part of the debugging/trace
  # log stuff used in testing & development of this script.  See the file
  # DEBBUGGING.md on the github page, for a full explaination of how I
  # chose to implement a debug/trace log.
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Thor: "Hey, let's do 'Get Help'.  It's great.  Works every time."
  # Loki: "It's humiliating.  We are not doing 'Get Help'."
  if [[ "${MY_ARG}" = "--help" ]] || [[ "${MY_ARG}" = "-h" ]]
  then
    # Thor: "GET HELP!  MY BROTHER'S DYING!"
    clear
    echo
    echo -e "SYSTEM_INFO v${MY_VERSION} - HELP"
    cat <<'EOF'

$ system_info*
    Run normally, the script shows a menu of different categories to examine.
    Multiple selections can be made.  Pressing ENTER by itself executes the
    selected options.  If 17 is selected, then all options are executed,
    regardless of whether they were selected.  Choices are saved, and the menu
    pre-loaded with those selections, the next time the script is run.

$ system_info* [1-17]
    If a menu option is specified as a parameter, saved selections are ignored,
    and the specified category selected.  Only a single category can be given
    in this way.  If 17 is specified, then all categories run, just as if
    option 17 were selected from the menu.  Any option specified in this way is
    NOT saved for pre-loading the next time the script is run.

$ system_info* [3> filename]
    For development/testing.  Writes debug/trace data to the specified file.

$ system_info* [ -h | --help ]
    You are here.

EOF
    # Thor:  "Classic!"
    # Loki:  "Humiliating."
    # -- 'Thor: Ragnarok'
    exit
  fi
}


#---------------
# Called by fnMAIN
#
fnINITIALIZE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Indexed arrays
  declare -a CHOICES
  declare -a OPTIONS

  export PATH="${PATH:+${PATH}:}/usr/sbin:/sbin"
  LC_ALL=C
  LANG=C
  if [[ "${TERM}" = "" ]] || [[ "${TERM}" = "dumb" ]]
  then
    REV=""
    SGR0=""
    BELL=""
  else
    REV="$(tput rev 2>/dev/null)"
    SGR0="$(tput sgr0 2>/dev/null)"
    BELL="$(tput bel 2>/dev/null)"
  fi
  RCFILE="${HOME}/.system_inforc"
  ERROR=" "
  DEG_SYMBOL=$'\xc2\xb0'
  SECTION=""
}

#---------------
# Called by fnMAIN
#
fnDEFINE_OPTIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # The array of menu OPTIONS is defined
  OPTIONS[0]="Pi Hardware"
  OPTIONS[1]="Performance"
  OPTIONS[2]="O/S Config"
  OPTIONS[3]="Memory"
  OPTIONS[4]="Logging"
  OPTIONS[5]="Services"
  OPTIONS[6]="Hardware Busses"
  OPTIONS[7]="Serial & Bluetooth"
  OPTIONS[8]="USB & Other Devices"
  OPTIONS[9]="Filesystems & Storage"
  OPTIONS[10]="Audio & Video"
  OPTIONS[11]="Networking"
  OPTIONS[12]="Network Filesystems"
  OPTIONS[13]="Containers & Virtualization"
  OPTIONS[14]="Modules and Packages"
  OPTIONS[15]="System Security"
  OPTIONS[16]="Run All Of The Above"
}

#---------------
# Called by fnMAIN
#
fnCONFIRM_BASH()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # This guards against people launching this script with an incorrect shell,
  # such as by running 'sh scriptname', overriding the 'shebang'.
  if [[ "${BASH_VERSION}" = "" ]]
  then
    clear
    echo "${BELL}"
    echo "################################################################"
    echo
    echo "ERROR: THE WRONG SHELL IS BEING USED TO RUN THIS SCRIPT."
    echo
    echo "${0} is written for the bash shell only."
    echo "It will not run under sh, ksh, or any other shell but \"bash\"."
    echo
    echo "Please do either this..."
    echo "  $ chmod +x ${0}"
    echo "  $ ./${0}"
    echo
    echo "or this..."
    echo "  $ bash ${0}"
    echo
    echo "...to execute under bash, as intended."
    echo
    echo "################################################################"
    echo
    exit
  fi
}

#---------------
# Called by the mainline
#
fnABORT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Called by a trap, whenever the signals
  # SIGHUP SIGINT SIGQUIT SIGABRT or SIGTERM
  # are received.  We clean up after ourselves.
  echo
  echo "ABORT${BELL}"

  # delete the lshw tmp file
  rm /tmp/.lshw_businfo."${PPID}" 2>/dev/null

  # close the debugging file descriptor
  exec 3>&- 2> /dev/null

  # exit the script
  exit
}

#---------------
# Called by fnMAIN and fnDO_INSPECTIONS
#
fnTITLE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo
  echo "               _   VERSION ${MY_VERSION}   _        __"
  echo $' ___ _   _ ___| |_ ___ _ __ ___   (_)_ __  / _| ___'
  echo $'/ __| | | / __| __/ _ \\ \'_ \` _ \\ | | \'_ \\| |_ / _ \\'
  echo $'\__ \ |_| \__ \ ||  __/ | | | | | | | | | |  _| (_) |'
  echo $'|___/\__, |___/\__\___|_| |_| |_| |_|_| |_|_|  \___/'
  echo $'     |___/'
  echo "           RASPBERRY PI SYSTEM INFORMATION REPORT"
  echo
}

#---------------
# Called by multiple functions
#
fnBANNER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo "==============================================================================="
  echo "SYSTEM_INFO(${SECTION}): ${*}"
  echo "==============================================================================="
  echo
}

#---------------
# Called by multiple functions
#
fnSUB_BANNER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo "-------------------------------------------------------"
  echo " ${*}"
  echo
}

#---------------
# Inspect the mode (permissions - in octal), owner, and group of a
# specified directory or file.
# Called by passing 4 parameters to the function as follows:
#   fnMOG octal_mode owner group directory
# Called by fnUSERCHECK and fnCHECK_PERMISSIONS
#
fnMOG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local OCTAL=""
  local OWNER=""
  local GROUP=""
  local CHECKPATH=""
  local COCTAL=""
  local SYMBOLIC=""
  local COWNER=""
  local CGROUP=""

  OCTAL="${1}"      # recommended perms, eg: 755 (rwxr-xr-x)
  OWNER="${2}"      # recommended owner
  GROUP="${3}"      # recommended group
  CHECKPATH="${4}"  # path to check

  if [[ -e "${CHECKPATH}" ]]
  then
    # Run commands
    COCTAL="$(${SUDO} stat -L -c %a "${CHECKPATH}")"
    SYMBOLIC="$(${SUDO} stat -L -c %A "${CHECKPATH}")"
    COWNER="$(${SUDO} stat -L -c %U "${CHECKPATH}")"
    CGROUP="$(${SUDO} stat -L -c %G "${CHECKPATH}")"
    # Compare
    echo "[${CHECKPATH}]"
    if [[ "${COCTAL}" != "${OCTAL}" ]]
    then
      echo "  Permissions ... WARN [${COCTAL}] (${SYMBOLIC}) - Recommend [${OCTAL}])"
    else
      echo "  Permissions ... OK [${OCTAL}] (${SYMBOLIC})"
    fi
    if [[ "${COWNER}" != "${OWNER}" ]]
    then
      echo "  Owner ......... WARN [${COWNER}] - Recommend [${OWNER}]"
    else
      echo "  Owner ......... OK [${OWNER}]"
    fi
    if [[ "${CGROUP}" != "${GROUP}" ]]
    then
      echo "  Group ......... WARN [${CGROUP}] - Recommend [${GROUP}]"
    else
      echo "  Group ......... OK [${GROUP}]"
    fi
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnCONFIRM_OS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Written for Raspbian Stretch and above.  Jessie and older not supported.
  # if os-release file exists...
  if [[ -f /etc/os-release ]]
  then
    # source the os-release file
    . /etc/os-release 2>/dev/null
    # if Raspbian...
    if [[ "${ID}" = "raspbian" ]]
    then
      # and if older than Stretch...
      if [[ "$(echo "${VERSION_ID} < 9" | bc)" -eq 1 ]]
      then
        # too old.
        echo
        fnBANNER "UNSUPPORTED RASPBIAN VERSION"
        echo "This script is designed for Raspbian GNU/Linux 9 (Stretch), and above."
        echo "Version ${PRETTY_NAME} is not supported."
        echo
        exit 1
      else
        # if Raspbian, and Stretch or newer, then ok.
        echo "OS version check:  ok"
      fi
    else
      # if not Raspbian, then unsupported.
      echo
      fnBANNER "LINUX VERSION UNKNOWN"
      echo "This script is designed for Raspbian GNU/Linux 9 (Stretch), and above."
      echo "Unable to identify your version of the operating system... Exiting."
      echo
      exit 1
    fi
  else
    # if os-release file doesn't exist...
    echo
    fnBANNER "LINUX VERSION UNKNOWN"
    echo "This script is designed for Raspbian GNU/Linux 9 (Stretch), and above."
    echo "Unable to identify your version of the operating system... Exiting."
    echo
    exit 1
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnRING_BUF()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Check that dmesg contains anything we might need.  Examples include the
  # "memory split", "active display driver", "rtc", and several other tests.
  if [[ "$(dmesg | grep "Booting Linux")" = "" ]]
  then
    echo
    fnBANNER "DMESG RING BUFFER HAS WRAPPED - PLEASE REBOOT"
    echo "This script relies on \"dmesg\" to provide some of the data it needs."
    echo
    echo "Kernel messages are stored in a data structure called a ring buffer."
    echo "The buffer is fixed in size, with new data overwriting the oldest data."
    echo "When data we need has already been overwritten, that data is lost to us."
    echo
    echo "Your ring buffer has already wrapped.  Please reboot your system before"
    echo "attempting to re-run this script, to ensure that the buffer contains"
    echo "any data we need."
    echo
    exit 1
  else
    echo "dmesg ring buffer: ok"
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
#
fnSUDO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # If we're not already root, set "${SUDO}" so that commands that need
  # root privs will run under sudo
  SUDO=$(type -path sudo)
  if [[ "${EUID}" -ne 0 ]] && [[ "${SUDO}" = "" ]]
  then
    echo
    echo "${0} has not been run as root and sudo is not available, exiting." >&2
    exit 1
  else
    echo "running as user:   $(whoami)"
    if [[ "${EUID}" -ne 0 ]]
    then
      if [[ -n "${SUDO}" ]]
      then
        echo "sudo is available: ok"
      fi
    fi
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnCHECK_VIRT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(systemd-detect-virt)" = "none" ]]
  then
    echo "virtual machine:   ok"
  else
    echo
    fnBANNER "RUNNING WITHIN A VIRTUAL MACHINE IS NOT SUPPORTED"
    echo "This script does not support running inside a virtual machine."
    echo "Please exit the VM and run the script again."
    echo
    exit 1
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnCHECK_CHROOT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if ${SUDO} systemd-detect-virt --chroot
  then
    echo
    fnBANNER "RUNNING WITHIN A CHROOT'D ENVIRONMENT IS NOT SUPPORTED"
    echo "This script does not support running in a chroot'd environment."
    echo "Please exit the chroot'd environment and run the script again."
    echo
    exit 1
  else
    echo "chroot check:      ok"
  fi
  echo
}

#---------------
# Called by fnCONFIRM_PREREQS
#
fnDECODE_REV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  ## https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md
  ## Old-style revision codes
  ## The first set of Raspberry Pi models were given sequential hex revision
  ## codes from 0002 to 0015:

  ## Old style revision codes were normally 4 digits long.  However,
  ## if the Raspberry Pi has been over-volted (voiding the warranty)
  ## the revision number will have 100 at the front. e.g. 1000002.

  ## Code 	Model 	Rev 	RAM 	Manufacturer
  ## 0002 	B 	1.0 	256MB 	Egoman
  ## 0003 	B 	1.0 	256MB 	Egoman
  ## 0004 	B 	2.0 	256MB 	Sony UK
  ## 0005 	B 	2.0 	256MB 	Qisda
  ## 0006 	B 	2.0 	256MB 	Egoman
  ## 0007 	A 	2.0 	256MB 	Egoman
  ## 0008 	A 	2.0 	256MB 	Sony UK
  ## 0009 	A 	2.0 	256MB 	Qisda
  ## 000d 	B 	2.0 	512MB 	Egoman
  ## 000e 	B 	2.0 	512MB 	Sony UK
  ## 000f 	B 	2.0 	512MB 	Egoman
  ## 0010 	B+ 	1.2 	512MB 	Sony UK
  ## 0011 	CM1 	1.0 	512MB 	Sony UK
  ## 0012 	A+ 	1.1 	256MB 	Sony UK
  ## 0013 	B+ 	1.2 	512MB 	Embest
  ## 0014 	CM1 	1.0 	512MB 	Embest
  ## 0015 	A+ 	1.1 	256MB/512MB 	Embest

  ## With the launch of the Raspberry Pi 2, new-style revision codes were
  ## introduced.  Rather than being sequential, each bit of the hex code
  ## represents a piece of information about the revision:

  ## NOQuuuWuFMMMCCCCPPPPTTTTTTTTRRRR
  ##         ^- if "1" then new revision code is used
  ##
  ## Part 	Represents 	Options
  ## N	 	Overvoltage 	0: Overvoltage allowed
  ## 				1: Overvoltage disallowed
  ## O 		OTP Program1 	0: OTP programming allowed
  ## 				1: OTP programming disallowed
  ## Q 		OTP Read1 	0: OTP reading allowed
  ## 				1: OTP reading disallowed
  ## uuu 	Unused 		Unused
  ## W 		Warranty bit 	0: Warranty is intact
  ## 				1: Warranty has been voided by overclocking
  ## u 		Unused	 	Unused
  ## F 		New flag 	1: new-style revision
  ## 				0: old-style revision
  ## MMM 	Memory size 	0: 256MB
  ## 				1: 512MB
  ## 				2: 1GB
  ## 				3: 2GB
  ## 				4: 4GB
  ## 				5: 8GB
  ## CCCC 	Manufacturer 	0: Sony UK
  ## 				1: Egoman
  ## 				2: Embest
  ## 				3: Sony Japan
  ## 				4: Embest
  ## 				5: Stadium
  ## PPPP 	Processor 	0: BCM2835
  ## 				1: BCM2836
  ## 				2: BCM2837
  ## 				3: BCM2711
  ## TTTTTTTT 	Type	 	0: A
  ##		 		1: B
  ##		 		2: A+
  ## 				3: B+
  ## 				4: 2B
  ## 				5: Alpha (early prototype)
  ## 				6: CM1
  ## 				8: 3B
  ## 				9: Zero
  ## 				a: CM3
  ## 				c: Zero W
  ## 				d: 3B+
  ## 				e: 3A+
  ## 				f: Internal use only
  ## 				10: CM3+
  ## 				11: 4B
  ## 				13: 400
  ## 				14: CM4
  ## RRRR 	Revision 	0, 1, 2, etc.

  ## New-style revision codes in use:
  ## Code 	Model	 	Rev 	RAM 	Manufacturer
  ## 900021 	A+ 		1.1 	512MB 	Sony UK
  ## 900032 	B+ 		1.2 	512MB 	Sony UK
  ## 900092 	Zero 		1.2 	512MB 	Sony UK
  ## 900093 	Zero 		1.3 	512MB 	Sony UK
  ## 9000c1 	Zero W 		1.1 	512MB 	Sony UK
  ## 9020e0 	3A+ 		1.0 	512MB 	Sony UK
  ## 920092 	Zero 		1.2 	512MB 	Embest
  ## 920093 	Zero 		1.3 	512MB 	Embest
  ## 900061 	CM 		1.1 	512MB 	Sony UK
  ## a01040 	2B 		1.0 	1GB 	Sony UK
  ## a01041 	2B 		1.1 	1GB 	Sony UK
  ## a02082 	3B 		1.2 	1GB 	Sony UK
  ## a020a0 	CM3 		1.0 	1GB 	Sony UK
  ## a020d3 	3B+ 		1.3 	1GB 	Sony UK
  ## a02042 	2B (w/BCM2837) 	1.2 	1GB 	Sony UK
  ## a21041 	2B 		1.1 	1GB 	Embest
  ## a22042 	2B (w/BCM2837) 	1.2 	1GB 	Embest
  ## a22082 	3B 		1.2 	1GB 	Embest
  ## a220a0 	CM3 		1.0 	1GB 	Embest
  ## a32082 	3B 		1.2 	1GB 	Sony Japan
  ## a52082 	3B 		1.2 	1GB 	Stadium
  ## a22083 	3B 		1.3 	1GB 	Embest
  ## a02100 	CM3+ 		1.0 	1GB 	Sony UK
  ## a03111 	4B 		1.1 	1GB 	Sony UK
  ## b03111 	4B 		1.1 	2GB 	Sony UK
  ## b03112 	4B 		1.2 	2GB 	Sony UK
  ## c03111 	4B 		1.1 	4GB 	Sony UK
  ## c03112 	4B 		1.2 	4GB 	Sony UK
  ## d03114 	8B 		1.4 	8GB 	Sony UK
  ## c03130	400		1.0	4GB	Sony UK
  ## In total, there are 32 variants of the CM4 Compute Module, with a range of
  ## RAM and eMMC Flash options, and with or without wireless connectivity.
  ## a03141	CM4		1.1	1GB	Sony UK <-- CM4 1GB  These are guesses on my part
  ## b03141	CM4		1.1	2GB	Sony UK <-- CM4 2GB  as neither the forums nor the
  ## c03141	CM4		1.1	4GB	Sony UK <-- CM4 4GB  raspberry pi documentation site
  ## d03141	CM4		1.1	8GB	Sony UK <-- CM4 8GB  give all the CM4 revision codes.

  ## The following revision-decoding logic was shamelessly borrowed from:
  ## https://raspberrypi.stackexchange.com/questions/100076/what-revisions-does-cat-proc-cpuinfo-return-on-the-new-pi-4-1-2-4gb
  ## I've made only some coding style changes to match the rest of this script,
  ## and accomodated new models released since the original post.

  local PCB_REVISION=""
  local MODEL_NAME=""
  local PROCESSOR=""
  local MANUFACTURER=""
  local MEMORY_SIZE=""
  local ENCODED_FLAG=""
  local WARRANTY_VOID_OLD=""
  local WARRANTY_VOID_NEW=""

  # These are from the new style revision codes, but we can borrow some
  # of the values, for the old style codes.  This array lacks the "2.0"
  # board revs, the "Qisda" manufacturer, and the "256/512" MB value used
  # by some of the old-style revision codes.  Rather than modify these
  # arrays, I just use those values directly, in sorting out the old codes.
  PCB_REVISION=("v1.0" "v1.1" "v1.2" "v1.3" "v1.4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
  MODEL_NAME=("A" "B" "A+" "B+" "Pi2B" "Alpha" "CM1" "unknown" "3B" "Zero" "CM3" "unknown" "Zero W" "3B+" "3A+" "internal use only" "CM3+" "4B" "18 ?" "400" "CM4")
  PROCESSOR=("BCM2835" "BCM2836" "BCM2837" "BCM2711" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
  MANUFACTURER=("Sony UK" "Egoman" "Embest" "Sony Japan" "Embest" "Stadium" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
  MEMORY_SIZE=("256 MB" "512 MB" "1024 MB" "2048 MB" "4096 MB" "8192 MB" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
  ENCODED_FLAG=("" "revision is a bit field")
  WARRANTY_VOID_OLD=("" "warranty void - Pre Pi2")
  WARRANTY_VOID_NEW=("" "warranty void - Post Pi2")

  MY_EXTRA_INFO=""

  MY_REVISION=$(awk '/^Revision/ { print $NF }' /proc/cpuinfo 2>/dev/null)
  # Force a rev code for testing...
  # MY_REVISION=c03141  ; # CM4
  # MY_REVISION=1000002 ; # Old rev, expired warranty
  # MY_REVISION=0003    ; # Model B w/ mods

  ENCODED=$((0x${MY_REVISION} >> 23 & 1))
  if [[ ${ENCODED} = 1 ]]
  then
    # NEW STYLE REVISION CODES...
    # Save as globals so we can make decisions later based on model, ram, etc.
    MY_PCB_REVISION=${PCB_REVISION[$((0x${MY_REVISION}&0xf))]}
    MY_MODEL_NAME=${MODEL_NAME[$((0x${MY_REVISION}>>4&0xff))]}
    MY_PROCESSOR=${PROCESSOR[$((0x${MY_REVISION}>>12&0xf))]}
    MY_MANUFACTURER=${MANUFACTURER[$((0x${MY_REVISION}>>16&0xf))]}
    MY_MEMORY_SIZE=${MEMORY_SIZE[$((0x${MY_REVISION}>>20&7))]}
    MY_ENCODED_FLAG=${ENCODED_FLAG[$((0x${MY_REVISION}>>23&1))]}
    MY_WARRANTY_VOID_OLD=${WARRANTY_VOID_OLD[$((0x${MY_REVISION}>>24&1))]}
    MY_WARRANTY_VOID_NEW=${WARRANTY_VOID_NEW[$((0x${MY_REVISION}>>25&1))]}
  else
    # OLD STYLE REVISION CODES...
    # Below is a brute force sanity check of my data.
    # Old style revision codes were normally 4 chars long.  However,
    # if the Raspberry Pi has been over-volted (voiding the warranty)
    # the revision code will have a prefix of "100". e.g. 1000002.

    # See if the rev code is 7 chars long
    if [[ "${#MY_REVISION}" = 7 ]]
    then
      # If yes, the 3-char warranty void prefix ("100") is present
      MY_WARRANTY_VOID_PREFIX="$(echo "${MY_REVISION}" | cut -c1-3)"
      # And the last 4 chars are the actual revision code
      MY_REVISION="$(echo "${MY_REVISION}" | cut -c4-7)"
    else
      # Otherwise, no prefix is present
      MY_WARRANTY_VOID_PREFIX=""
    fi

    # Now look at the actual revision code
    case "${MY_REVISION}" in
      0002)
        MY_PCB_REVISION=${PCB_REVISION[0]}
        MY_MODEL_NAME=${MODEL_NAME[1]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[1]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
        ;;
      0003)
        MY_PCB_REVISION=${PCB_REVISION[0]}
        MY_MODEL_NAME=${MODEL_NAME[1]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[1]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
        MY_EXTRA_INFO="Fuses mod and D14 removed"
        ;;
      0004)
        MY_PCB_REVISION="2.0"
        MY_MODEL_NAME=${MODEL_NAME[1]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[0]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
        ;;
      0005)
        MY_PCB_REVISION="2.0"
        MY_MODEL_NAME=${MODEL_NAME[1]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER="Qisda"
        MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
        ;;
      0006)
        MY_PCB_REVISION="2.0"
        MY_MODEL_NAME=${MODEL_NAME[1]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[1]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
        ;;
      0007)
        MY_PCB_REVISION="2.0"
        MY_MODEL_NAME=${MODEL_NAME[0]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[1]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
        ;;
      0008)
        MY_PCB_REVISION="2.0"
        MY_MODEL_NAME=${MODEL_NAME[0]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[0]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
        ;;
      0009)
        MY_PCB_REVISION="2.0"
        MY_MODEL_NAME=${MODEL_NAME[0]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER="Qisda"
        MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
        ;;
      000d)
        MY_PCB_REVISION="2.0"
        MY_MODEL_NAME=${MODEL_NAME[1]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[1]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
        ;;
      000e)
        MY_PCB_REVISION="2.0"
        MY_MODEL_NAME=${MODEL_NAME[1]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[0]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
        ;;
      000f)
        MY_PCB_REVISION="2.0"
        MY_MODEL_NAME=${MODEL_NAME[1]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[1]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
        ;;
      0010)
        MY_PCB_REVISION=${PCB_REVISION[2]}
        MY_MODEL_NAME=${MODEL_NAME[3]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[0]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
        ;;
      0011)
        MY_PCB_REVISION=${PCB_REVISION[0]}
        MY_MODEL_NAME=${MODEL_NAME[6]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[0]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
        ;;
      0012)
        MY_PCB_REVISION=${PCB_REVISION[1]}
        MY_MODEL_NAME=${MODEL_NAME[2]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[0]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
        ;;
      0013)
        MY_PCB_REVISION=${PCB_REVISION[2]}
        MY_MODEL_NAME=${MODEL_NAME[3]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[2]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
        ;;
      0014)
        MY_PCB_REVISION=${PCB_REVISION[0]}
        MY_MODEL_NAME=${MODEL_NAME[6]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[2]}
        MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
        ;;
      0015)
        MY_PCB_REVISION=${PCB_REVISION[1]}
        MY_MODEL_NAME=${MODEL_NAME[2]}
        MY_PROCESSOR=${PROCESSOR[0]}
        MY_MANUFACTURER=${MANUFACTURER[2]}
        MY_MEMORY_SIZE="256 MB / 512 MB"
        ;;
      *)
        MY_PCB_REVISION="UNKNOWN"
        MY_MODEL_NAME="UNKNOWN"
        MY_PROCESSOR="UNKNOWN"
        MY_MANUFACTURER="UNKNOWN"
        MY_MEMORY_SIZE="UNKNOWN"
        ;;
    esac
  fi

  # Pi 4B:
  # Revision [abc]03111 is original board with USB-C power design flaw.
  # Revision [abc]03112 is v1.2 board with fix.
  # (First char, a, b, c or d, refers to 1GB, 2GB, 4GB, or 8GB memory.)
  # Revision d03114 is the 8GB v1.4 board, which also has the fix.
  if [[ "$(echo "${MY_REVISION}" | cut -c2-)" = "03111" ]]
  then
    MY_EXTRA_INFO="USB-C power design flaw affecting \"Smart\" USB-C cables."
  fi

  # Pi CM4:
  # Educated guesses for the as yet unreleased CM4
  if [[ "$(echo "${MY_REVISION}" | cut -c2-)" = "03141" ]]
  then
    MY_EXTRA_INFO="Guessing at this - CM4 rev codes not yet published."
  fi

  case "${MY_MODEL_NAME}" in
    4B|CM4|400)
      PI4_FAMILY="1"
      ;;
    *)
      PI4_FAMILY="0"
      ;;
  esac
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnPRINT_DECODED_REV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ ${ENCODED} = 1 ]]
  then
    fnBANNER "NEW STYLE SYSTEM REVISION NUMBER"
  else
    fnBANNER "OLD STYLE SYSTEM REVISION NUMBER"
  fi
  echo "Revision      : ${MY_REVISION}"
  echo "PCB Revision  : ${MY_PCB_REVISION}"
  echo "Model Name    : ${MY_MODEL_NAME}"
  echo "Processor     : ${MY_PROCESSOR}"
  echo "Manufacturer  : ${MY_MANUFACTURER}"
  echo "Memory Size   : ${MY_MEMORY_SIZE}"
  if [[ ${ENCODED} = 1 ]]
  then
    echo "Encoded Flag  : ${MY_ENCODED_FLAG}"
  fi
  if [[ -n "${MY_WARRANTY_VOID_OLD}" ]] || [[ -n "${MY_WARRANTY_VOID_NEW}" ]] || [[ -n "${MY_WARRANTY_VOID_PREFIX}" ]]
  then
    echo "Warranty Void : yes"
  else
    echo "Warranty Void : no"
  fi
  if [[ -n "${MY_EXTRA_INFO}" ]]
  then
    echo "Comments/Notes: ${MY_EXTRA_INFO}"
  fi
  echo
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnCHK_PACKAGES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PKG_MISSING=""
  local REQUIRED=""
  local REQ_HIT=""
  local REQ_MAX=""
  local PIGPIO_PKG=""
  local DOCKER_PKG=""
  local SUPPLEMENTAL=""
  local SUP_HIT=""
  local SUP_MAX=""

  PKG_MISSING=0
  if type -path dpkg >/dev/null 2>&1
  then
    #################################
    # First, the required packages
    REQUIRED=$(dpkg -l 2>/dev/null | awk '{ print $2 }' | grep -E -i "^alsa-utils$|^bc$|^bluez$|^coreutils$|^cron$|^i2c-tools$|^initramfs-tools$|^iproute2$|^libraspberrypi-bin$|^lsb-release$|^lshw$|^net-tools$|^procps$|^rpi-eeprom$|^sed$|^systemd$|^util-linux$|^usbutils$|^v4l-utils$|^wireless-tools$")
    REQ_HIT=0
    REQ_MAX=0
    for PACKAGE in alsa-utils bc bluez coreutils cron i2c-tools initramfs-tools iproute2 libraspberrypi-bin lsb-release lshw net-tools procps rpi-eeprom usbutils sed systemd util-linux v4l-utils wireless-tools
    do
      if [[ "${PACKAGE}" = "rpi-eeprom" ]]
      then
        # If the Pi is not a 4B, 400, or CM4, then skip checking for the rpi-eeprom package
        if [[ "${PI4_FAMILY}" != "1" ]]
        then
          continue
        fi
      fi
      # Otherwise, for all packages, on all models...
      # If the package is installed...
      if [[ "$(echo "${REQUIRED}" | grep "${PACKAGE}")" != "" ]]
      then
        (( REQ_HIT++ )) || :
      else
        # Otherwise, tell the user to install it.
        fnBANNER "Required package \"${PACKAGE}\" is not installed." | grep -v "^$"
        echo "Install with:"
        echo "  sudo apt install -y ${PACKAGE}"
        PKG_MISSING=1
        echo
      fi
      (( REQ_MAX++ )) || :
    done
    if [[ ${PKG_MISSING} -ne 0 ]]
    then
      fnBANNER "Once any missing packages are installed, re-run this script."
      echo
      exit
    else
      echo "${REQ_HIT} out of ${REQ_MAX} required packages are installed."
      echo "All core inspections will be performed."
      echo

      ######################################
      # Now, the supplemental packages.
      # If installed, great.  If not installed, don't trouble the user to add
      # them.  Some of the supplemental package names have changed, between
      # Stretch and Buster.  The next few lines accomodate these different
      # package names.  The package containing daemon "pigpiod" is called
      # "pigpiod" on Buster, but called "pigpio" on Stretch.  The package
      # containing "docker" is called "docker-ce-cli" on Buster, but called
      # "docker.io" on Stretch.
      if [[ "${VERSION_ID}" -eq 9 ]]
      then
        # Package names on Stretch
        PIGPIO_PKG=pigpio
        DOCKER_PKG=docker.io
      else
        # Package names on Buster
        PIGPIO_PKG=pigpiod
        DOCKER_PKG=docker-ce-cli
      fi

      # The packages conditionally named above, appear as variables here...
      SUPPLEMENTAL=$(dpkg -l 2>/dev/null | awk '{ print $2 }' | grep -E -i "^apparmor$|^at$|^auditd$|^chkrootkit$|^clamav$|^cups-client$|^dc$|^${DOCKER_PKG}$|^ethtool$|^hdparm$|^lirc$|^lm-sensors$|^lvm2$|^lynis$|^m4$|^mdadm$|^nfs-kernel-server$|^nmap$|^perl-base$|^${PIGPIO_PKG}$|^python3-gpiozero$|^quota$|^rkhunter$|^rng-tools$|^rpcbind$|^rtl-sdr$|^samba$|^smartmontools$|^snort$|^sysbench$|^sysstat$|^systemd-container$|^systemd-coredump$|^tripwire$|^ufw$|^unhide$|^watchdog$|^wiringpi$|^x11-xserver-utils$")
      SUP_HIT=0
      SUP_MAX=0
      # They also appear as variables here...
      for PACKAGE in apparmor at auditd chkrootkit clamav cups-client dc ${DOCKER_PKG} ethtool hdparm lirc lm-sensors lvm2 lynis m4 mdadm nfs-kernel-server nmap perl-base ${PIGPIO_PKG} python3-gpiozero quota rkhunter rng-tools rpcbind rtl-sdr samba smartmontools snort sysbench sysstat systemd-container systemd-coredump tripwire ufw unhide watchdog wiringpi x11-xserver-utils
      do
        # If wiringpi is installed, it needs to be v2.52 on the Pi 4B - 1/2/4GB
        # models only..
        # See - http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/
        # This script will not support WiringPi, of any version, on a Pi 4B 8GB, 400, or CM4
        # model.
        if [[ "${PACKAGE}" = "wiringpi" ]]
        then
          WIRINGPI_VERS=$(gpio -v 2>/dev/null | head -1 | awk '{ print $NF }')
          if [[ "${WIRINGPI_VERS}" = "2.52" ]]
          then
            # Can't use "${PI4_FAMILY}" here because we allow this on 4Bs older than the 8GB model.
            if [[ "${MY_REVISION}" != "d03114" ]] && [[ "${MY_MODEL_NAME}" != "400" ]] && [[ "${MY_MODEL_NAME}" != "CM4" ]]
            then
              (( SUP_HIT++ ))
              (( SUP_MAX++ ))
              continue
            fi
          fi
          # If not a 4B, 400, or CM4 then wiringpi v2.50 from the repositories will do
          if [[ "${PI4_FAMILY}" != "1" ]]
          then
            (( SUP_HIT++ ))
          fi
          (( SUP_MAX++ ))
        else
          # Otherwise, for all other packages, on all models...
          # If the package is installed...
          if [[ "$(echo "${SUPPLEMENTAL}" | grep "${PACKAGE}")" != "" ]]
          then
            (( SUP_HIT++ )) || :
            # KPC
            # else
            #   echo "package ${PACKAGE} not found"
          fi
          (( SUP_MAX++ )) || :
        fi
      done
      echo "${SUP_HIT} out of ${SUP_MAX} supplemental packages are installed."
      if [[ "${SUP_HIT}" -gt 0 ]]
      then
        echo "Some supplemental inspections can be performed."
      else
        echo "No supplemental inspections can be performed."
      fi
      echo
    fi
  else
    echo "Missing utility dpkg, unable to verify package dependencies" >&2
    exit 1
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
#
fnLSHW_BUSINFO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo -n "One moment, please... "
  ${SUDO} lshw -businfo >/tmp/.lshw_businfo."${PPID}" 2>/dev/null
  # The tmpfile negates need to run the above slow command multiple times.
  # We'll grab the next few variables now, for use in later routines.
  LSHW_INPUT=$(grep "input" /tmp/.lshw_businfo."${PPID}" 2>/dev/null | head -1)
  LSHW_STORAGE=$(grep "storage" /tmp/.lshw_businfo."${PPID}" 2>/dev/null | head -1)
  LSHW_GENERIC=$(grep "generic" /tmp/.lshw_businfo."${PPID}" 2>/dev/null | head -1)
  LSHW_MULTIMEDIA=$(grep "multimedia" /tmp/.lshw_businfo."${PPID}" 2>/dev/null | head -1)
  LSHW_COMMUNICATION=$(grep "communication" /tmp/.lshw_businfo."${PPID}" 2>/dev/null | head -1)
  echo "Ready."
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnSYSTEM_ID()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEM IDENTIFICATION"
  echo "Hostname: $(hostname)"
  echo "Serial #: $(awk '/^Serial/ { print $NF }' /proc/cpuinfo 2>/dev/null)"
  echo
}

#---------------
# Called by fnOS
#
fnMODPROBE_CONFIGS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  MODPROBE_CONFIGS=0
  if [[ "$(lsmod | grep configs)" = "" ]]
  then
    ${SUDO} modprobe configs
    MODPROBE_CONFIGS=1
  fi
}

#---------------
# Called by fnOS
#
fnRMMOD_CONFIGS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(lsmod | grep configs)" != "" ]] && [[ "${MODPROBE_CONFIGS}" -eq 1 ]]
  then
    ${SUDO} rmmod configs
    MODPROBE_CONFIGS=0
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER, fnMODPROBE_CONFIGS, fnRMMOD_CONFIGS
#
fnOS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local TARGET=""
  local AUTOLOGIN_GUI=""
  local AUTOLOGIN_TTY=""

  fnBANNER "OPERATING SYSTEM"
  echo "${PRETTY_NAME}"
  uname -a
  echo

  echo "LSB_RELEASE:"
  lsb_release -a 2>/dev/null
  echo

  echo "HOSTNAMECTL:"
  hostnamectl status 2> /dev/null
  echo

  echo "OSTYPE.............. ${OSTYPE}"
  echo

  if [[ "$(vcgencmd get_config arm_64bit | cut -f2 -d"=")" = "1" ]]
  then
    echo "KERNEL IS........... 64-BIT"
  else
    echo "KERNEL IS........... 32-BIT"
  fi

  if [[ -c /dev/kvm ]]
  then
    echo "KVM SUPPORT......... enabled"
  else
    echo "KVM SUPPORT......... disabled"
  fi

  fnMODPROBE_CONFIGS

  if [[ "$(${SUDO} gunzip -c /proc/config.gz | grep "CONFIG_SECURITY_SELINUX=[ym]")" != "" ]]
  then
    echo "SELINUX............. enabled"
    # HAS_SELINUX="yes"
  else
    echo "SELINUX............. not present in this kernel"
    # HAS_SELINUX="no"
  fi
  if [[ "$(${SUDO} gunzip -c /proc/config.gz | grep "CONFIG_SECURITY_APPARMOR=[ym]")" != "" ]]
  then
    echo "APPARMOR............ enabled"
    HAS_APPARMOR="yes"
  else
    echo "APPARMOR............ not present in this kernel"
    HAS_APPARMOR="no"
  fi
  if [[ "$(${SUDO} gunzip -c /proc/config.gz | grep "CONFIG_AUDIT=[ym]")" != "" ]]
  then
    echo "AUDITD SUPPORT...... enabled"
    HAS_AUDITD="yes"
  else
    echo "AUDITD SUPPORT...... not present in this kernel"
    HAS_AUDITD="no"
  fi
  echo

  fnRMMOD_CONFIGS

  echo -n "DEFAULT BOOT TARGET. "
  TARGET="$(stat /lib/systemd/system/default.target | grep "File:" | awk '{ print $NF }')"
  systemctl list-units --type=target | grep "${TARGET}" | awk '{ print $5" "$6" "$7" "$8" "$9 }'

  if [[ -f /etc/lightdm/lightdm.conf ]]
  then
    echo -n "GUI AUTOLOGIN....... "
    AUTOLOGIN_GUI="$(grep "^autologin-user=" /etc/lightdm/lightdm.conf | cut -f2 -d"=")"
    if [[ -n "${AUTOLOGIN_GUI}" ]]
    then
      echo "${AUTOLOGIN_GUI}"
    else
      echo "none"
    fi
  fi

  echo -n "TTY AUTOLOGIN....... "
  AUTOLOGIN_TTY="$(grep "^ExecStart=" /lib/systemd/system/getty@.service | grep "autologin" | awk '{ print $3 }')"
  if [[ -n "${AUTOLOGIN_TTY}" ]]
  then
    echo "${AUTOLOGIN_TTY}"
  else
    echo "none"
  fi
  echo

  echo "BASH VERSION........ ${BASH_VERSION}"
  echo

  echo -n "UPTIME.............. "
  uptime -p
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnMAC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "MAC-ADDRESS(ES)"
  ifconfig | grep '[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:' | awk '{print $2}' | tr "a-f" "A-F" | sort
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnMODEL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "MODEL AND FIRMWARE VERSION"
  strings /sys/firmware/devicetree/base/model
  echo
  cat /etc/rpi-issue
  echo
  vcgencmd version
  echo
  fnBANNER "VIDEO CORE VERSION AND LOG STATUS"
  vcgencmd vcos version
  echo
  vcgencmd vcos log status
  echo
  fnBANNER "VIDEO CORE OUT-OF-MEMORY EVENTS"
  vcgencmd mem_oom
  echo
  fnBANNER "VIDEO CORE RELOCATABLE MEMORY STATS"
  vcgencmd mem_reloc_stats
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnDIAGRAM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path pinout >/dev/null 2>&1
  then
    fnBANNER "SYSTEM DIAGRAM (***)"
    pinout -m
    echo
  fi
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnCPU()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CPU INFORMATION"
  lscpu
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER, fnSUB_BANNER
#
fnSENSORS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path sensors >/dev/null 2>&1
  then
    fnBANNER "LM-SENSORS (***)"
    sensors
  fi
  if type -path sensors-detect >/dev/null 2>&1
  then
    fnSUB_BANNER "Searching for sensors..."
    ${SUDO} sensors-detect --auto
    echo
  fi
  echo " ----------------------------------------------------"
  systemctl status lm-sensors.service
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnHOW_BOOT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MY_OTP=""
  local BOOT_TO_USB=""

  # Boot-from-USB mass storage will be handled differently on the Pi 4B, 400, and CM4,
  # versus older models.
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    # The Pi 4B, 400, and CM4 use an EEPROM to control it's boot source.
    fnBANNER "PI MODEL ${MY_MODEL_NAME} EEPROM VERSION"
    vcgencmd bootloader_version
    echo
    if type -path rpi-eeprom-update >/dev/null 2>&1
    then
      # This command will indicate that an update is required, if the
      # timestamp of the most recent file in the firmware directory
      # (normally /lib/firmware/raspberrypi/bootloader/critical)
      # is newer than that reported by the current bootloader.
      fnBANNER "PI MODEL ${MY_MODEL_NAME} EEPROM UPDATE STATUS"
      ${SUDO} rpi-eeprom-update
      echo
    else
      echo "Missing utility rpi-eeprom-update, skipping eeprom update check" >&2
    fi

    fnBANNER "PI MODEL ${MY_MODEL_NAME} EEPROM CONFIG"
    echo "The meaning of each of these is documented here:"
    echo "https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711_bootloader_config.md"
    echo
    vcgencmd bootloader_config
  else
    # Some older Pi models use OTP (One Time Programable) memory to control
    # whether the Pi can boot from USB mass storage.  Here, we check the
    # model, and then perform the appropriate examination.  OTP-managed
    # USB mass storage boot is available on Pi 2B v1.2, 3A+, 3B, and 3B+
    # models only.  Any other model will skip this test.  The Pi 3B+
    # comes from the factory with boot from USB mass storage enabled.
    # If a Model 2B, make sure it's a v1.2 unit.
    MY_OTP=${MY_MODEL_NAME}
    if [[ "${MY_MODEL_NAME}" = "Pi2B" ]] && [[ "${MY_PROCESSOR}" = "BCM2837" ]]
    then
      MY_OTP="Pi2Bv1.2"
    fi
    case ${MY_OTP} in
      Pi2Bv1.2|3A+|3B|3B+)
        fnBANNER "OTP BOOT-FROM-USB STATUS"
        BOOT_TO_USB=$(vcgencmd otp_dump | grep "^17:")
        if [[ "${BOOT_TO_USB}" = "17:3020000a" ]]
        then
          echo "Boot From USB: Enabled"
        else
          echo "Boot From USB: Available, but not enabled"
        fi
        ;;
      * )
        echo "Boot From USB: Feature not available on this model"
        ;;
    esac
    echo
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnDTOVERLAYS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ACTIVE DEVICE TREE OVERLAYS"
  ${SUDO} vcdbg log msg 2>&1 | grep "Loaded overlay" | cut -f2- -d":"
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnDTPARAMS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ACTIVE DEVICE TREE PARAMS"
  ${SUDO} vcdbg log msg 2>&1 | grep "dtparam:" | cut -f2- -d":"
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnSYSCTL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSCTL KERNEL VARIABLES"
  cat /etc/sysctl.conf /etc/sysctl.d/*.conf | grep -E -v "^$|^#" | sort
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnLEDS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local TRIGGER=""

  # This section needs study for Pi 4B ethernet LEDs...
  # dtparam=eth_led0=4
  # dtparam=eth_led1=4
  #
  # perhaps use "sudo vcdbg log msg" and grep for:
  # dtparam: eth_led0=
  # dtparam: eth_led1=
  # (maybe even "dtparam: act_led_trigger=heartbeat" for ACT LED, below, too.)
  #
  # eth_led0 is green
  # eth_led1 is amber
  #
  # The comments are also hard to decipher (e.g. what's the difference
  # between 0, 2, and 7?):
  # 0=Speed/Activity (default) 1=Speed
  # 2=Flash activity           3=FDX
  # 4=Off                      5=On
  # 6=Alt                      7=Speed/Flash
  # 8=Link                     9=Activity
  #
  # My understanding is:
  #
  # Speed means on for a fast link (probably 1Gb/s), otherwise off.
  #
  # Activity inverts the current state for a short period for every packet,
  # so more traffic means more flicker.
  #
  # Flash activity is like Activity but without the proportionality - the
  # pulses (which could be on or off depending on the other part of the
  # mode) are a fixed width and the gaps are of (the same) minimum width,
  # such that you see a clear flash pattern if there is activity and a steady
  # state if not.
  #
  # It looks like 2 is mislabelled and should just say Flash activity.
  #
  fnBANNER "LED TRIGGERS"
  TRIGGER=""
  if [[ -f /sys/class/leds/led0/trigger ]]
  then
    echo -n "LED0: "
    sed 's/ /\n/g' < /sys/class/leds/led0/trigger | while read -r TRIGGER
    do
      echo "${TRIGGER}" | grep -F "[" || :
    done
  fi
  if [[ -f /sys/class/leds/led1/trigger ]]
  then
    echo -n "LED1: "
    sed 's/ /\n/g' < /sys/class/leds/led1/trigger | while read -r TRIGGER
    do
      echo "${TRIGGER}" | grep -F "[" || :
    done
  fi
  if [[ -f /sys/class/leds/mmc0::/trigger ]]
  then
    echo -n "MMC0: "
    sed 's/ /\n/g' < /sys/class/leds/mmc0::/trigger | while read -r TRIGGER
    do
      echo "${TRIGGER}" | grep -F "[" || :
    done
  fi
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnCMDLINE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CMDLINE.TXT"
  cat /boot/cmdline.txt 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnCONFIGTXT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CONFIG.TXT SETTINGS"
  grep -E -v "^$|^#" < /boot/config.txt 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
#
fnMEMSPLIT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ARM=""
  local GPU=""

  fnBANNER "MEMORY SPLIT"
  # There is a flaw in "vcgencmd get_mem arm" on Pi 4B and later models with
  # more than 1GB of memory.  On those models, the command only considers the
  # first GB of memory.  The technique used here instead, is accurate on all
  # Pi models regardless of memory.
  ARM=$(($(dmesg | grep "Memory:" | grep "available" | cut -f2 -d"/" | cut -f1 -d"K") / 1024 ))
  ARM=$(printf "%4d" "${ARM}")
  echo "ARM: ${ARM} MB"
  GPU="$(vcgencmd get_mem gpu | cut -f2 -d"=" | sed 's/M$//')"
  GPU=$(printf "%4d" "${GPU}")
  echo "GPU: ${GPU} MB"
  echo
  echo "Note: GPU hardware-accelerated codecs will be disabled if \"gpu_mem=16\"."
  echo "At least \"gpu_mem=96\" is required for HW codecs to run correctly."
  echo "At least \"gpu_mem=128\" is required for camera operation."
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnDISPDRV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ACTIVE DISPLAY DRIVER"
  # If two particular modules are not running, it's the Broadcom driver.
  # If the modules are loaded, the "fake" OpenGL driver shows "firmwarekms"
  # in dmesg.  If the modules are loaded, the "full" OpenGL driver does not
  # show "firmwarekms" in dmesg.  An example of why we needed to check for
  # ring buffer wrap earlier.  We need to remember which driver is used -
  # we'll need this info later.
  if [[ "$(lsmod | awk '{ print $1 }' | grep ^vc4)" = "" ]] && [[ "$(lsmod | awk '{ print $1 }' | grep ^drm)" = "" ]]
  then
    DISP_DRIVER="broadcom"
    echo "Broadcom Display Driver"
  else
    if [[ "$(dmesg | grep firmwarekms)" != "" ]]
    then
      DISP_DRIVER="fake"
      echo "\"Fake\" OpenGL Display Driver"
    else
      DISP_DRIVER="full"
      echo "\"Full\" OpenGL Display Driver"
    fi
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnPROCSPEED()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local FREQ=""
  local MHZ=""

  fnBANNER "PROCESSOR SPEEDS"
  FREQ=$(vcgencmd measure_clock arm | cut -f2 -d"=")
  MHZ=$((FREQ / 1000000))
  MHZ=$(printf "%4d" "${MHZ}")
  echo " CPU: ${MHZ} MHz"
  FREQ=$(vcgencmd measure_clock core | cut -f2 -d"=")
  MHZ=$((FREQ / 1000000))
  MHZ=$(printf "%4d" "${MHZ}")
  echo "CORE: ${MHZ} MHz"
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnOVERCLOCK()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CLOCK_STUFF=""

  # For details see:
  # https://www.raspberrypi.org/documentation/configuration/config-txt/overclocking.md
  CLOCK_STUFF=$(grep -E -v "^$|^#" /boot/config.txt | grep -E -i "^arm_freq=|^gpu_freq=|^core_freq=|^h264_freq=|^isp_freq=|^v3d_freq=|^hevc_freq=|^sdram_freq=|^over_voltage=|^over_voltage_sdram=|^over_voltage_sdram_c=|^over_voltage_sdram_i=|^over_voltage_sdram_p=|^force_turbo=|^initial_turbo=|^arm_freq_min=|^core_freq_min=|^gpu_freq_min=|^h264_freq_min=|^isp_freq_min=|^v3d_freq_min=|^hevc_freq_min=|^sdram_freq_min=|^over_voltage_min=|^temp_limit=|^temp_soft_limit=|^hdmi_enable_4kp60=|^enable_tvout=")

  if [[ -n "${CLOCK_STUFF}" ]]
  then
    fnBANNER "CLOCKSPEED / OVERCLOCKING OPTIONS FOUND IN CONFIG.TXT"
    echo "${CLOCK_STUFF}" | sort
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnRING_OSCILLATOR()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ALL=""
  local C=""
  local F=""

  fnBANNER "RING OSCILLATOR STATS"
  if type -path dc >/dev/null 2>&1
  then
    # SUPPLEMENTAL CONVERSION to Fahrenheit
    ALL="$(vcgencmd read_ring_osc)"
    C="$(vcgencmd read_ring_osc | cut -f4 -d'(' | cut -f1 -d"'")"
    F="$(echo "2 k 9 5 / ${C} * 32 + p" | dc)"
    echo "${ALL} ($(printf "%3.1f" "${F}")${DEG_SYMBOL}F) (***)"
  else
    vcgencmd read_ring_osc
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnCLOCKFREQ()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CLOCK=""

  fnBANNER "CLOCK FREQUENCIES"
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo "Clocks available across all Pi models..."
  fi
  for CLOCK in arm core h264 isp v3d uart pwm emmc pixel vec hdmi dpi
  do
    echo "${CLOCK}: $(vcgencmd measure_clock "${CLOCK}")" | awk '{ printf("%- 10s %- 28s\n", $1, $2);}' 2>&1
  done
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo
    echo "Additional ${MY_MODEL_NAME} clocks..."
    for CLOCK in altscb cam0 cam1 ckl108 clk27 clk54 debug0 debug1 dft dsi0 dsi0esc dsi1 dsi1esc emmc2 genet125 genet250 gisb gpclk0 gpclk1 hevc m2mc otp pcm plla pllb pllc plld pllh pulse smi tectl testmux tsens usb wdog xpt
    do
      echo "${CLOCK}: $(vcgencmd measure_clock "${CLOCK}")" | awk '{ printf("%- 10s %- 28s\n", $1, $2);}' 2>&1
    done
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnVOLTS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local VOLTS=""

  fnBANNER "VOLTAGES"
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo "Voltages available across all Pi models..."
  fi
  for VOLTS in core sdram_c sdram_i sdram_p
  do
    echo "${VOLTS}: $(vcgencmd measure_volts "${VOLTS}")" | awk '{ printf("%- 10s %- 40s\n", $1, $2);}' 2>&1
  done
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo
    echo "Additional ${MY_MODEL_NAME} voltages..."
    vcgencmd measure_volts 2711 | sed 's/ /\n/g' | while read -r VOLTS
    do
      echo -e "2711: ${VOLTS}" | awk '{ printf("%- 10s %- 40s\n", $1, $2);}' 2>&1
    done
    for VOLTS in ain1 usb_pd uncached
    do
      echo "${VOLTS}: $(vcgencmd measure_volts "${VOLTS}")" | awk '{ printf("%- 10s %- 40s\n", $1, $2);}' 2>&1
    done
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnTEMPS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local GPU_TEMP=""
  local ARM_TEMP=""
  local PMIC_TEMP=""
  local C=""
  local F=""

  fnBANNER "TEMPERATURE"
  # Pointless venting - I wish bash could do floating point
  # math directly in the shell like ksh can, without needing
  # bc, dc, expr, awk, or other external commands.  Argh!
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo "Temperatures available across all Pi models..."
  fi
  GPU_TEMP=$(vcgencmd measure_temp)
  C=$(echo "${GPU_TEMP}" | cut -f2 -d"=" | cut -f1 -d"'")
  if type -path dc >/dev/null 2>&1
  then
    # SUPPLEMENTAL CONVERSION to Fahrenheit
    F=$(echo "2 k 9 5 / ${C} * 32 + p" | dc)
    echo " GPU Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C ($(printf "%3.2f" "${F}")${DEG_SYMBOL}F) (***)"
  else
    # Otherwise, show Centigrade/Celcius only
    echo " GPU Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C"
  fi
  ARM_TEMP=$(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null)
  C=$(echo "scale=2;${ARM_TEMP}/1000" | bc)
  if type -path dc >/dev/null 2>&1
  then
    # SUPPLEMENTAL CONVERSION to Fahrenheit
    F=$(echo "2 k 9 5 / ${C} * 32 + p" | dc)
    echo " ARM Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C ($(printf "%3.2f" "${F}")${DEG_SYMBOL}F) (***)"
  else
    # Otherwise, show Centigrade/Celcius only
    echo " ARM Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C"
  fi

  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo
    echo "Additional Pi ${MY_MODEL_NAME} PMIC temperature..."
    PMIC_TEMP=$(vcgencmd measure_temp pmic)
    C=$(echo "${PMIC_TEMP}" | cut -f2 -d"=" | cut -f1 -d"'")
    if type -path dc >/dev/null 2>&1
    then
      # SUPPLEMENTAL CONVERSION to Fahrenheit
      F=$(echo "2 k 9 5 / ${C} * 32 + p" | dc)
      echo "PMIC Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C ($(printf "%3.2f" "${F}")${DEG_SYMBOL}F) (***)"
    else
      # Otherwise, show Centigrade/Celcius only
      echo "PMIC Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C"
    fi
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnGOV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local GOV=""
  local FORCE=""

  fnBANNER "SCALING GOVERNOR"
  GOV=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null)
  FORCE=$(grep "^force_turbo=" /boot/config.txt 2>/dev/null | cut -f2 -d"=")

  # The possible governor settings are:
  #   performance  - always use max cpu freq
  #   powersave    - always use min cpu freq
  #   ondemand     - change cpu freq depending on cpu load
  #                  (On rasbian, it just switches min and max)
  #   conservative - smoothly change cpu freq depending on cpu load
  #   uesrspace    - allow user space daemon to control cpufreq
  #   schedutil    - wiser about freq. selection than the other governors,
  #                  but not quite there yet
  # All but "performance" are overridden by "force_turbo=1" in config.txt.
  # Both of those mean the same thing - run at max speed, all the time..

  echo "${GOV}"
  if [[ "${GOV}" != "performance" ]] && [[ "${FORCE}" = "1" ]]
  then
    echo "(...but overridden by \"force_turbo=1\" found in config.txt)"
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnTHROTTLES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local UNDERVOLTED=""
  local CAPPED=""
  local THROTTLED=""
  local SOFT_TEMPLIMIT=""
  local HAS_UNDERVOLTED=""
  local HAS_CAPPED=""
  local HAS_THROTTLED=""
  local HAS_SOFT_TEMPLIMIT=""
  local GOOD=""
  local BAD=""
  local STATUS=""

  fnBANNER "DECODED PROCESSOR THROTTLING STATUS"
  # These are what cause the overtemp (thermometer) icon,
  # the undervolt (lightening bolt) icon, etc., to be
  # displayed on a screen, when there's a problem.
  #
  # "vcgencmd get_throttled"
  # Bit Meaning
  # ===============
  #  0 Undervoltage currently detected
  #  1 Arm frequency currently capped
  #  2 Currently throttled
  #  3 Soft temperature limit currently active
  # 16 Under voltage has occured at least once since last boot
  # 17 Arm frequency cap has occured at least once since last boot
  # 18 Throttling has occurred at least once since last boot
  # 19 Soft Temperature limit has occurred at least once since last boot

  #Flag Bits
  UNDERVOLTED=0x1
  CAPPED=0x2
  THROTTLED=0x4
  SOFT_TEMPLIMIT=0x8
  HAS_UNDERVOLTED=0x10000
  HAS_CAPPED=0x20000
  HAS_THROTTLED=0x40000
  HAS_SOFT_TEMPLIMIT=0x80000

  #Output Strings
  GOOD="no"
  BAD="YES"

  #Get Status, extract hex
  STATUS=$(vcgencmd get_throttled)
  STATUS=${STATUS#*=}

  echo -n "Throttle Status: "
  ((STATUS!=0)) && echo "${STATUS}" || echo "${STATUS}"
  echo

  echo "Undervolted:"
  echo -n "    Currently: "
  (((STATUS&UNDERVOLTED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_UNDERVOLTED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
  echo "Throttled:"
  echo -n "    Currently: "
  (((STATUS&THROTTLED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_THROTTLED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
  echo "Frequency Capped:"
  echo -n "    Currently: "
  (((STATUS&CAPPED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_CAPPED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
  echo "Softlimit:"
  echo -n "    Currently: "
  (((STATUS&SOFT_TEMPLIMIT)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_SOFT_TEMPLIMIT)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnULIMIT_CORE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ULIMIT=""
  local HITS=""

  # SUPPLEMENTAL STUFF HERE
  fnBANNER "ULIMIT AND CORE DUMPS (***)"
  ulimit -a
  echo

  ULIMIT=$(ulimit -c)
  case ${ULIMIT} in
    "0")
      echo " Core dumps are disabled..."
      echo "ulimit = 0"
      ;;
    "unlimited")
      echo " Core dumps are enabled..."
      echo "ulimit = unlimited"
      ;;
    *)
      echo " Core dumps are enabled..."
      echo "ulimit = ${ULIMIT}"
      ;;
  esac
  echo

  HITS=$(find /etc/security/limits* -type f -exec grep core {} \; | grep -v "^#")
  if [[ -n "${HITS}" ]]
  then
    echo " Core dumps are enabled globally in /etc/security/limits*..."
    echo "${HITS}"
    echo
  fi

  HITS=$(find /etc/systemd/system.conf -type f -exec grep DefaultLimitCORE {} \; | grep -v "^#")
  if [[ -n "${HITS}" ]]
  then
    echo " Default global core dump limit in /etc/systemd/system.conf..."
    echo "${HITS}"
    echo
  fi

  if [[ -f /etc/systemd/coredump.conf ]]
  then
    echo " Contents of /etc/systemd/coredump.conf..."
    grep -v "^# " < /etc/systemd/coredump.conf 2>/dev/null | grep -v "^#$" | grep -v "^$"
    echo
  fi

  if [[ "$(journalctl -xe | grep "dumped core")" != "" ]]
  then
    echo " journalctl -xe..."
    journalctl -xe | grep "dumped core"
    echo
  fi

  if type -path coredumpctl >/dev/null 2>&1
  then
    echo " journalctl reports the following core dumps..."
    ${SUDO} coredumpctl list 2>&1
    echo
    echo " Core dumps present in /var/lib/systemd/coredump..."
    ls -l /var/lib/systemd/coredump
    echo
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnQUOTAS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path repquota >/dev/null 2>&1
  then
    if [[ "$(grep "quota=" /etc/fstab 2>/dev/null | grep -v "^#")" != "" ]]
    then
      fnBANNER "QUOTAS (***)"
      echo " The following filesystems are configured for quotas..."
      grep "quota=" /etc/fstab 2>/dev/null | grep -v "^#"
      echo
      ${SUDO} repquota -u -g -v -a -s -t | grep -v "^#"
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnOVERLAYFS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MOUNT_STATUS=""

  if [[ "$(grep "boot=overlay" /boot/cmdline.txt)" != "" ]]
  then
    fnBANNER "OVERLAY FILESYSTEM"
    echo "Found \"boot=overlay\" in cmdline.txt"
    echo
    echo "Fhe following initrd.img overlay files are in /boot:"
    find /boot -print | grep initrd.img
    echo
    echo "Mounted overlay filesystems:"
    df -Th -t overlay 2>&1
    echo
    echo "Checking fstab for read-only /boot filesystem:"
    grep /boot /etc/fstab | grep "ro" | grep -v "^#"
    echo
    echo "Current status of /boot filesystem:"
    MOUNT_STATUS="$(mount | grep "/boot" | cut -f2 -d'(' | cut -f1 -d",")"
    case ${MOUNT_STATUS} in
      "rw") echo "/boot is currently read-write"
        ;;
      "ro") echo "/boot is currently read-only"
        ;;
      *)    echo "unknown"
        ;;
    esac
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnCODECS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CODEC=""
  local STATUS=""
  local LIC_STATUS=""

  fnBANNER "HARDWARE-ACCELERATED CODECS"
  # FOR THE PI 4B, 400, and CM4...
  # On theses Pi models, hardware decoding for MPG2 and WVC1
  # is disabled and cannot be enabled even with a license key.
  # These Pis, with their increased processing power compared to
  # earlier models, can decode these in software such as VLC.
  # MPG4, H263, MPG2, and WVC1 hardware decode options have all
  # been dropped, on these Pis.  The ARM cores on the Pi4 are more
  # than capable of decoding those formats at better that real-
  # time.  (There is no real material >1080p using those codecs.)
  #
  # FOR OLDER MODELS...
  # Hardware decoding of MPG2 and WVC1 requires license keys,
  # purchased seperately.
  CODEC=""
  STATUS=""
  for CODEC in AGIF FLAC H263 H264 MJPA MJPB MJPG MPG2 MPG4 MVC0 " PCM" THRA VORB " VP6" " VP8" WMV9 WVC1
  do
    STATUS=$(vcgencmd codec_enabled "${CODEC}" | cut -f2 -d"=")
    # These two codecs...
    if [[ "${CODEC}" = "MPG2" ]] || [[ "${CODEC}" = "WVC1" ]]
    then
      # ...on models other than the 4B...
      if [[ "${PI4_FAMILY}" != "1" ]]
      then
        # ...if enabled...
        if [[ "${STATUS}" = "enabled" ]]
        then
          #... are marked as licensed.
          LIC_STATUS="(licensed)"
        else
          # If not enabled on these models, a license is required to enable.
          LIC_STATUS="(license required to enable)"
        fi
        # We then show their status (including whether licensed).
        echo "${CODEC}: ${STATUS} ${LIC_STATUS}"
      else
        # For other codecs, just show their status.
        echo "${CODEC}: ${STATUS}"
      fi
    else
      # Otherwise, show each codec's status, without concern for license.
      echo "${CODEC}: ${STATUS}"
    fi
  done
  echo
  echo "Note 1: VP6, VP8, and MJPG are not handled by the hardware video decoder"
  echo "in the Broadcom BCM2835 processor, but by the VideoCore GPU.  Enable these"
  echo "by running:  sudo raspi-config -> Interfacing Options -> Camera -> Enable"
  echo "or by adding \"start_x=1\" to /boot/config.txt"
  echo
  echo "Note 2: GPU hardware-accelerated codecs will be disabled if \"gpu_mem=16\"."
  echo "At least \"gpu_mem=96\" is required for the codecs to run correctly."
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnV4L2CODECS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "V4L2-CTL CODECS"
  v4l2-ctl -d 10 --list-formats-out
  if [[ "$(v4l2-ctl -d 10 --list-formats-out | grep "Pixel")" = "" ]]
  then
    echo
  fi
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo "Note: The H.265 codec, new w/ the Pi 4B, isn't part of the videocore."
    echo "It's an entirely new block on the chip, so the VC6 knows nothing"
    echo "about it.  Therefore, vcgencmd (which talks to the VC6) also knows"
    echo "nothing about it.  The v4l2-ctl command used here, however, should"
    echo "show the H.265 codec, when enabled, on Pi 4B, 400, and CM4 models."
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnV4LDEV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DEV=""

  # The Pi itself, will have /dev/video10 (decode), /dev/video11 (encode),
  # and /dev/video12 (resize & format conversion) V4L devices.  What we
  # want to look at here is any other V4L device found on the system, such
  # as TV tuners.
  fnBANNER "VIDEO4LINUX DEVICES"
  v4l2-ctl --list-devices 2>/dev/null || :
  for DEV in $(v4l2-ctl --list-devices 2>/dev/null | grep /dev/)
  do
    fnBANNER "VIDEO4LINUX DEVICE ${DEV}"
    v4l2-ctl -d "${DEV}" --all
    echo
  done
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnCAMERA()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CAMERA (CSI)"
  # Refers to the small cameras that plug into the Pi's CSI connector
  vcgencmd get_camera
  if [[ "$(vcgencmd get_config disable_camera_led | cut -f2 -d"=")" -eq 1 ]]
  then
    echo
    echo "Camera LED is disabled during record."
  fi
  echo
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
fn1W()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DRIVER=""

  if [[ -d /sys/bus/w1/devices ]]
  then
    fnBANNER "W1-GPIO (1-WIRE INTERFACE) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep w1_gpio
    echo
    echo " Discovered 1-WIRE Drivers..."
    find /sys/bus/w1/drivers -type d | grep -v "^.$" | grep -v /drivers$ | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
    echo " 1-WIRE Addresses in /sys/bus/w1/devices..."
    ls -1 /sys/bus/w1/devices 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
fnSPI()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DRIVER=""

  if [[ "$(lsmod | grep spi)" != "" ]]
  then
    fnBANNER "SPI (SERIAL PERIPHERAL INTERFACE) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep spi
    echo
    echo " Discovered SPI Drivers..."
    find /sys/bus/spi/drivers -type d | grep -v "^.$" | grep -v "/drivers$" | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
fnI2S()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DRIVER=""

  if [[ "$(lsmod | grep i2s)" != "" ]]
  then
    fnBANNER "I2S (INTER-IC SOUND) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep i2s
    echo
    echo " Discovered I2S Drivers..."
    find /sys/bus/platform/drivers/*i2s -maxdepth 0 | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER, fnSUB_BANNER
#
fnI2C()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DRIVER=""
  local BUS=""
  local NUM=""

  if [[ "$(lsmod | grep i2c)" != "" ]]
  then
    fnBANNER "I2C (INTER-IC COMMUNICATION) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep i2c
    echo
    echo " Discovered I2C Drivers..."
    find /sys/bus/i2c/drivers -type d | grep -E -v "^.$|/drivers$|/dummy$|/stmpe-i2c$" | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
  fi

  # If i2c is enabled, probe for i2c busses
  if [[ "$(grep "^dtparam=i2c_arm=on" /boot/config.txt 2>/dev/null)" != "" ]]
  then
    fnBANNER "I2CDETECT"
    i2cdetect -l 2>&1 | sort
    echo
    i2cdetect -l 2>&1 | sort | awk '{ print $1 }' | cut -f2 -d'-' | while read -r BUS
    do
      echo " I2C BUS: ${BUS}"
      i2cdetect -y "${BUS}" 2>&1
      echo
    done
  fi

  if [[ "$(grep i2c /boot/config.txt 2>/dev/null | grep -v "^#")" != "" ]]
  then
    fnSUB_BANNER "I2C-related entries in config.txt"
    grep i2c /boot/config.txt 2>/dev/null | grep -v "^#"
    echo
  fi

  i2cdetect -l | awk '{ print $1 }' | cut -f2 -d'-' | sort -n | while read -r NUM
  do
    echo "-------------------"
    dtoverlay -h i2c"${NUM}" | grep -v "^$"
  done
  echo

  ls -l /dev/i2c*
  echo
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnRTC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # If the user has a realtime clock installed and configured...
  if [[ -c /dev/rtc0 ]] || [[ -L /dev/rtc ]]
  then
    fnBANNER "RTC (REALTIME CLOCK)"
    dmesg | grep rtc | grep -v "Modules linked in:" | grep -v crtc
    echo
    lsmod | grep rtc
    echo
    ls -l /dev/rtc*
    echo
    echo "Hardware RTC says:"
    ${SUDO} hwclock
    echo
    echo "Operating System says:"
    date
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnHWRNG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  # If Hardware Random Number Generator is enabled, and daemon is running...
  if [[ -c /dev/hwrng ]] && [[ -n "$(ps -ef | pgrep rngd)" ]]
  then
    # ...and if the test tool is available...
    if type -path rngtest >/dev/null 2>&1
    then
      fnBANNER "HARDWARE RANDOM NUMBER GENERATOR (***)"
      ${SUDO} cat /dev/hwrng 2>/dev/null | rngtest -c 1000 2>&1 || :
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnHWWD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DIR=""

  # SUPPLEMENTAL STUFF HERE
  # If the watchdog timer is enabled...
  if [[ "$(systemctl | grep watchdog.service)" != "" ]]
  then
    fnBANNER "BROADCOM WATCHDOG TIMER (***)"
    dmesg | grep watchdog
    echo
    grep -E -v "^$|^#" < /etc/watchdog.conf 2>/dev/null
    echo
    DIR="$(awk '/^test-directory/ { print $3 }' /etc/watchdog.conf)"
    if [[ -n "${DIR}" ]]
    then
      echo "Contents of ${DIR}:"
      ls -l "${DIR}"
      echo
    fi
    DIR="$(awk '/^log-dir/ { print $3 }' /etc/watchdog.conf)"
    if [[ -n "${DIR}" ]]
    then
      echo "Contents of ${DIR}:"
      ls -l "${DIR}"
      echo
    fi
    systemctl status watchdog.service | tee /dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnUSB_DEV_INFO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "USB AND OTHER DEVICE INFO"
  lsusb | sort
  echo
  cat /tmp/.lshw_businfo."${PPID}" 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnLSHW_INPUT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n "${LSHW_INPUT}" ]]
  then
    fnBANNER "INPUT DEVICES"
    ${SUDO} lshw -class input 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnLSHW_GENERIC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n "${LSHW_GENERIC}" ]]
  then
    fnBANNER "GENERIC DEVICES"
    ${SUDO} lshw -class generic 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnRTL_SDR()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  # Note: A bug in the Pi 4B's USB (xhci host controllers that don't update
  # endpoint DCS) may affect test results.  The following commands can update
  # your firmware to correct the issue, if needed:
  # sudo apt update
  # sudo apt install rpi-eeprom
  # sudo rpi-eeprom-update -a
  # sudo reboot
  if type -path rtl_eeprom >/dev/null 2>&1 && type -path rtl_test >/dev/null 2>&1
  then
    if [[ "$(lsmod | grep rtl2832)" != "" ]]
    then
      fnBANNER "RTL-SDR TUNER (***)"
      rtl_eeprom 2>&1
      echo
      rtl_test -t 2>&1 | grep ^S
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnLSHW_STORAGE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n "${LSHW_STORAGE}" ]]
  then
    fnBANNER "STORAGE DEVICES"
    ${SUDO} lshw -class storage 2>/dev/null
    echo
    ${SUDO} lshw -short -class disk -class storage -class volume 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
#
fnSMART()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DEV=""
  local MOUNTPOINT=""
  local NOATIME=""

  # SUPPLEMENTAL STUFF HERE
  if type -path smartctl >/dev/null 2>&1
  then
    fnBANNER "USB ATA/SATA & SCSI/SAS STORAGE WITH SMART TECHNOLOGY (***)"
    if [[ "$(smartctl --scan -d sat | grep -v aborted)" != "" ]]
    then
      echo "Scanning Devices..."
      smartctl --scan -d sat | grep -v aborted
      echo
      fnSUB_BANNER "Checking \"noatime\" mount option on ATA/SATA and SCSI/SAS filesystems"
      echo "The \"noatime\" option disables updates to the access timestamp of an inode,"
      echo "whenever a file is accessed (eg: when files are merely read.)  Disabling"
      echo "these updates eliminates a huge number of writes to a device over time,"
      echo "especially on filesystems that host the operating system itself.  This is"
      echo "particularly important for SD & SSD devices, as excessive writes will shorten"
      echo "the lifespan of the device.  Mechanical drives can also benefit, from the"
      echo "ever-so-slight performance gain."
      echo
      echo "This check examines mounted filesystems ONLY."
      echo
      smartctl --scan -d sat | grep -v aborted | awk '{ print $1 }' | while read -r DEV
      do
        lsblk --ascii "${DEV}" -o name,mountpoint | grep -v SWAP | grep -v MOUNTPOINT | grep "/" | awk '{ print $NF }' | sort -u | while read -r MOUNTPOINT
        do
          NOATIME="$(grep -E -v "^#|^$" < /etc/fstab | awk '{ print $2 " " $4 }' | grep "^${MOUNTPOINT} " | grep "noatime")"
          printf "%-16s" "${MOUNTPOINT}"
          if [[ -n "${NOATIME}" ]]
          then
            echo ": noatime is specified for this filesystem, in /etc/fstab"
          else
            echo ": noatime is not specified for this filesystem, in /etc/fstab"
          fi
        done
      done
      echo
      fnSUB_BANNER "Active statements in /etc/smartd.conf:"
      grep -E -v "^#|^$" /etc/smartd.conf
      echo
      fnSUB_BANNER "SMARTD.SERVICE"
      systemctl status smartd.service
      echo
      smartctl --scan -d sat | grep -v aborted | awk '{ print $1 }' | while read -r DEV
      do
        fnBANNER "SMART DEVICE: ${DEV}"
        ${SUDO} smartctl --info "${DEV}" -d sat
        fnSUB_BANNER "Full Device Details..."
        ${SUDO} smartctl -d sat --xall "${DEV}"
      done
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnQUIRKS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(grep "quirks" /boot/cmdline.txt)" != "" ]]
  then
    fnBANNER "USB STORAGE QUIRKS CHECK"
    echo "USB storage \"quirks\" statement found in cmdline.txt."
    echo "The \"quirks\" directive disables UAS for a given storage device."
    echo "Disabling UAS also disables the trim functions of the device."
    echo "At least one USB storage device may not be capable of \"trim\"."
    echo
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
#
fnTRIM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local FSTRIM_STATUS=""

  if [[ "$(find /etc/udev -type f -exec grep unmap {} \; | grep -v "^#")" != "" ]]
  then
    fnBANNER "USB STORAGE WITH TRIM"
    ${SUDO} fstrim --all -v 2>/dev/null
    FSTRIM_STATUS=${?}
    case ${FSTRIM_STATUS} in
      0|64)
        echo
        fnSUB_BANNER "UDEV RULES FOR TRIM"
        find /etc/udev -type f -exec grep unmap {} \; -print | grep -v "^#"
        echo
        fnSUB_BANNER "FSTRIM.TIMER"
        systemctl status fstrim.timer
        echo
        if [[ "$(grep discard /etc/fstab 2>/dev/null)" != "" ]]
        then
          fnSUB_BANNER "DISCARD ENTRIES IN FSTAB"
          grep discard /etc/fstab 2>/dev/null
          echo
        fi
        ;;
      *)
        ;;
    esac
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnBLKID()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "DISK CONFIGURATION"
  ${SUDO} blkid | grep -v zram | sort
  echo
  lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL,UUID,PARTUUID,MODEL | grep -v zram
  echo
  df -h -T | grep -v tmpfs
  echo
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
#
fnRAID()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MD=""
  local UUID=""
  local FSTAB=""
  local DEV=""

  # SUPPLEMENTAL STUFF HERE
  if [[ -e /proc/mdstat ]]
  then
    fnBANNER "RAID ARRAY CONFIGURATION (***)"
    grep "^[a-zA-Z]" < /proc/mdstat 2>/dev/null
    echo
    echo "Contents of /etc/mdadm/mdadm.conf..."
    grep -E -v "^$|^#" < /etc/mdadm/mdadm.conf 2>/dev/null
    echo
    grep ^md < /proc/mdstat 2>/dev/null | awk '{ print $1 }' | while read -r MD
    do
      fnSUB_BANNER "RAID ARRAY DEVICE /dev/${MD} (***)" | tr '[:lower:]' '[:upper:]'
      ${SUDO} mdadm --query /dev/"${MD}" 2>/dev/null | sed 's/ Use mdadm --detail for more detail.//'
      echo
      UUID=$(blkid | grep "/dev/${MD}:" | awk '{ print $2 }' | cut -f2 -d"\"")
      FSTAB=$(grep "${UUID}" /etc/fstab 2>/dev/null || :)
      if [[ -n "${FSTAB}" ]]
      then
        echo "/etc/fstab entry..."
        echo "${FSTAB}"
        echo
        df -h "$(grep "${UUID}" /etc/fstab 2>/dev/null | awk '{ print $2 }')"
        echo
      fi
      ${SUDO} mdadm --detail /dev/"${MD}"
      echo
      ${SUDO} mdadm --detail /dev/"${MD}" | awk '{ print $NF }' | grep /dev/ | grep -v "/dev/${MD}:" | while read -r DEV
      do
        fnSUB_BANNER "RAID ARRAY DEVICE /dev/${MD} - COMPONENT ${DEV} (***)" | tr '[:lower:]' '[:upper:]'
        ${SUDO} mdadm --query "${DEV}" 2>/dev/null | grep -v "is not an md array" | sed 's/  Use mdadm --examine for more detail.//'
        echo
        ${SUDO} mdadm --examine "${DEV}"
        echo
      done
    done
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
#
fnLVM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path vgdisplay >/dev/null 2>&1
  then
    if [[ -n "$(${SUDO} vgdisplay 2>/dev/null)" ]]
    then
      fnBANNER "LOGICAL VOLUME MANAGER CONFIGURATION (***)"
      echo "LOGICAL VOLUMES..."
      ${SUDO} lvs 2>&1
      echo
      ${SUDO} lvdisplay 2>&1

      fnSUB_BANNER "VOLUME GROUPS..."
      ${SUDO} vgs 2>&1
      echo
      ${SUDO} vgdisplay 2>&1

      fnSUB_BANNER "PHYSICAL VOLUMES..."
      ${SUDO} pvs 2>&1
      echo
      ${SUDO} pvdisplay 2>&1
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnHDPARM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DEV=""

  # SUPPLEMENTAL STUFF HERE
  if type -path hdparm >/dev/null 2>&1
  then
    stat /dev/sd? | grep "File:" | awk '{ print $NF }' | while read -r DEV
    do
      fnBANNER "HDPARM ATA/SATA DEVICE PARAMETERS - ${DEV} (***)" | grep -v "^$"
      ${SUDO} hdparm -I --verbose "${DEV}" 2>/dev/null
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnFSTAB()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -f /etc/fstab ]]
  then
    fnBANNER "FSTAB FILE"
    grep -E -v "^$|^#" < /etc/fstab 2>/dev/null
    echo
  else
    # In truth, I can't envision a booted/running system without this file.
    echo "Missing file /etc/fstab" >&2
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnLSHW_MM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n "${LSHW_MULTIMEDIA}" ]]
  then
    fnBANNER "MULTIMEDIA DEVICES"
    ${SUDO} lshw -class multimedia 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnALSA_MOD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -e /proc/asound/modules ]]
  then
    fnBANNER "ALSA MODULES"
    cat /proc/asound/modules 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnALSA_HW()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -e /proc/asound/cards ]]
  then
    fnBANNER "ALSA SOUND HARDWARE"
    cat /proc/asound/cards 2> /dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnALSA_CARD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -e /proc/asound/cards ]]
  then
    grep "^ [0123]" < /proc/asound/cards 2>/dev/null | awk '{ print $1 }' | while read -r CARD_NUM
    do
      fnBANNER "ALSA CARD-${CARD_NUM} INFO"
      amixer -c "${CARD_NUM}" 2>/dev/null
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnALSA_PB_CAP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ALSA PLAYBACK AND CAPTURE DEVICES"
  if [[ "$(aplay -l 2>/dev/null | grep ^card)" != "" ]]
  then
    aplay -l 2>/dev/null
  else
    aplay -l 2>/dev/null | grep PLAYBACK
    echo "No playback device found"
  fi
  echo
  if [[ "$(arecord -l 2>/dev/null | grep ^card)" != "" ]]
  then
    arecord -l 2>/dev/null
  else
    arecord -l 2>/dev/null | grep CAPTURE
    echo "No capture device found"
  fi
  echo
}

#---------------
# Called by fnGROUP_SERIAL_BT
# Calls fnBANNER
#
fnACM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -c /dev/ttyACM0 ]] || [[ -c /dev/ttyACM1 ]]
  then
    if [[ -n "${LSHW_COMMUNICATION}" ]]
    then
      fnBANNER "ACM COMMUNICATION DEVICES"
      ${SUDO} lshw -class communication 2>/dev/null
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_SERIAL_BT
# Calls fnBANNER, fnSUB_BANNER
#
fnSERIAL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local SERIAL_DEV=""
  local NUM=""
  local UART_TYPE=""
  local DEVICE=""

  fnBANNER "UARTS AND USB SERIAL PORTS"
  # By default, on Raspberry Pis equipped with wireless/Bluetooth module,
  # (Raspberry Pi 3 and Raspberry Pi Zero W), the PL011 UART is connected
  # to the Bluetooth module, while the mini UART is used as the primary
  # UART and will have a Linux console on it.  On all other models, the
  # PL011 is used as the primary UART.
  #
  # In Linux device terms, by default, /dev/ttyS0 refers to the mini UART,
  # and /dev/ttyAMA0 refers to the PL011.  The primary UART is the one
  # assigned to the Linux Console, which depends on the Raspberry Pi model
  # as described above.  There are also symlinks: /dev/serial0, which
  # always refers to the primary UART (if enabled), and /dev/serial1,
  # which similarly always refers to the secondary UART (if enabled.)
  #
  # The Pi 4B allows up to 4 additional hardware UARTS (2 thru 5) to be defined.
  # uart2 uses pins that could conflict with the camera and any kind of "hat"
  # with eeprom.  Also If you enable the handshake, I2C1 has to be disabled.
  # Uart3 use GPIO4 then you should consider to change 1 wire GPIO pin if you
  # need 1 wire.  It also uses GPIO7 if you enable handshake then you need to
  # disable SPI.  Uart4 uses the SPI GPIOs.  SPI needs to be disabled.
  # No conflict with uart5. This is the safest one to use.

  # IN OTHER WORDS:
  # On all Pis, UART0 is a PL011 that appears to Linux as ttyAMA<n>,
  # and UART1 is an 8250 clone that appears as ttyS0.  On a Pi4,
  # UART2-5 are additional PL011s that also appear as ttyAMA<n>.
  # The number starts at 0 for the first enabled PL011 and counts
  # up through all the enabled interfaces.  The numbering is stable
  # for any given combination of UARTs, but enabling or disabling
  # one can change the number assignments of others.
  #
  # Adding "enable_uart=1" to config.txt on a Pi4 enables ttyS0 (UART1)
  # on GPIOs 14 & 15 (Alt5), leaving UART0 driving the Bluetooth
  # interface on 30-33 (Alt3).  Adding "dtoverlay=disable-bt" switches
  # the UART roles so that UART0 is mapped to 14 & 15 (Alt0), leaving
  # UART1 unmapped.

  ls -l /dev/ttyAMA? /dev/serial? /dev/ttyS? /dev/ttyACM? 2>/dev/null
  echo

  fnSUB_BANNER "On-board (non-USB) serial ports"
  dmesg | grep MMIO | awk '{ print $4 }' | while read -r MMIO
  do
    SERIAL_DEV="$(dmesg | grep "${MMIO}" | cut -f2 -d':' | cut -f2 -d')' | sed 's/is a//')"
    printf '%8s: %s\n' "${MMIO}" "${SERIAL_DEV}"
  done
  echo

  if [[ "$(grep uart /boot/config.txt 2>/dev/null | grep -v "^#")" != "" ]]
  then
    fnSUB_BANNER "UART-related entries in config.txt"
    grep uart /boot/config.txt 2>/dev/null | grep -v "^#"
    echo
  fi

  grep "^dtoverlay=uart" /boot/config.txt 2>/dev/null | cut -f2 -d'=' | cut -f1 -d',' | cut -c 5 | while read -r NUM
  do
    fnSUB_BANNER "${MY_MODEL_NAME} UART #${NUM}"
    dtoverlay -h uart"${NUM}" | grep -v "^$"
    echo
    raspi-gpio get 0-15 | grep -v PUT | awk '{ print $1" "$2" "$6 }' | grep "${NUM}$"
    echo
  done

  for NUM in 0 1 2 3 4 5
  do
    if [[ -c /dev/ttyACM${NUM} ]]
    then
      UART_TYPE=$(dmesg | grep ttyACM"${NUM}" | cut -f4 -d':' | cut -c2-)
      DEVICE=": $(systemctl list-units --all | grep dev-ttyACM"${NUM}".device | sed 's/plugged/plugged:/' | cut -f2- -d':' | sed 's/   //')"
      fnSUB_BANNER "/dev/ACM${NUM}... ${UART_TYPE}${DEVICE}"
      stty -a -F /dev/ttyACM"${NUM}"
      echo
    fi
  done
  for NUM in 0 1 2 3 4 5
  do
    if [[ -c /dev/ttyAMA${NUM} ]]
    then
      fnSUB_BANNER "/dev/ttyAMA${NUM}..."
      stty -a -F /dev/ttyAMA"${NUM}"
      echo
    fi
  done
  for NUM in 0 1 2 3 4 5
  do
    if [[ -c /dev/ttyS${NUM} ]]
    then
      fnSUB_BANNER "/dev/ttyS${NUM}..."
      stty -a -F /dev/ttyS"${NUM}"
      echo
    fi
  done
}

#---------------
# Called by fnGROUP_SERIAL_BT
# Calls fnBANNER
#
fnBT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PS_BT=""
  local BTMAC_OUT=""
  local BTDEFAULT=""
  local BTMAC=""
  local BTSHOW_OUT=""
  local BTPAIRED_OUT=""

  # Make sure bluetoothd is running, because if not,
  # the bluetoothctl commands used here will hang.
  PS_BT=$(pgrep bluetoothd)
  if [[ -n "${PS_BT}" ]]
  then
    #---------------
    fnBANNER "BLUETOOTH CONTROLLERS"
    hciconfig
    BTMAC_OUT="$(echo list | ${SUDO} bluetoothctl 2>/dev/null)"
    BTDEFAULT=$(echo "${BTMAC_OUT}" | grep ^Controller | grep "default" | awk '{ print $2 }')
    BTMAC=""
    echo "${BTMAC_OUT}" | grep ^Controller | awk '{ print $2 }' | while read -r BTMAC
    do
      if [[ "${BTDEFAULT}" = "${BTMAC}" ]]
      then
        echo "Default BT Controller..."
      else
        echo "Additional (Non-default) BT Controller..."
      fi
      BTSHOW_OUT="$(echo show "${BTMAC}" | ${SUDO} bluetoothctl 2>/dev/null)"
      echo "${BTSHOW_OUT}" | grep -v -F "[" | grep -v "^$" | grep -v "Agent registered" | grep -v "Device registered not available"
      echo
    done
    #---------------
    fnBANNER "BLUETOOTH DEVICES (paired w/ default controller)"
    BTPAIRED_OUT="$(echo paired-devices | ${SUDO} bluetoothctl 2>/dev/null)"
    if [[ -n "${BTPAIRED_OUT}" ]]
    then
      echo "${BTPAIRED_OUT}" | grep -v -F "[" | awk '{ print $2 }' | while read -r BTMAC
      do
        echo "info ${BTMAC}" \
          | ${SUDO} bluetoothctl 2>/dev/null \
          | grep -v -F "[" \
          | grep -v "^$" \
          | grep -v "Agent registered" \
          | grep -v "Device registered not available" \
          || :
      done
      echo
    fi
  else
    #---------------
    fnBANNER "bluetoothd daemon not running"
    echo
  fi
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
#
fnMEMSWAP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "MEMORY AND SWAP"
  free -h
  echo
  swapon --summary
  echo
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
#
fnMEMINFO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local NAME=""
  local BYTES=""
  local SUFFIX=""

  if [[ -e /proc/meminfo ]]
  then
    fnBANNER "MEMINFO"
    while read -r NAME BYTES SUFFIX
    do
      printf '%-16s %10d %s\n' "${NAME}" "${BYTES}" "${SUFFIX}"
    done < /proc/meminfo
    echo
  fi
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
#
fnIPC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "IPC STATUS"
  lsipc
  echo
  ipcs -u
  ipcs -m
  ipcs -q
  ipcs -s
  ipcs -l
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
#
fnDMESG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "DMESG - WARNINGS"
  dmesg | grep -i warn
  echo
  fnBANNER "DMESG - FAILURES"
  dmesg | grep -i fail
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSTEMD_CHAIN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMD-ANALYZE CRITICAL-CHAIN"
  systemctl list-jobs
  echo
  systemd-analyze time
  echo
  systemd-analyze critical-chain
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSTEMD_BLAME()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMD-ANALYZE BLAME"
  # the tee eliminates the pause every screenfull
  systemd-analyze blame | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSTEMD_SECURITY()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMD-ANALYZE SECURITY"
  # the tee eliminates the pause every screenfull
  # and gets rid of the color
  systemd-analyze security | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSCTL_STATUS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMCTL STATUS"
  # the tee eliminates the pause every screenfull
  systemctl status | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSCTL_FAIL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMCTL UNIT FAILURES"
  systemctl list-units --failed --all | grep -v "list-unit-files"
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSCTL_LIST()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMCTL LIST-UNIT-FILES"
  # the tee eliminates the pause every screenfull
  systemctl list-unit-files | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
#
fnJOURNAL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -d /var/log/journal ]]
  then
    if [[ "$(stat /var/log/journal | grep "Access" | grep "2755" | grep "root" | grep "systemd")" != "" ]]
    then
      fnBANNER "PERSISTENT JOURNALING"
      echo "Persistent Journaling is configured"
      ls -ld /var/log/journal
      echo
      ${SUDO} journalctl --sync
      ${SUDO} journalctl --flush
      ${SUDO} journalctl -b | grep "System journal"  | tail -1 | cut -f4- -d":"
      ${SUDO} journalctl -b | grep "Runtime journal" | tail -1 | cut -f4- -d":" | sed 's/^ //'
      echo
      echo "Journaled boots..."
      journalctl --list-boots
      echo
      journalctl --disk-usage
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
#
fnRSYSLOG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PERL_SCRIPT=""

  # SUPPLEMENTAL STUFF HERE
  # Logic in this module is shamelessly based on syslogconf,
  # by Michael Hill, Lockheed Martin Astronotics, Denver, CO
  # Perl is used here because bash sucks at nesting associative arrays.
  if type -path perl >/dev/null 2>&1 && type -path m4 >/dev/null 2>&1
  then
    fnBANNER "RSYSLOG.CONF ANALYSIS (***)"
    echo "This module creates a comprehensive listing of rsyslog.conf event logging."
    echo "The selector selects all messages of equal or higher severity.  For example,"
    echo "news.err really means news.err, news.crit, news.alert, news.emerg.  And"
    echo "mail,uucp.alert means mail.alert, mail.emerg, uucp.alert, and uucp.emerg."
    echo
    echo "Some versions of syslog allow an = character before the level specifier"
    echo "(as in news.=err) to act only on messages of that level."
    echo
    echo "The output below interprets the directives to show where things are going."
    echo

    PERL_SCRIPT=$(cat <<'EOF'
select (STDERR); $| = 1;        # Turn off buffered I/O
select (STDOUT); $| = 1;
($progname = $0) =~ s/.*\///;
chop ($uname = `uname -nsr`);
@uname = split (' ', $uname);

sub fatal {
  local ($errMesg, $errCode) = (@_);

  printf (STDERR "$progname:  %s\n", $errMesg);
  exit ($errCode);
}

$rsyslogconf = '/etc/rsyslog.conf';
$loghost = '';
@facilities = ('kern', 'user', 'mail', 'daemon',
  'auth', 'lpr', 'news', 'uucp', 'cron', 'local0',
  'local1', 'local2', 'local3', 'local4', 'local5',
  'local6', 'local7', 'mark');
@levels = ('emerg', 'alert', 'crit', 'err', 'warning',
  'notice', 'info', 'debug');

for $facil (@facilities) {
  for $lev (@levels) {
    $event_type{"$facil.$lev"} = 'no action';
  }
}
for $i ($[ .. $#levels) {
  $severity{$levels[$i]} = $i;
}

($name) = gethostbyname ('loghost');
if ($name eq $hostname) {
  # we're running on 'loghost'
  $loghost = '-DLOGHOST';
}

open (SYSLOGCONF, "m4 $loghost $rsyslogconf |") ||
  &fatal ("can't open 'm4 $rsyslogconf'", 2);

while (<SYSLOGCONF>) {
  local (%eventlist);

  next if (/^\s*$/ || /^\s*#/);
  chop;

  %eventlist = ( );
  ($events, $action) = split (/\t+/);
  next if ($action eq '');

  # parse for multiple events
  @events = split (';', $events);
  for $event (@events) {
    local ($thislev, $evt);

    ($facils, $level) = split ('\.', $event);
    $thislev = $severity{$level};

    # parse for multiple facility specifications
    if ($facils eq '*') {
      @facils = grep (! /mark/, @facilities);
    } else {
      @facils = split (',', $facils);
    }
    if ($level eq 'none') {
      @levs = @levels;
    } else {
      @levs = grep ($severity{$_} <= $thislev, @levels);
    }
    for $facil (@facils) {
      for $lev (@levs) {
        if ($level eq 'none') {         # delete entry
          delete ($eventlist{"$facil.$lev"})
            if ($eventlist{"$facil.$lev"});
        } else {                        # add entry
          $eventlist{"$facil.$lev"} = 1;
        }
      }
    }
  }
  for $evt (keys (%eventlist)) {
    if ($event_type{$evt} eq 'no action') {
      $event_type{$evt} = $action;
    } else {
      $event_type{$evt} .= ", $action";
    }
  }
}

close (SYSLOGCONF);

for $key (sort (keys (%event_type))) {
  printf ("Event:  %-16s\tAction:  %s\n", $key,
    $event_type{$key});
}

exit (0);
EOF
    )
    perl -e "${PERL_SCRIPT}"
    echo
  fi
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
#
fnLOGROTATE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "LOGROTATE"
  echo " Contents of /etc/logrotate.conf:"
  grep -v "^$" /etc/logrotate.conf
  echo
  echo " ----------------------------------------------------"
  echo " logrotate config files in /etc/logrotate.d ..."
  ls /etc/logrotate.d
  echo
  if [[ "$(systemctl | grep "logrotate.timer")" != "" ]]
  then
    echo " ----------------------------------------------------"
    systemctl status logrotate.timer
    echo
  fi
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnRCLOCAL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -f /etc/rc.local ]]
  then
    fnBANNER "CONTENTS OF RC.LOCAL"
    grep -E -v "^$|^#" < /etc/rc.local 2>/dev/null
    echo
  else
    echo "Missing file /etc/rc.local" >&2
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnLOCALE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -f /etc/default/locale ]] && [[ -f /etc/default/keyboard ]] && [[ -f /etc/default/console-setup ]] && [[ -f /etc/timezone ]]
  then
    fnBANNER "LOCALIZATION SETTINGS"
    . /etc/default/locale
    . /etc/default/keyboard
    . /etc/default/console-setup
    echo "Language : ${LANG}"
    echo "KB Model : ${XKBMODEL}"
    echo "KB Layout: ${XKBLAYOUT}"
    echo "Char. Map: ${CHARMAP}"
    echo "Timezone : $(cat /etc/timezone 2>/dev/null)"
    echo
  else
    echo "Unable to determine locale settings on this Pi.  Skipping."
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER, fnSUB_BANNER
#
fnLIRC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local LIRC=""
  local SERVICE=""

  # SUPPLEMENTAL STUFF HERE
  if [[ -n "$(find /dev/lirc* -print 2>/dev/null)" ]]
  then
    fnBANNER "LIRC - LINUX INFRA-RED COMMUNICATION DEVICES (***)"
    lsmod | grep "ir_" | sort
    echo

    fnSUB_BANNER "LIRC-related entries in config.txt"
    grep gpio-ir /boot/config.txt 2>/dev/null | grep -v "^#"
    echo

    fnSUB_BANNER "LIRC config files"
    find /etc/lirc* -print | grep conf$
    echo

    fnSUB_BANNER "LIRC device nodes"
    find /dev/lirc* -print | while read -r LIRC
    do
      ls -l "${LIRC}"
    done
    echo

    fnSUB_BANNER "LIRC device tree overlays"
    if [[ -c /dev/lirc0 ]]
    then
      dtoverlay -h gpio-ir 2> /dev/null | grep -v "^$"
      echo
    fi
    if [[ -c /dev/lirc1 ]]
    then
      dtoverlay -h gpio-ir-tx 2> /dev/null | grep -v "^$"
      echo
    fi

    fnSUB_BANNER "LIRC dmesg log entries"
    dmesg | grep lirc | cut -f2- -d"]"
    echo

    fnSUB_BANNER "LIRC service status entries"
    for SERVICE in $(systemctl | grep lirc | awk '{ print $1 }')
    do
      systemctl status "${SERVICE}"
      echo
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnPRINTER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CUPS_RUNNING=""

  # SUPPLEMENTAL STUFF HERE
  # Not everyone has "cups" installed, so "lpstat" (part of the cups-client
  # package) is not a required dependency for this script.  If they have it,
  # great.  If not, it's no big deal.
  if type -path lpstat >/dev/null 2>&1
  then
    CUPS_RUNNING="$(lpstat -r 2>/dev/null)"
    if [[ "${CUPS_RUNNING}" = "scheduler is running" ]]
    then
      fnBANNER "PRINTER STATUS {***)"
      lpstat -t
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnTOUCH()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PI_TOUCHSCR=""

  fnBANNER "OFFICIAL 7\" TOUCHSCREEN"
  PI_TOUCHSCR="$(dmesg | grep -i ft5406 || :)"
  if [[ -n "${PI_TOUCHSCR}" ]]
  then
    echo "detected"
  else
    echo "not detected"
  fi
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER, fnSUB_BANNER
#
fnDISPLAY()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DISP_NUM=""
  local TVSTATUS=""
  local TV_OFF=""
  local DEV_ID=""
  local DEV_AUDIO=""
  local TVGROUP=""

  if [[ "${VERSION_ID}" -ne 9 ]]
  then
    # It seems that Stretch doesn't support the "-1" flag
    # for "vcgencmd display_power", to test specific displays.
    # So, skip this first section, if Stretch.
    fnBANNER "DISPLAY POWER UP STATUS"
    echo "DISPLAY         ID  STATUS"
    echo "--------------------------"
    echo -e -n "Main LCD        0"
    case $(vcgencmd display_power -1 0 | cut -f2 -d"=") in
      "0") echo "   off"
        ;;
      "1") echo "   ON"
        ;;
      *) echo "   undetected"
        ;;
    esac
    echo -e -n "Secondary LCD   1"
    case $(vcgencmd display_power -1 1 | cut -f2 -d"=") in
      "0") echo "   off"
        ;;
      "1") echo "   ON"
        ;;
      *) echo "   undetected"
        ;;
    esac
    echo -e -n "HDMI 0          2"
    case $(vcgencmd display_power -1 2 | cut -f2 -d"=") in
      "0") echo "   off"
        ;;
      "1") echo "   ON"
        ;;
      *) echo "   undetected"
        ;;
    esac
    echo -e -n "Composite       3"
    case $(vcgencmd display_power -1 3 | cut -f2 -d"=") in
      "0") echo "   off"
        ;;
      "1") echo "   ON"
        ;;
      *) echo "   undetected"
        ;;
    esac
    echo -e -n "HDMI 1          7"
    case $(vcgencmd display_power -1 7 | cut -f2 -d"=") in
      "0") echo "   off"
        ;;
      "1") echo "   ON"
        ;;
      *) echo "   undetected"
        ;;
    esac
    echo
  fi

  # Unfortunately, tvservice is useless with vc4-kms-v3d(-pi4),
  # but ok with broadcom and "fake" gl driver.
  if [[ "${DISP_DRIVER}" = "broadcom" ]] || [[ "${DISP_DRIVER}" = "fake" ]]
  then
    fnBANNER "HDMI DISPLAY DATA"
    vcgencmd dispmanx_list 2>&1
    echo
    tvservice -l 2>/dev/null
    echo
    tvservice -l 2>/dev/null | grep "Display Number" | awk '{ print $3 }' | cut -f1 -d"," | while read -r DISP_NUM
    do
      TVSTATUS="$(tvservice -s -v "${DISP_NUM}" 2>/dev/null | strings)"
      TV_OFF="$(echo "${TVSTATUS}" | awk '{ print $2 }')"
      if [[ "${TV_OFF}" = "0x120000" ]]
      then
        echo "Display ${DISP_NUM} is not HDMI... Skipping."
        echo
        continue
      else
        if [[ "${TV_OFF}" = "0x2" ]]
        then
          echo "Display ${DISP_NUM} TV is Off... Skipping."
          echo
          continue
        fi
      fi
      fnSUB_BANNER "DISPLAY NUMBER : ${DISP_NUM}"
      echo "DISPLAY STATUS : ${TVSTATUS}"

      DEV_ID="$(tvservice -n -v "${DISP_NUM}" 2>/dev/null | strings )"
      if [[ "${DEV_ID}" = "" ]]
      then
        DEV_ID="No Device Present"
      fi
      echo "EDID DEVICE ID : ${DEV_ID}"

      DEV_AUDIO="$(tvservice -a -v "${DISP_NUM}" 2>/dev/null | strings | sed 's/^     //')"
      if [[ "${DEV_AUDIO}" = "" ]]
      then
        DEV_AUDIO="No Device Present"
      fi
      echo "SUPPORTED AUDIO: ${DEV_AUDIO}"
      echo

      # Group is usually either DMT (monitors - group 2) or CEA (TV sets -
      # group 1).  This forces "custom" modes to be listed (I hope) as DMT,
      # mode 87
      TVGROUP="$(echo "${TVSTATUS}" | awk '{ print $4 }')"
      if [[ "${TVGROUP}" != "DMT" ]] && [[ "${TVGROUP}" != "CEA" ]]
      then
        TVGROUP=DMT
      fi
      tvservice --modes="${TVGROUP}" -v "${DISP_NUM}" 2>/dev/null
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnROWS_COLS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ROWS=""
  local COLS=""

  fnBANNER "CURRENT ROWS & COLUMNS"
  echo "Term type is: ${TERM}"
  echo
  if [[ "${TERM}" = "" ]] || [[ "${TERM}" = "dumb" ]]
  then
    echo "Environment variable TERM not defined."
    echo "Unable to determine rows and columns."
  else
    ROWS=$(tput lines 2>/dev/null)
    COLS=$(tput cols 2>/dev/null)
    echo "Screen is ${ROWS} rows X ${COLS} columns"
    echo
    echo "Term type characteristics from infocomp"
    echo "---------------------------------------"
    infocmp -I "${TERM}"
    echo
    echo "Term type characteristics from termcap"
    echo "---------------------------------------"
    infocmp -C "${TERM}"
  fi
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnRESOLUTION()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # 'vcgencmd get_lcd_info' is useless with vc4-kms-v3d(-pi4), but
  # ok with broadcom and "fake" gl driver.
  if [[ "${DISP_DRIVER}" = "broadcom" ]] || [[ "${DISP_DRIVER}" = "fake" ]]
  then
    fnBANNER "CURRENT SCREEN RESOLUTION"
    echo "HORIZONTAL : $(vcgencmd get_lcd_info | awk '{ print $1 }') pixels"
    echo "VERTICAL   : $(vcgencmd get_lcd_info | awk '{ print $2 }') pixels"
    echo "COLOR DEPTH: $(vcgencmd get_lcd_info | awk '{ print $3 }') bits"
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnXRESOLUTION()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path xrandr >/dev/null 2>&1
  then
    if [[ -n "${DISPLAY}" ]]
    then
      fnBANNER "CURRENT X-DISPLAY RESOLUTION (***)"
      echo "\$DISPLAY=${DISPLAY}"
      # xrandr is part of package "x11-xserver-utils"
      xrandr --verbose 2>&1 | grep -v "xrandr: Failed to get size of gamma for output default"
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
fnWIRINGPI()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  # Do not run on Pi 4B 8GB, 400, or CM4 models.
  # All other Pi 4Bs (1/2/4GB) require WiringPi version 2.52.
  # The 4B 8GB, 400 and CM4 models appeared after deprication of WiringrPpi.
  # All older Pi models can run the versions in the repositories.
  if type -path gpio >/dev/null 2>&1
  then
    # If it's an 8GB 4B, or a 400, or a CM4, then get out.
    if [[ "${MY_REVISION}" = "d03114" ]] || [[ "${MY_MODEL_NAME}" = "400" ]] || [[ "${MY_MODEL_NAME}" = "CM4" ]]
    then
      return 0
    fi

    # If it's a 4B 1-4GB, but WiringPi is not 2.5, then get out.
    if [[ "${MY_MODEL_NAME}" = "4B" ]] && [[ "${WIRINGPI_VERS}" != "2.52" ]]
    then
      return 0
    fi

    fnBANNER "GPIO PIN STATUS via WIRINGPI (***)"
    gpio readall
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
fnPIGPIOD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PY3_SCRIPT=""

  # SUPPLEMENTAL STUFF HERE
  # See: http://www.raspberrypi.org/forums/viewtopic.php?t=254071
  # for post entitled "GPIO Readall Code", by user "Milliways"
  # requires python3-pigpio be installed.
  # requires "/usr/bin/pigpiod" be running (systemctl enable pigpiod.service)
  # Unfortunately, some older 26-pin Model A and B Pis may be out of luck.
  if [[ -n "$(pgrep pigpiod)" ]]
  then
    fnBANNER "GPIO PIN STATUS via PIGPIOD (***)"
    PY3_SCRIPT=$(cat <<'EOF'
"""
Read all GPIO
"""
import sys, os, time
import pigpio

MODES = ["IN", "OUT", "ALT5", "ALT4", "ALT0", "ALT1", "ALT2", "ALT3"]
HEADER = ('3.3v', '5v', 2, '5v', 3, 'GND', 4, 14, 'GND', 15, 17, 18, 27, 'GND', 22, 23, '3.3v', 24, 10, 'GND', 9, 25, 11, 8, 'GND', 7, 0, 1, 5, 'GND', 6, 12, 13, 'GND', 19, 16, 26, 20, 'GND', 21)
GPIOPINS = 40

FUNCTION = {
'Pull': ('High', 'High', 'High', 'High', 'High', 'High', 'High', 'High', 'High', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low'),
'ALT0': ('SDA0', 'SCL0', 'SDA1', 'SCL1', 'GPCLK0', 'GPCLK1', 'GPCLK2', 'SPI0_CE1_N', 'SPI0_CE0_N', 'SPI0_MISO', 'SPI0_MOSI', 'SPI0_SCLK', 'PWM0', 'PWM1', 'TXD0', 'RXD0', 'FL0', 'FL1', 'PCM_CLK', 'PCM_FS', 'PCM_DIN', 'PCM_DOUT', 'SD0_CLK', 'SD0_XMD', 'SD0_DATO', 'SD0_DAT1', 'SD0_DAT2', 'SD0_DAT3'),
'ALT1': ('SA5', 'SA4', 'SA3', 'SA2', 'SA1', 'SAO', 'SOE_N', 'SWE_N', 'SDO', 'SD1', 'SD2', 'SD3', 'SD4', 'SD5', 'SD6', 'SD7', 'SD8', 'SD9', 'SD10', 'SD11', 'SD12', 'SD13', 'SD14', 'SD15', 'SD16', 'SD17', 'TE0', 'TE1'),
'ALT2': ('PCLK', 'DE', 'LCD_VSYNC', 'LCD_HSYNC', 'DPI_D0', 'DPI_D1', 'DPI_D2', 'DPI_D3', 'DPI_D4', 'DPI_D5', 'DPI_D6', 'DPI_D7', 'DPI_D8', 'DPI_D9', 'DPI_D10', 'DPI_D11', 'DPI_D12', 'DPI_D13', 'DPI_D14', 'DPI_D15', 'DPI_D16', 'DPI_D17', 'DPI_D18', 'DPI_D19', 'DPI_D20', 'DPI_D21', 'DPI_D22', 'DPI_D23'),
'ALT3': ('SPI3_CE0_N', 'SPI3_MISO', 'SPI3_MOSI', 'SPI3_SCLK', 'SPI4_CE0_N', 'SPI4_MISO', 'SPI4_MOSI', 'SPI4_SCLK', '_', '_', '_', '_', 'SPI5_CE0_N', 'SPI5_MISO', 'SPI5_MOSI', 'SPI5_SCLK', 'CTS0', 'RTS0', 'SPI6_CE0_N', 'SPI6_MISO', 'SPI6_MOSI', 'SPI6_SCLK', 'SD1_CLK', 'SD1_CMD', 'SD1_DAT0', 'SD1_DAT1', 'SD1_DAT2', 'SD1_DAT3'),
'ALT4': ('TXD2', 'RXD2', 'CTS2', 'RTS2', 'TXD3', 'RXD3', 'CTS3', 'RTS3', 'TXD4', 'RXD4', 'CTS4', 'RTS4', 'TXD5', 'RXD5', 'CTS5', 'RTS5', 'SPI1_CE2_N', 'SPI1_CE1_N', 'SPI1_CE0_N', 'SPI1_MISO', 'SPIl_MOSI', 'SPI1_SCLK', 'ARM_TRST', 'ARM_RTCK', 'ARM_TDO', 'ARM_TCK', 'ARM_TDI', 'ARM_TMS'),
'ALT5': ('SDA6', 'SCL6', 'SDA3', 'SCL3', 'SDA3', 'SCL3', 'SDA4', 'SCL4', 'SDA4', 'SCL4', 'SDA5', 'SCL5', 'SDA5', 'SCL5', 'TXD1', 'RXD1', 'CTS1', 'RTS1', 'PWM0', 'PWM1', 'GPCLK0', 'GPCLK1', 'SDA6', 'SCL6', 'SPI3_CE1_N', 'SPI4_CE1_N', 'SPI5_CE1_N', 'SPI6_CE1_N')
}

def pin_state(g):
    mode = pi.get_mode(g)
    if(mode<2):
        name = 'GPIO{}'.format(g)
    else:
        name = FUNCTION[MODES[mode]][g]
    return name, MODES[mode], pi.read(g)

if len(sys.argv) > 1:
    pi = pigpio.pi(sys.argv[1])
else:
    pi = pigpio.pi()

if not pi.connected:
    sys.exit(1)
rev = pi.get_hardware_revision()
if rev < 16 :
    GPIOPINS = 26

print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
print('| BCM |    Name    | Mode | V |  Board   | V | Mode | Name      | BCM |')
print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
for h in range(1, GPIOPINS, 2):
# odd pin
    hh = HEADER[h-1]
    if(type(hh)==type(1)):
        print('|{0:4} | {1[0]:<10} | {1[1]:<4} | {1[2]} |{2:3} '.format(hh, pin_state(hh), h), end='|| ')
    else:
        print('|     |  {:18}   | {:2}'.format(hh, h), end=' || ')
# even pin
    hh = HEADER[h]
    if(type(hh)==type(1)):
        print('{0:2} | {1[2]:<2}| {1[1]:<5}| {1[0]:<10}|{2:4} |'.format(h+1, pin_state(hh), hh))
    else:
        print('{:2} |             {:9}|     |'.format(h+1, hh))
print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
print('| BCM |    Name    | Mode | V |  Board   | V | Mode | Name      | BCM |')
print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
EOF
    )
    python3 -c "${PY3_SCRIPT}"
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnMPSTAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path mpstat >/dev/null 2>&1
  then
    fnBANNER "MPSTAT (***)"
    # 3 samples, 3 seconds apart, to get an average
    mpstat 3 3
    echo
  else
    echo "Missing utility mpstat (part of sysstat), skipping mpstat display" >&2
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnIOSTAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path iostat >/dev/null 2>&1
  then
    fnBANNER "IOSTAT (***)"
    iostat -x
  else
    echo "Missing utility iostat (part of sysstat), skipping iostat display" >&2
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnIP6STAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(grep ipv6.disable=1 /boot/cmdline.txt 2>/dev/null)" != "" ]]
  then
    fnBANNER "IPV6 DISABLED"
    echo "IPv6 has been disabled in cmdline.txt"
    echo
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnNET_FILES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local HITS=""

  if [[ -f /etc/resolv.conf ]]
  then
    fnBANNER "RESOLV.CONF"
    grep -E -v "^$|^#" < /etc/resolv.conf 2>/dev/null
    echo
  else
    echo "Missing file /etc/resolv.conf" >&2
  fi

  if [[ -f /etc/hosts ]]
  then
    fnBANNER "HOSTS FILE"
    grep -E -v "^$|^#" < /etc/hosts 2>/dev/null
    echo
  else
    echo "Missing file /etc/hosts" >&2
  fi

  if [[ -f /etc/networks ]]
  then
    fnBANNER "NETWORKS FILE"
    grep -E -v "^$|^#" < /etc/networks 2>/dev/null
    echo
  else
    echo "Missing file /etc/networks" >&2
  fi

  if [[ -f /etc/iptables.up.rules ]]
  then
    fnBANNER "IPV4 FIREWALL RULES"
    grep -E -v "^$|^#" < /etc/iptables.up.rules 2>/dev/null
    echo
  else
    echo "Missing file /etc/iptables.up.rules" >&2
  fi

  if [[ -f /etc/ip6tables.up.rules ]]
  then
    fnBANNER "IPV6 FIREWALL RULES"
    grep -E -v "^$|^#" < /etc/ip6tables.up.rules 2>/dev/null
    echo
  else
    echo "Missing file /etc/ip6tables.up.rules" >&2
  fi

  if [[ -f /etc/hosts.deny ]]
  then
    fnBANNER "TCPWRAPPERS: HOSTS.DENY"
    HITS=$(grep -E -v "^$|^#" < /etc/hosts.deny 2>/dev/null | grep -c . || :)
    if [[ "${HITS}" -ne 0 ]]
    then
      grep -E -v "^#|^$" < /etc/hosts.deny 2>/dev/null
    else
      echo "file is empty"
    fi
    echo
  else
    echo "Missing file /etc/hosts.deny" >&2
  fi

  if [[ -f /etc/hosts.allow ]]
  then
    fnBANNER "TCPWRAPPERS: HOSTS.ALLOW"
    HITS=$(grep -E -v "^#|^$" < /etc/hosts.allow 2>/dev/null | grep -c . || :)
    if [[ "${HITS}" -ne 0 ]]
    then
      grep -E -v "^#|^$" < /etc/hosts.allow 2>/dev/null
    else
      echo "file is empty"
    fi
    echo
  else
    echo "Missing file /etc/hosts.allow" >&2
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnROUTES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ROUTE TABLE - IPV4"
  route -4 2> /dev/null
  echo
  fnBANNER "ROUTE TABLE - IPV6"
  route -6 2>/dev/null || :
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnNET_ADAPTERS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "NETWORK ADAPTERS"
  ${SUDO} lshw -class network 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnETHTOOL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ETH=""

  # SUPPLEMENTAL STUFF HERE
  if type -path ethtool >/dev/null 2>&1
  then
    ifconfig | grep "flags=" | grep -v "lo:" | cut -f1 -d":" | while read -r ETH
    do
      fnBANNER "ETHTOOL ${ETH} (***)"
      echo "Found ${ETH}..."
      echo
      ${SUDO} ethtool -i "${ETH}"
      echo
      ${SUDO} ethtool "${ETH}" || :
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnIFCONFIG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "IFCONFIG"
  ifconfig
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnARP_CACHE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "IP NEIGHBORS (ARP CACHE)"
  ip neigh
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnSUPPLICANT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -f /etc/wpa_supplicant/wpa_supplicant.conf ]]
  then
    fnBANNER "WPA_SUPPLICANT FILE (Passwords will not be displayed)"
    ${SUDO} cat /etc/wpa_supplicant/wpa_supplicant.conf 2>/dev/null | grep -v "^$" \
      | sed 's/psk=.*/psk=**PASSWORD_HIDDEN**/' \
      | sed 's/wep_key0=.*/wep_key0=**PASSWORD_HIDDEN**/' \
      | sed 's/password=.*/password=**PASSWORD_HIDDEN**/' \
      | sed 's/passwd=.*/passwd=**PASSWORD_HIDDEN**/'
    echo
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnIWCONFIG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local WLAN=""

  fnBANNER "IWCONFIG"
  ip -s link | grep "wlan[0-3]" | awk '{ print $2 }' | cut -f1 -d":" | while read -r WLAN
  do
    iwconfig "${WLAN}" 2>/dev/null
  done
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnWIFI_AP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "VISIBLE WIFI ACCESS POINTS"
  iwlist scan 2>/dev/null | grep -v "^$" | grep -v "Unknown:"
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnNETSTAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "NETSTAT"
  netstat -n 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_NET_FS
# Calls fnBANNER
#
fnRPC_NFS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PS_RPC=""

  # SUPPLEMENTAL STUFF HERE
  # Another supplemental test.  If they have the portmapper and NFS running,
  # we'll show some information along with a list of any exports.
  PS_RPC=$(pgrep rpcbind)
  if [[ -n "${PS_RPC}" ]]
  then
    if type -path rpcinfo >/dev/null 2>&1
    then
      fnBANNER "PORTMAPPER - RPCINFO (***)"
      rpcinfo localhost
      echo
    else
      echo "Missing utility rpcinfo, skipping rpcinfo display" >&2
    fi

    #---------------
    # SUPPLEMENTAL STUFF HERE
    if type -path showmount >/dev/null 2>&1
    then
      fnBANNER "EXPORTED NFS DIRS (***)"
      showmount -e localhost
      echo
    else
      echo "Missing utility showmount, skipping nfs exports display" >&2
    fi

    #---------------
    # SUPPLEMENTAL STUFF HERE
    fnBANNER "MOUNTED NFS DIRS (***)"
    if [[ "$(df -hT --type=nfs --type=nfs4)" != "" ]]
    then
      df -hT --type=nfs --type=nfs4
      echo
      if type -path nfsiostat >/dev/null 2>&1 && type -path grep >/dev/null 2>&1
      then
        fnBANNER "NFSIOSTAT (***)" | grep -v "^$"
        nfsiostat
      else
        echo "Missing nfsiostat, skipping nfsiostat display" >&2
      fi
    else
      echo "No NFS shares mountted"
    fi
    echo
  fi
}

#---------------
# Called by fnGROUP_NET_FS
# Calls fnBANNER
#
fnSMB_CIFS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PS_SMB=""

  # SUPPLEMENTAL STUFF HERE
  # Another supplemental test.  If they have smb running,
  # we'll show some samba stats
  PS_SMB=$(pgrep smbd)
  if [[ -n "${PS_SMB}" ]]
  then
    if type -path smbstatus >/dev/null 2>&1
    then
      fnBANNER "SMBSTATUS - REMOTE SYSTEMS CONNECTED TO US (***)" | grep -v "^$"
      ${SUDO} smbstatus
    else
      echo "Missing utility smbstatus, skipping smbstatus display" >&2
    fi
  fi

  fnBANNER "MOUNTED CIFS DIRS"
  if [[ -n "$(df -hT --type=cifs 2>/dev/null)" ]]
  then
    df -hT --type=cifs 2>/dev/null
  else
    echo "No remote CIFS/Windows shares mounted"
  fi
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnERRNO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path perl >/dev/null 2>&1 && type -path m4 >/dev/null 2>&1
  then
    fnBANNER "OPERATING SYSTEM ERROR NUMBERS (***)"
    echo " NUM SYMBOLIC_NAME    DESCRIPTION"
    echo " ----------------------------------------------------"
    # Ordinarily the codes don't go as high as 255, but allowing for
    # such here is hoped to future-proof the command in the event
    # new error numbers appear with future releases of the kernel.
    # The following only prints valid errnos that exist in the kernel.
    perl -MErrno -e 'my %e= map { Errno->$_()=>$_ } keys(%!); print grep !/unknown error/i, map sprintf("%4d %-16s %s".$/,$_,$e{$_},$!=$_), 1..255'
    echo
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnSIGNALS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "EVENT SIGNALS"
  trap -l
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnCRON()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "JOB SCHEDULING - CRON"
  echo " Contents of /etc/crontab:"
  if [[ -f /etc/crontab ]]
  then
    cat /etc/crontab
  else
    echo " File /etc/crontab is missing!"
  fi
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.d ..."
  ls /etc/cron.d
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.hourly ..."
  ls /etc/cron.hourly
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.daily ..."
  ls /etc/cron.daily
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.weekly ..."
  ls /etc/cron.weekly
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.monthly ..."
  ls /etc/cron.monthly
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /var/spool/cron/crontabs:"
  ${SUDO} ls /var/spool/cron/crontabs
  echo
  echo " ----------------------------------------------------"
  echo " Contents of /etc/cron.allow:"
  if [[ -f /etc/cron.allow ]]
  then
    cat /etc/cron.allow
  else
    echo " File /etc/cron.allow not configured"
  fi
  echo
  echo " ----------------------------------------------------"
  echo " Contents of /etc/cron.deny:"
  if [[ -f /etc/cron.deny ]]
  then
    cat /etc/cron.deny
  else
    echo " File /etc/cron.deny not configured"
  fi
  echo
  echo " ----------------------------------------------------"
  systemctl status cron.service
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path at >/dev/null 2>&1
  then
    fnBANNER "JOB SCHEDULING - AT (***)"
    if [[ -f /etc/at.allow ]]
    then
      echo " Contents of /etc/at.allow:"
      ${SUDO} cat /etc/at.allow 2>/dev/null
      echo
    else
      echo " File /etc/at.allow not configured"
      echo
    fi
    echo " ----------------------------------------------------"
    if [[ -f /etc/at.deny ]]
    then
      echo " Contents of /etc/at.deny:"
      ${SUDO} cat /etc/at.deny 2>/dev/null
      echo
    else
      echo " File /etc/at.deny not present"
      echo
    fi
    echo " ----------------------------------------------------"
    echo " at files in /var/spool/cron/atjobs:"
    ${SUDO} ls /var/spool/cron/atjobs
    echo
    echo " ----------------------------------------------------"
    echo " at files in /var/spool/cron/atspool:"
    ${SUDO} ls /var/spool/cron/atspool
    echo
    echo " ----------------------------------------------------"
    echo " Checking atq for any jobs..."
    if [[ -n "$(${SUDO} atq)" ]]
    then
      ${SUDO} atq
    else
      echo " No jobs found"
    fi
    echo
    echo " ----------------------------------------------------"
    systemctl status atd.service
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnSYSBENCH_CPU()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path sysbench >/dev/null 2>&1
  then
    fnBANNER "SYSBENCH CPU BENCHMARK (***)"
    sysbench --num-threads=4 --test=cpu --cpu-max-prime=20000 --validate run
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnSYSBENCH_MEM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path sysbench >/dev/null 2>&1
  then
    fnBANNER "SYSBENCH MEMORY READ/WRITE BENCHMARK (***)"
    sysbench --test=memory run --memory-total-size=2G
    echo " ----------------------------------------------------"
    sysbench --test=memory run --memory-total-size=2G --memory-oper=read
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnSYSBENCH_IO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  # This only gets called if the touchfile "${HOME}/.system_info_io" exists
  if type -path sysbench >/dev/null 2>&1
  then
    fnBANNER "SYSBENCH FILEIO BENCHMARK (***)"
    if [[ -e "${HOME}/.system_info_io" ]]
    then
      echo -e " Touchfile \"${HOME}/.system_info_io\" detected."
      echo " Executing the sysbench File I/O benchmark."
      echo "=================================================="
      echo
      sysbench --test=fileio --file-total-size=2G prepare
      sysbench --test=fileio --file-total-size=2G --file-test-mode=rndrw --init-rng=on --max-time=300 --max-requests=0 run
      sysbench --test=fileio --file-total-size=2G cleanup
      echo
      echo "=================================================="
      echo " To prevent system_info from running this test,"
      echo " delete the touchfile with the following command:"
      echo "   rm ${HOME}/.system_info_io"
      echo
    else
      echo -e " Touchfile \"${HOME}/.system_info_io\" not detected."
      echo " Skipping sysbench File I/O benchmark."
      echo
      echo " To have system_info run this test, create the"
      echo " touchfile with the following command:"
      echo "   touch ${HOME}/.system_info_io"
      echo
      echo " To prevent system_info from running this test,"
      echo " delete the touchfile with the following command:"
      echo "   rm ${HOME}/.system_info_io"
      echo
      echo " Note that enabling this test creates, writes, reads"
      echo " and deletes 128 test files, 16Mb each (2GB total)."
      echo " Most people will NOT want to do that much writing to"
      echo " their wear-sensitive media (mainly SD cards and USB-"
      echo " attached SSD drives), on a regular basis."
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnMODULES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "LOADED MODULES"
  lsmod | head -1
  lsmod | sort | grep -v "Used by"
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnMOD_DETAILS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MODULE=""

  fnBANNER "MODULE DETAILS"
  lsmod | awk '{ print $1 }' | grep -v "^Module" | sort | while read -r MODULE
  do
    echo "===================="
    modinfo "${MODULE}"
    echo
  done
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnSHOW_REPOS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local REPO=""

  fnBANNER "CONFIGURED REPOSITORIES"
  echo "The following binary repositories are configured..."
  grep --recursive --include '*.list' '^deb ' /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null | while read -r REPO
  do
    echo "  ${REPO}"
  done
  echo
  echo "The following source repositories are configured..."
  grep --recursive --include '*.list' '^deb-src ' /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null | while read -r REPO
  do
    echo "  ${REPO}"
  done
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnUPGRADABLES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CHECKING REPOSITORIES"
  # confirm that we can connect to the internet...
  if ping www.yahoo.com -c 3 >/dev/null 2>&1
  then
    echo "This script will *NOT* upgrade any of your packages."
    echo "It will only see if package upgrades are available."
    echo "Any package updates listed here are your responsibility"
    echo "to upgrade.  This script makes no changes to your system."
    echo
    echo "Fetching available package lists from the repositories..."
    ${SUDO} apt update 2>/dev/null
    echo
    echo "Any available upgrades will appear here..."
    ${SUDO} apt list --upgradable 2>/dev/null
    echo
  else
    echo "Unable to reach the Internet.  Are you connected?"
    echo
  fi
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnDEPENDENCY_CHECK()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CHECK FOR BROKEN DEPENDENCIES"
  ${SUDO} apt-get check
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnON_HOLD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Packages can be placed "on hold" to prevent upgrading a package
  # in question.  While on hold, apt, apt-get, dpkg, aptitude and so on
  # will all refuse to upgrade the on-hold package.  Here, we remind
  # the admin of any packages they may have placed "on hold".
  #
  # To place a package on hold to prevent upgrade:
  #   sudo apt-mark hold <package_name>
  # To release a package from hold to allow upgrade:
  #   sudo apt-mark unhold <package_name>
  # To view list of packages currently on hold:
  #   sudo dpkg --get-selections | grep "hold"
  fnBANNER "PACKAGES ON HOLD TO DISALLOW UPGRADE"
  if [[ "$(${SUDO} dpkg --get-selections | grep "hold$")" = "" ]]
  then
    echo "No packages placed on hold"
    echo
  else
    ${SUDO} dpkg --get-selections | grep "hold$"
  fi
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnPACKAGES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "INSTALLED PACKAGE LIST"
  dpkg -l 2>/dev/null | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnPKG_DETAILS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PACKAGE=""

  fnBANNER "PACKAGE DETAILS"
  apt list 2>/dev/null | cut -f1 -d"/" | sort | while read -r PACKAGE
  do
    echo "===================="
    apt show "${PACKAGE}" 2>/dev/null
  done
}

#---------------
# Called by fnGROUP_OTHER
# Calls fnBANNER, fnSUB_BANNER
#
fnDOCKER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local SERVICE=""

  # SUPPLEMENTAL STUFF HERE
  if [[ -n "$(pgrep dockerd)" ]] || [[ -n "$(pgrep docker)" ]]
  then
    fnBANNER "DOCKER (***)"
    ${SUDO} docker version 2>/dev/null
    echo
    echo "-------------------------------"
    ${SUDO} docker info 2>/dev/null

    if [[ -f /etc/containerd/config.toml ]]
    then
      fnSUB_BANNER "Contents of /etc/containerd/config.toml"
      grep -E -v "^#|^$" < /etc/containerd/config.toml
      echo
    fi

    systemctl | grep docker | awk '{ print $1 }' | while read -r SERVICE
    do
      fnSUB_BANNER "Docker Service..." | grep -v "^$"
      systemctl status "${SERVICE}"
    done
    echo

    fnSUB_BANNER "ALL CONTAINERS" | grep -v "^$"
    ${SUDO} docker ps -a 2>/dev/null
    echo
    fnSUB_BANNER "RUNNING CONTAINERS" | grep -v "^$"
    ${SUDO} docker ps 2>/dev/null
    echo
    fnSUB_BANNER "ALL IMAGES"
    ${SUDO} docker images 2>/dev/null
    echo

    if [[ "$(docker images 2>/dev/null | awk '{ print $1 }' | grep "^hello-world")" != "" ]]
    then
      fnSUB_BANNER "Docker \"Hello World\"" | grep -v "^$"
      ${SUDO} docker run --rm -it hello-world 2>/dev/null | sed 's/\r//'
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_OTHER
# Calls fnBANNER
#
fnNSPAWN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local NSPAWNPKG=""
  local NSPAWN=""

  # SUPPLEMENTAL STUFF HERE
  if [[ -n "$(pgrep systemd-nspawn)" ]]
  then
    fnBANNER "SYSTEMD-NSPAWN (***)"
    echo "NSPAWN-RELATED PACKAGES INSTALLED:"
    echo
    dpkg -l | grep -i nspawn | awk '{ print $2 }' | while read -r NSPAWNPKG
    do
      apt show "${NSPAWNPKG}" 2>/dev/null
      echo "-------------------------------"
      echo
    done
    echo "CONTAINERS FOUND IN: /var/lib/machines"
    ${SUDO} find /var/lib/machines/ -maxdepth 1 -mindepth 1 -type d -exec basename {} \;
    echo
    echo "-------------------------------"
    ${SUDO} systemctl list-machines
    echo
    machinectl list
    echo
    echo "-------------------------------"
    if type -path ds64-shell >/dev/null 2>&1
    then
      echo "DS64-SHELL..."
      ds64-shell --version 2>/dev/null | sed 's/\r//'
      echo
      echo "-------------------------------"
    fi
    systemctl | grep nspawn | awk '{ print $1 }' | while read -r NSPAWN
    do
      systemctl status "${NSPAWN}"
      echo
      echo "-------------------------------"
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnMOG
#
fnUSERCHECK()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PW_REC=""
  local PW_USR=""
  local PW_NUM=""
  local PW_GRP=""
  local GRP_GRP=""
  local HOMEDIR=""
  local GRP_REC=""

  fnBANNER "REGULAR (NON-SYSTEM) USER ACCOUNTS"
  sort -u -n -t: -k 3.1 /etc/passwd | while read -r PW_REC
  do
    PW_USR="$(echo "${PW_REC}" | cut -f1 -d":")"
    PW_NUM="$(echo "${PW_REC}" | cut -f3 -d":")"
    PW_GRP="$(echo "${PW_REC}" | cut -f4 -d":")"
    GRP_GRP="$(grep ":${PW_GRP}:" /etc/group | cut -f1 -d":")"
    if [[ "${PW_NUM}" -ge 1000 ]] && [[ "${PW_USR}" != "nobody" ]]
    then
      echo "--------------------"
      echo -n "USER NAME ................... "
      echo "${PW_USR}"

      echo -n "NUMERIC UID ................. "
      echo "${PW_REC}" | cut -f3 -d":"

      echo -n "USER'S PRIMARY GROUP ........ "
      grep ":${PW_GRP}:" /etc/group | cut -f1 -d":"

      echo -n "HOME DIRECTORY .............. "
      HOMEDIR=$(grep "^${PW_USR}:" /etc/passwd | cut -f6 -d":")
      if [[ -d "${HOMEDIR}" ]]
      then
        fnMOG 700 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}"
      else
        echo -n "${HOMEDIR}"
        echo " <-- *** WARNING: SPECIFIED DIRECTORY DOES NOT EXIST ***"
      fi

      echo -n "THE USER'S SHELL ............ "
      grep "^${PW_USR}:" /etc/passwd | cut -f7 -d":"

      echo -n "MEMBER OF GROUPS ............ "
      if [[ "$(grep -E "^${PW_USR}:|:${PW_USR}$|:${PW_USR},|,{PW_USR},|,${PW_USR}$" /etc/group | cut -f1 -d":" | head -1)" != "" ]]
      then
        grep -E "^${PW_USR}:|:${PW_USR}$|:${PW_USR},|,{PW_USR},|,${PW_USR}$" /etc/group | cut -f1 -d":" | sort | while read -r GRP_REC
        do
          echo -n "${GRP_REC} "
        done
        echo
      else
        echo "Account is not a member of any groups"
      fi

      echo -n "PASSWORD STATUS ............. "
      case "$(${SUDO} passwd --status "${PW_USR}" | awk '{ print $2 }')" in
        NP)
          echo "<-- *** NO PASSWORD (THIS IS BAD) ***"
          ;;
        L)
          echo "<-- *** ADMINISTRATIVELY LOCKED ***"
          ;;
        P)
          echo "VALID - OK"
          ;;
        *)
          echo "<-- *** UNDEFINED ERROR FOUND (THIS IS BAD) ***"
          ;;
      esac

      echo -n "PASSWORD LAST CHANGED ....... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -1
      echo -n "PASSWORD EXPIRES ............ "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -2 | tail -1
      echo -n "PASSWORD INACTIVE ........... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -3 | tail -1
      echo -n "ACCOUNT EXPIRES ............. "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -4 | tail -1
      echo -n "MIN PASSWORD LIFE (DAYS) .... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -5 | tail -1
      echo -n "MAX PASSWORD LIFE (DAYS) .... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -6 | tail -1
      echo -n "WARN BEFORE CHANGE (DAYS) ... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -7 | tail -1

      if [[ -d "${HOMEDIR}/.ssh" ]]
      then
        echo "USER'S .ssh SETUP:"
        fnMOG 700 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh"
        if [[ -f "${HOMEDIR}/.ssh/authorized_keys" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/authorized_keys"
        fi
        if [[ -f "${HOMEDIR}/.ssh/known_hosts" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/known_hosts"
        fi
        if [[ -f "${HOMEDIR}/.ssh/config" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/config"
        fi
        if [[ -f "${HOMEDIR}/.ssh/id_dsa" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_dsa"
        fi
        if [[ -f "${HOMEDIR}/.ssh/id_dsa.pub" ]]
        then
          fnMOG 644 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_dsa.pub"
        fi
        if [[ -f "${HOMEDIR}/.ssh/id_rsa" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_rsa"
        fi
        if [[ -f "${HOMEDIR}/.ssh/id_rsa.pub" ]]
        then
          fnMOG 644 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_rsa.pub"
        fi
      fi
      echo
    fi
  done
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnLOGIN_DEFS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEM LOGIN DEFAULTS"
  grep -E -v "^$|^#" /etc/login.defs
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnSUB_BANNER
#
fnLAST_LOGINS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "LAST LOGINS"
  last
  echo
  lastlog
  echo
  fnSUB_BANNER "LOGIN FAILURES"
  ${SUDO} lastb
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnW()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CURRENTLY LOGGED ON"
  w
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnSUDOERS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SUDOERS SYNTAX CHECK"
  ${SUDO} visudo --check --strict
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnMOG
#
fnCHECK_PERMISSIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DIR=""

  fnBANNER "CHECKING BASIC CRITICAL DIRECTORY PERMISSIONS"
  # 755
  for DIR in / /bin /boot /dev /etc /home /lib /media /mnt /opt /run /sbin /srv /usr /var
  do
    fnMOG 755 root root "${DIR}"
  done
  # 555
  for DIR in /proc /sys
  do
    fnMOG 555 root root "${DIR}"
  done
  # OTHER
  fnMOG 700 root root /root
  fnMOG 1777 root root /tmp
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnCHKROOTKIT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path chkrootkit >/dev/null 2>&1
  then
    fnBANNER "CHECKING FOR ROOTKITS - CHKROOTKIT (***)"
    ${SUDO} chkrootkit -e -n 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnCLAM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CLAM_SVC=""

  # SUPPLEMENTAL STUFF HERE
  if type -path clamscan >/dev/null 2>&1
  then
    fnBANNER "CLAMAV ANTI-VIRUS SCANNER (***)"
    if type -path clamscan >/dev/null 2>&1
    then
      echo "CLAMSCAN.... $(clamscan --version 2>/dev/null)"
    else
      echo "CLAMSCAN.... not found"
    fi

    if type -path freshclam >/dev/null 2>&1
    then
      echo "FRESHCLAM... $(freshclam --version 2>/dev/null)"
    else
      echo "FRESHCLAM... not found"
    fi

    if type -path clamd >/dev/null 2>&1
    then
      echo "CLAMD....... $(clamd --version 2>/dev/null)"
    else
      echo "CLAMD....... not found"
    fi

    if type -path clamdscan >/dev/null 2>&1
    then
      echo "CLAMDSCAN... $(clamdscan --version 2>/dev/null)"
    else
      echo "CLAMDSCAN.... not found"
    fi

    echo

    if type -path clamconf >/dev/null 2>&1
    then
      echo " ----------------------------------------------------"
      clamconf -n 2>/dev/null
      echo
    fi

    if [[ "$(systemctl | grep clamav)" != "" ]]
    then
      systemctl | grep clamav | awk '{ print $1 }' | while read -r CLAM_SVC
      do
        echo " ----------------------------------------------------"
        systemctl status "${CLAM_SVC}"
        echo
      done
    else
      echo " ----------------------------------------------------"
      echo "No clamav-related systemd services running."
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnTRIPWIRE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path tripwire >/dev/null 2>&1
  then
    fnBANNER "TRIPWIRE (***)"
    tripwire || :
    echo
    echo " ----------------------------------------------------"

    if [[ -f /etc/tripwire/tw.cfg ]]
    then
      echo -e " Default Config File ...... /etc/tripwire/tw.cfg"
    fi

    if [[ -f /etc/tripwire/tw.pol ]]
    then
      echo -e " Default Policy File ...... /etc/tripwire/tw.pol"
    fi

    if [[ -f /var/lib/tripwire/"${HOSTNAME}".twd ]]
    then
      echo -e " Default Database File .... /var/lib/tripwire/${HOSTNAME}.twd"
    fi

    if [[ -f /etc/tripwire/site.key ]]
    then
      echo -e " Default Site Key ......... /etc/tripwire/site.key"
    fi

    if [[ -f /etc/tripwire/"${HOSTNAME}"-local.key ]]
    then
      echo -e " Default Local Key ........ /etc/tripwire/${HOSTNAME}-local.key"
    fi

    if [[ -d /var/lib/tripwire/report ]]
    then
      echo -e " Default Report Directory . /var/lib/tripwire/report"
    fi

    echo " ----------------------------------------------------"
    echo
    if [[ -f /var/lib/tripwire/"${HOSTNAME}".twd ]]
    then
      ${SUDO} tripwire --check || :
    fi
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnNMAP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MY_IP=""

  # SUPPLEMENTAL STUFF HERE
  # Not everyone has, or needs, nmap.  So, it's not a required dependency
  # for this script.  However, if we do find that it is available, we can
  # make use of it here.
  if type -path nmap >/dev/null 2>&1
  then
    # IPV4
    ifconfig | grep "inet " | awk '{ print $2 }' | sort -u -n -t. -k 1,1  -k 2,2  -k 3,3  -k 4,4 | while read -r MY_IP
    do
      fnBANNER "SCANNING FOR SERVICES ON IPV4: ${MY_IP} (***)"
      nmap -Pn -sV -T4 -p 1-65535 --version-light "${MY_IP}" | grep -E "^PORT|^[1-9][0-9]"
      echo
    done
    # IPV6
    ifconfig | grep "inet6 " | grep -v "inet6 ....::" | awk '{ print $2 }' | sort | while read -r MY_IP
    do
      fnBANNER "SCANNING FOR SERVICES ON IPV6: ${MY_IP} (***)"
      nmap -6 -Pn -sV -T4 -p 1-65535 --version-light "${MY_IP}" | grep -E "^PORT|^[1-9][0-9]"
      echo
    done
  fi

}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnSUB_BANNER
#
fnSNORT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path snort >/dev/null 2>&1
  then
    fnBANNER "SNORT IDS (***)"
    snort -V 2>&1
    echo
    if [[ -f /etc/snort/snort.conf ]]
    then
      fnSUB_BANNER "SNORT CONFIGURATION TEST..."
      ${SUDO} snort -T -c /etc/snort/snort.conf 2>&1
      echo
    fi
    echo " ----------------------------------------------------"
    systemctl status snort.service
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnLYNIS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path lynis >/dev/null 2>&1
  then
    fnBANNER "LYNIS (***)"
    ${SUDO} lynis update info --cronjob 2> /dev/null
    echo " ----------------------------------------------------"
    ${SUDO} lynis update check --cronjob 2> /dev/null
    echo
    echo " ----------------------------------------------------"
    ${SUDO} lynis show profiles --cronjob 2> /dev/null
    echo
    echo " ----------------------------------------------------"
    ${SUDO} lynis audit system --cronjob 2> /dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnUFW()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path ufw >/dev/null 2>&1
  then
    fnBANNER "UFW (***)"
    ${SUDO} ufw version
    echo
    echo " ----------------------------------------------------"
    ${SUDO} ufw status verbose
    echo
    echo " ----------------------------------------------------"
    systemctl status ufw.service
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnRKHUNTER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path rkhunter >/dev/null 2>&1
  then
    fnBANNER "CHECKING FOR ROOTKITS - RKHUNTER (***)"
    ${SUDO} rkhunter --versioncheck --nocolors
    echo
    echo " ----------------------------------------------------"
    ${SUDO} rkhunter --update --nocolors
    echo
    echo " ----------------------------------------------------"
    if ${SUDO} rkhunter --config-check
    then
      ${SUDO} rkhunter -c --enable all --rwo --sk --nocolors || :
    fi
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnUNHIDE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path unhide >/dev/null 2>&1
  then
    fnBANNER "UNHIDE (***)"
    ${SUDO} unhide sys
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnAUDITD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path auditctl >/dev/null 2>&1 && [[ "${HAS_AUDITD}" = "yes" ]]
  then
    fnBANNER "AUDITD (***)"
    ${SUDO} auditctl -l
    echo
    echo " ----------------------------------------------------"
    ${SUDO} ls -alR /etc/audit
    echo
    echo " ----------------------------------------------------"
    ${SUDO} aureport
    echo
    echo " ----------------------------------------------------"
    ${SUDO} ls -alR /var/log/audit
    echo
    echo " ----------------------------------------------------"
    systemctl status auditd.service
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
# This function is an optimistic placeholder, should the
# kernel one day be provided with SELINUX support compiled in.
# It presently does nothing but return to where it was called.
#
# fnSELINUX()
# {
#   fnDEBUG
#
#   # SUPPLEMENTAL STUFF HERE
#   if [[ "${HAS_SELINUX}" = "yes" ]]
#   then
#     fnBANNER "SELINUX (***)"
#     # If SELINUX support ever shows up in the repo kernels,
#     # I'll add stuff here, to report on it.
#   fi
#   return 0
# }

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnAPPARMOR()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if type -path aa-status >/dev/null 2>&1 && [[ "${HAS_APPARMOR}" = "yes" ]] && [[ "$(grep "apparmor=1" /boot/cmdline.txt)" != "" ]]
  then
    fnBANNER "APPARMOR (***)"
    echo -n "Apparmor enabled: "
    aa-enabled
    echo
    ${SUDO} aa-status
    echo
  fi
}

#----------------------------------- INITIALIZATION - RUN BEFORE MENU
# Called by fnMAIN
# Calls several functions
#
fnCONFIRM_PREREQS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnSUDO
  fnCONFIRM_OS
  fnRING_BUF
  fnCHECK_VIRT
  fnCHECK_CHROOT
  fnDECODE_REV
  fnCHK_PACKAGES
  fnLSHW_BUSINFO
}

##################################################
# THE INDIVIDUAL FUNCTIONS DEFINED ABOVE NOW GET GROUPED TOGETHER
# BY MENU SELECTION. It beats moving whole blocks or code around.
##################################################

#----------------------------------- Pi Hardware
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_HARDWARE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   /|      Menu Option 1'
  echo '__)|__\__ | |\__/| \|    |      PI HARDWARE'
  echo
  SECTION="1"
  fnPRINT_DECODED_REV
  fnSYSTEM_ID
  fnMAC
  fnMODEL
  fnDIAGRAM
  fnCPU
  fnSENSORS
  fnHOW_BOOT
}

#----------------------------------- Performance
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_PERFORMANCE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __        __      '
  echo '(_ |_ /   | |/  \|\ |    _)     Menu Option 2'
  echo '__)|__\__ | |\__/| \|   /__     PERFORMANCE'
  echo
  SECTION="2"
  fnPROCSPEED
  fnOVERCLOCK
  fnRING_OSCILLATOR
  fnCLOCKFREQ
  fnVOLTS
  fnTEMPS
  fnGOV
  fnTHROTTLES
  fnMPSTAT
  fnIOSTAT
  fnSYSBENCH_CPU
  fnSYSBENCH_MEM
  fnSYSBENCH_IO
}

#----------------------------------- O/S Config
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_OS_CONFIG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __        __      '
  echo '(_ |_ /   | |/  \|\ |    _)     Menu Option 3'
  echo '__)|__\__ | |\__/| \|   __)     OS CONFIG'
  echo
  SECTION="3"
  fnOS
  fnLOCALE
  fnCMDLINE
  fnCONFIGTXT
  fnDTOVERLAYS
  fnDTPARAMS
  fnSYSCTL
  fnLEDS
  fnULIMIT_CORE
  fnERRNO
  fnSIGNALS
  fnCRON
  fnAT
}

#----------------------------------- Memory
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_MEMORY()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   |__|    Menu Option 4'
  echo '__)|__\__ | |\__/| \|      |    MEMORY'
  echo
  SECTION="4"
  fnMEMSPLIT
  fnMEMSWAP
  fnMEMINFO
  fnIPC
}

#----------------------------------- Logging
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_LOGGING()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   |_      Menu Option 5'
  echo '__)|__\__ | |\__/| \|   __)     LOGGING'
  echo
  SECTION="5"
  fnDMESG
  fnJOURNAL
  fnRSYSLOG
  fnLOGROTATE
}

#----------------------------------- Services
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_OS_SERVICES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   /__     Menu Option 6'
  echo '__)|__\__ | |\__/| \|   \__)    SERVICES'
  echo
  SECTION="6"
  fnSYSTEMD_CHAIN
  fnSYSTEMD_BLAME
  fnSYSTEMD_SECURITY
  fnSYSCTL_STATUS
  fnSYSCTL_FAIL
  fnSYSCTL_LIST
  fnRCLOCAL
}

#----------------------------------- H/W Busses
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_HW_BUSSES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __        ___     '
  echo '(_ |_ /   | |/  \|\ |     /     Menu Option 7'
  echo '__)|__\__ | |\__/| \|    /      HARDWARE BUSSES'
  echo
  SECTION="7"
  fn1W
  fnSPI
  fnI2S
  fnI2C
  fnWIRINGPI
  fnPIGPIOD
}

#----------------------------------- Serial & Bluetooth
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_SERIAL_BT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   (__)    Menu Option 8'
  echo '__)|__\__ | |\__/| \|   (__)    SERIAL & BLUETOOTH'
  echo
  SECTION="8"
  fnACM
  fnSERIAL
  fnBT
}

#----------------------------------- USB & Other Devices
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_DEVICES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   (__\    Menu Option 9'
  echo '__)|__\__ | |\__/| \|    __/    USB & OTHER DEVICES'
  echo
  SECTION="9"
  fnUSB_DEV_INFO
  fnLSHW_INPUT
  fnLSHW_GENERIC
  fnRTL_SDR
  fnRTC
  fnHWRNG
  fnHWWD
  fnLIRC
  fnPRINTER
}

#----------------------------------- Filesystems & Storage
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_FS_STORAGE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __            __  '
  echo '(_ |_ /   | |/  \|\ |   /| /  \ Menu Option 10'
  echo '__)|__\__ | |\__/| \|    | \__/ FILESYSTEMS & STORAGE'
  echo
  SECTION="10"
  fnFSTAB
  fnLSHW_STORAGE
  fnHDPARM
  fnSMART
  fnQUIRKS
  fnTRIM
  fnBLKID
  fnRAID
  fnLVM
  fnQUOTAS
  fnOVERLAYFS
}

#----------------------------------- Audio & Video
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_AV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   /| /|   Menu Option 11'
  echo '__)|__\__ | |\__/| \|    |  |   AUDIO & VIDEO'
  echo
  SECTION="11"
  fnLSHW_MM
  fnALSA_MOD
  fnALSA_HW
  fnALSA_CARD
  fnALSA_PB_CAP
  fnCAMERA
  fnCODECS
  fnV4L2CODECS
  fnV4LDEV
  fnTOUCH
  fnDISPDRV
  fnDISPLAY
  fnROWS_COLS
  fnRESOLUTION
  fnXRESOLUTION
}

#----------------------------------- Networking
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_NETWORK()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __           __   '
  echo '(_ |_ /   | |/  \|\ |   /|  _)  Menu Option 12'
  echo '__)|__\__ | |\__/| \|    | /__  NETWORKING'
  echo
  SECTION="12"
  fnIP6STAT
  fnNET_FILES
  fnROUTES
  fnNET_ADAPTERS
  fnETHTOOL
  fnIFCONFIG
  fnARP_CACHE
  fnSUPPLICANT
  fnIWCONFIG
  fnWIFI_AP
  fnNETSTAT
}

#----------------------------------- Network Filesystems
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_NET_FS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __           __   '
  echo '(_ |_ /   | |/  \|\ |   /|  _)  Menu Option 13'
  echo '__)|__\__ | |\__/| \|    | __)  NETWORK FILESYSTEMS'
  echo
  SECTION="13"
  fnRPC_NFS
  fnSMB_CIFS
}

#----------------------------------- Containers & Virtualization
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_OTHER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   /| |__| Menu Option 14'
  echo '__)|__\__ | |\__/| \|    |    | CONTAINERS & VIRTUALIZATION'
  echo
  SECTION="14"
  fnDOCKER
  fnNSPAWN
}

#----------------------------------- Modules and Packages
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_MODS_PKGS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __            __  '
  echo '(_ |_ /   | |/  \|\ |   /| |_   Menu Option 15'
  echo '__)|__\__ | |\__/| \|    | __)  MODULES AND PACKAGES'
  echo
  SECTION="15"
  fnMODULES
  # This next function generates information about each loaded module listed
  # by fnMODULES, above.  The amount of information can be significant,
  # depending upon how many modules are running.  Uncomment if you'ld like,
  # but it may give more information than you are willing to scroll through.
  # fnMOD_DETAILS

  fnSHOW_REPOS
  fnUPGRADABLES
  fnDEPENDENCY_CHECK
  fnON_HOLD
  fnPACKAGES
  # This next function will likely never see the light of day.  It generates
  # information about every installed package on a system.  You're better
  # off running "apt show" against a single package of interest only, than
  # having this script loop through every package.  (You could have thousands
  # of packages installed, and this would loop through every one of them!)
  # fnPKG_DETAILS
}

#----------------------------------- Security
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_SECURITY()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __            __  '
  echo '(_ |_ /   | |/  \|\ |   /| /__  Menu Option 16'
  echo '__)|__\__ | |\__/| \|    | \__) SYSTEM SECURITY'
  echo
  SECTION="16"
  fnUSERCHECK
  fnLOGIN_DEFS
  fnLAST_LOGINS
  fnW
  fnSUDOERS
  fnCHECK_PERMISSIONS
  fnCHKROOTKIT
  fnRKHUNTER
  fnCLAM
  fnTRIPWIRE
  fnNMAP
  fnUFW
  fnSNORT
  fnLYNIS
  fnUNHIDE
  # fnSELINUX
  fnAPPARMOR
  fnAUDITD
}

#---------------
# Called by fnFINISH_UP
#
fnEND_OF_REPORT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo
  echo    "==============================================================================="
  echo    ' __     __    __  __   __  __ __  __  __ ___ '
  echo -n '|_ |\ ||  \  /  \|_   |__)|_ |__)/  \|__) |  '
  echo "SYSTEM_INFO"
  echo -n '|__| \||__/  \__/|    | \ |__|   \__/| \  |  '
  echo "VER: ${MY_VERSION}"
  echo
}

##################################################
# HERE, WE ACTUALLY CALL THE GROUPS ABOVE, WHEN THE
# REPORT IS RUN, DEPENDING ON YOUR MENU SELECTIONS
#---------------
# Called by fnDO_INSPECTIONS
# Calls several functions
#
fnACTIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n ${CHOICES[16]} ]]
  then
    fnGROUP_HARDWARE
    fnGROUP_PERFORMANCE
    fnGROUP_OS_CONFIG
    fnGROUP_MEMORY
    fnGROUP_LOGGING
    fnGROUP_OS_SERVICES
    fnGROUP_HW_BUSSES
    fnGROUP_SERIAL_BT
    fnGROUP_DEVICES
    fnGROUP_FS_STORAGE
    fnGROUP_AV
    fnGROUP_NETWORK
    fnGROUP_NET_FS
    fnGROUP_OTHER
    fnGROUP_MODS_PKGS
    fnGROUP_SECURITY
    # If user selects to do all, do all only once
    return 0
  fi
  if [[ -n ${CHOICES[0]} ]]
  then
    fnGROUP_HARDWARE
  fi
  if [[ -n ${CHOICES[1]} ]]
  then
    fnGROUP_PERFORMANCE
  fi
  if [[ -n ${CHOICES[2]} ]]
  then
    fnGROUP_OS_CONFIG
  fi
  if [[ -n ${CHOICES[3]} ]]
  then
    fnGROUP_MEMORY
  fi
  if [[ -n ${CHOICES[4]} ]]
  then
    fnGROUP_LOGGING
  fi
  if [[ -n ${CHOICES[5]} ]]
  then
    fnGROUP_OS_SERVICES
  fi
  if [[ -n ${CHOICES[6]} ]]
  then
    fnGROUP_HW_BUSSES
  fi
  if [[ -n ${CHOICES[7]} ]]
  then
    fnGROUP_SERIAL_BT
  fi
  if [[ -n ${CHOICES[8]} ]]
  then
    fnGROUP_DEVICES
  fi
  if [[ -n ${CHOICES[9]} ]]
  then
    fnGROUP_FS_STORAGE
  fi
  if [[ -n ${CHOICES[10]} ]]
  then
    fnGROUP_AV
  fi
  if [[ -n ${CHOICES[11]} ]]
  then
    fnGROUP_NETWORK
  fi
  if [[ -n ${CHOICES[12]} ]]
  then
    fnGROUP_NET_FS
  fi
  if [[ -n ${CHOICES[13]} ]]
  then
    fnGROUP_OTHER
  fi
  if [[ -n ${CHOICES[14]} ]]
  then
    fnGROUP_MODS_PKGS
  fi
  if [[ -n ${CHOICES[15]} ]]
  then
    fnGROUP_SECURITY
  fi
}

##################################################
# A FEW REMAINING SUPPORTING FUNCTIONS DEALING
# WITH THE REPORT, THE SAVING/RECALLING OF MENU
# SELECTIONS, ETC.
#---------------
# Called by fnDO_INSPECTIONS and fnFINISH_UP
#
fnREPORT_ACTIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CHOICE_MADE=""

  echo "The following Menu Options were selected, to generate this report:"
  if [[ -n ${CHOICES[16]} ]]
  then
    echo "  Option 17: Run All Sections - (This option overrides any/all other selections)"
    echo
    return 0
  fi
  if [[ -n ${CHOICES[0]} ]]
  then
    echo "  Option  1: Pi Hardware"
    CHOICE_MADE="Y"
  fi
  if [[ -n ${CHOICES[1]} ]]
  then
    echo "  Option  2: Performance"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[2]} ]]
  then
    echo "  Option  3: O/S Config"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[3]} ]]
  then
    echo "  Option  4: Memory"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[4]} ]]
  then
    echo "  Option  5: Logging"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[5]} ]]
  then
    echo "  Option  6: Services"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[6]} ]]
  then
    echo "  Option  7: Hardware Busses"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[7]} ]]
  then
    echo "  Option  8: Serial & Bluetooth"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[8]} ]]
  then
    echo "  Option  9: USB & Other Devices"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[9]} ]]
  then
    echo "  Option 10: Filesystems & Storage"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[10]} ]]
  then
    echo "  Option 11: Audio & Video"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[11]} ]]
  then
    echo "  Option 12: Networking"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[12]} ]]
  then
    echo "  Option 13: Network Filesystems"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[13]} ]]
  then
    echo "  Option 14: Containers & Virtualization"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[14]} ]]
  then
    echo "  Option 15: Modules and Packages"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[15]} ]]
  then
    echo "  Option 16: Security"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ "$(echo "${CHOICE_MADE}" | grep "Y")" = "" ]]
  then
    echo "  No Menu Options were selected"
  fi
  echo
}

#---------------
# Called by fnCHECK_CMDLINE
#
fnREAD_RCFILE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local NUM=""
  local BOOLEAN=""

  # NOTE:  Because the array is 0-16, and the menu is presented as
  # options 1-17, the keys in the rc file are 1 lower than the menu
  # numbers they represent.  For example, menu option 1 is stored as
  # a key of 0, option 2 is stored as a key of 1, and so on.

  # RCFILE format is:
  #   menu option number (minus 1), a colon (:), and a boolean (0 or 1)
  #   0=not selected
  #   1=selected
  #
  #   example...
  #   0:1
  #   1:0
  #   2:0
  #   3:1
  #   ...
  #   17:0
  #
  #   The numeric options described above are then followed by flags
  #   that tell the script whether to run specific tests (or not), in
  #   the presence of the relevent supplemental packages.  For example,
  #   a user may have tripwire installed and configured, but may not
  #   want this script to perform a "tripwire --check".
  if [[ -f "${RCFILE}" ]]
  then
    # Numeric menu options
    for NUM in "${!OPTIONS[@]}"
    do
      BOOLEAN="$(grep "^${NUM}:" "${RCFILE}" 2>/dev/null | cut -f2 -d":")"
      if [[ "${BOOLEAN}" = "1" ]]
      then
        CHOICES[NUM]="${REV}+${SGR0}"
      fi
    done
  fi
}

#---------------
# Called by fnFINISH_UP
#
fnWRITE_RCFILE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local NUM=""

  for NUM in "${!OPTIONS[@]}"
  do
    if [[ -n "${CHOICES[NUM]}" ]]
    then
      echo "${NUM}:1"
    else
      echo "${NUM}:0"
    fi
  done
}

#---------------
# Called by fnFINISH_UP
#
fnREPORT_RCFILE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo "These menu selections have been saved in the file:"
  echo "  ${RCFILE}"
  echo
  echo "They will be auto-selected next time this script is run by user \"$(whoami)\"."
  echo
}

#---------------
# Menu function
# Called by fnMAIN_LOOP
#
fnMENU()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local SCR_ROW=""
  local SCR_COL=""

  echo "RASPBERRY PI SYSTEM INFORMATION REPORT v${MY_VERSION} - MAIN MENU"
  SCR_ROW=2
  SCR_COL=2
  for NUM in "${!OPTIONS[@]}"
  do
    if [[ "${SCR_ROW}" -gt 10 ]]
    then
      SCR_ROW=2
      SCR_COL=38
    fi
    tput cup "${SCR_ROW}" "${SCR_COL}" 2>/dev/null
    echo "[""${CHOICES[NUM]:- }""]" $(( NUM+1 ))") ${OPTIONS[NUM]}"
    (( SCR_ROW++ ))
  done
  (( SCR_ROW++ ))
  tput cup "${SCR_ROW}" 0 2>/dev/null
  echo "${ERROR}"
  echo "Type a number and press [ENTER] to select.  Again, to deselect."
  echo "Multiple selections can be made before any tests are executed."
}

#---------------
# Called by fnMAIN
# Calls fnREAD_RCFILE
#
fnCHECK_CMDLINE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Force the execution of a specific menu selection when testing.
  # Make sure any parameter is numeric, and between 1 and 17.
  if [[ ${MY_ARG} = *[[:digit:]]* ]] && [[ "${MY_ARG}" -ge 1 ]] && [[ "${MY_ARG}" -le 17 ]] 2>/dev/null
  then
    # Align a 1-17 parameter with 0-16 array elements
    ((CMDLINE_CHOICE=MY_ARG-1))
    CHOICES[${CMDLINE_CHOICE}]="${REV}+${SGR0}"
  else
    fnREAD_RCFILE
  fi
}

#---------------
# Called by fnMAIN
# Calls fnMENU
#
fnMAIN_LOOP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local SELECTION=""

  # Main Menu loop
  while fnMENU && read -r -e -p "Press [ENTER] by itself when ready.  Use Q [ENTER] or Ctrl-C to quit: " -n3 SELECTION && [[ -n "${SELECTION}" ]]
  do
    clear 2>/dev/null
    if [[ "${SELECTION}" = *[[:digit:]]* && ${SELECTION} -ge 1 && ${SELECTION} -le ${#OPTIONS[@]} ]]
    then
      (( SELECTION-- ))
      if [[ "${CHOICES[SELECTION]:-}" = "${REV}+${SGR0}" ]]
      then
        CHOICES[SELECTION]=""
      else
        CHOICES[SELECTION]="${REV}+${SGR0}"
      fi
      ERROR=" "
    else
      if [[ "${SELECTION}" = "q" ]] || [[ "${SELECTION}" = "Q" ]]
      then
        exit
      else
        ERROR="Invalid option: ${SELECTION}"
      fi
    fi
  done
}

#---------------
# Called by fnMAIN
# Calls several functions
#
fnDO_INSPECTIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local STAMP=""

  # Call all the inspections selected.
  clear 2>/dev/null
  STAMP=$(date +%F-%T | sed 's/:/-/g')
  REPORT=~/${HOSTNAME}-system_info-${STAMP}
  SECONDS=0
  true > "${REPORT}"
  fnTITLE | tee -a "${REPORT}"
  fnREPORT_ACTIONS | sed 's/\r//' | tee -a "${REPORT}"
  fnACTIONS | tee -a "${REPORT}"
}

#---------------
# Called by fnMAIN
# Calls several functions
#
fnFINISH_UP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ELAPSED=""
  local RUNTIME=""

  # Closing Screen
  # Everything from here down happens after the inspections are complete.
  rm /tmp/.lshw_businfo."${PPID}" 2>/dev/null
  ELAPSED=${SECONDS}
  RUNTIME="$((ELAPSED / 60)) minutes and $((ELAPSED % 60)) seconds."
  fnEND_OF_REPORT | tee -a "${REPORT}"
  fnBANNER "TIME REQUIRED TO GENERATE REPORT:  ${RUNTIME}" | sed 's/SYSTEM_INFO(): //' | tee -a "${REPORT}"
  fnREPORT_ACTIONS | sed 's/\r//' | tee -a "${REPORT}"
  if [[ "${CMDLINE_CHOICE}" = "" ]]
  then
    # The ">|" syntax overrides "set -o noclobber", allowing
    # an existing rc file to be updated/overwritten.
    fnWRITE_RCFILE >| "${RCFILE}"
    fnREPORT_RCFILE | tee -a "${REPORT}"
  fi
  fnBANNER "REPORT SAVED AS: ${REPORT}" | sed 's/SYSTEM_INFO(): //' | tee -a "${REPORT}"

  # If file descriptor 3 has been redirected to a debugging log file,
  # show the name of that file at the bottom of the system_info report.
  if [ "${DEBUG_LOG}" != "/dev/null" ]
  then
    fnBANNER "DEBUG LOG SAVED AS: ${DEBUG_LOG}" | sed 's/SYSTEM_INFO(): //' | tee -a "${REPORT}"
  fi

  echo "${BELL}"
}

#---------------
# Called by the mainline, below
# Calls several functions
#
fnMAIN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  clear 2>/dev/null
  fnINITIALIZE
  fnGET_HELP
  fnCONFIRM_BASH
  fnTITLE
  fnCONFIRM_PREREQS
  fnDEFINE_OPTIONS
  echo -n "PRESS ENTER FOR MENU... "
  read -r FOO
  # This next line just quiets shellcheck's complaints
  # that variable FOO (above) is unused.  :/
  echo "${FOO}" >/dev/null
  echo
  clear 2>/dev/null
  fnCHECK_CMDLINE
  fnMAIN_LOOP
  fnDO_INSPECTIONS
  fnFINISH_UP
}

##################################################
# MAINLINE
##################################################

readonly MY_ARG=${1:-}
readonly MY_VERSION="2.0.9"

# Cleanup if we abort, or are killed for any reason.
trap fnABORT SIGHUP SIGINT SIGQUIT SIGABRT SIGTERM

# Prevent any redirection from overwriting an existing file.
set -o noclobber

# "IT'S A TRAP!"
# -- Admiral Ackbar
#
# THE FOLLOWING "SET", "TRAP", AND "EXEC" COMMANDS ALL FACILITATE
# COLLECTION OF DATA USEFUL FOR DEBUGGING.  SEE THE FILE "DEBUGGING.md"
# ON THE GITHUB PAGE, FOR MORE INFORMATION.

# Ensure that ERR traps are inherited by functions, command substitutions,
# and subshell environments.
set -o errtrace

# Ensure that DEBUG and RETURN traps are inherited by functions, command substitutions,
# and subshell environments.  (The -E causes errors within functions to bubble up.)
set -E -o functrace

# Set up the file descriptor for debugging, and send a brief header to it.
[ -e /proc/self/fd/3 ] || exec 3> /dev/null
echo "SYSTEM_INFO v${MY_VERSION} - DEBUG LOG" >&3
echo -e "==============================\n" >&3

# This line figures out if fd3 has been redirected to a file.
# If yes, the name of the debug log is added to the bottom
# of the system_info report, in the function "fnFINISH_UP".
DEBUG_LOG="$(${SUDO} readlink /proc/self/fd/3 2>/dev/null)"

# This trap writes each line to be executed, just before it is executed, to the debug log
trap 'echo -e "line#: ${LINENO}...\t${BASH_COMMAND}" >&3' DEBUG

# This trap will log all non-0 return codes.
# To prevent some commands from tripping an ERR trap, by returning a non-0 return code,
# I'm imediately following those commands with "|| :" ("or true").
# An example would be a grep that doesn't find it's search string (return code 1).
# In other words, not all non-0 return codes are "errors" per se, but the trap will
# spot and report them.  You can quickly find them in your debugging log by grepping
# for the string "^NON-0" in the log.  These can then be investigated to determine
# if an actual error has occurred.
trap 'echo -e "NON-0: LINE ${LINENO}: RETURN CODE: ${?}\t${BASH_COMMAND}" >&3' ERR

# Log the completion of each function, upon return.
# It's a shame there is no corresponding logging of the entry into a function, only
# a return from a function.  This is why each function in this script includes an
# explicit command to add a log entry showing entry into the function.
trap 'echo -e "leave: ${FUNCNAME} -> back to ${FUNCNAME[1]}\n" >&3' RETURN

fnMAIN

# Close the file descriptor.
# This command is also present in function "fnABORT".
exec 3>&- 2> /dev/null
