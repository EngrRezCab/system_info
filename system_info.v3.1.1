#!/usr/bin/env bash

# system_info.sh
# Written by:   Ken Cormack, unixken@yahoo.com
# Copyright (c) 2020-2021, Ken Cormack
# github:       https://github.com/kencormack/system_info
# license:      GPL 3.0
# Contributor:  William Stearns, william.l.stearns@gmail.com
#
# This script attempts to perform a fairly complete audit of the current
# configuration of a Raspberry Pi.  The target hardware is any variant or
# model of Pi (except the Pico), up to and including the Pi 4B, 400,
# and CM4 modules.
#
# Supported OS versions include Raspbian Buster and the newly renamed
# "Raspberry Pi OS", in 32-bit.  Expect things not to work on the
# 64-bit OS, while it is still beta.  For those running Stretch,
# version 2.1.2 of this script, the last version to support Stretch,
# will remain available on the github page.  Beginning with version
# 3.0.0, support for Stretch has been REMOVED.
#
# No attempt will be made to back-port any later version of this script
# to Stretch or older, nor will I port this to Ubuntu, OSMC, LibreELEC,
# or any other OS distribution available for the Pi.
#
# See the README.md file, at the github link above, for additional info.
#
##################################################

#---------------
# Called by fnPARSE_CMDLINE
#
fnUSAGE()
{
  # This line, included in every function, is part of the debugging/trace
  # log stuff used in testing & development of this script.  See the file
  # DEBBUGGING.md on the github page, for a full explaination of how I
  # chose to implement a debug/trace log.
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo "Usage: $(basename "${0}") [-h|--help] [-v|--version] [-m|--menu <1-17>] [-o|--output <filename>]" >&2
  exit 1
}

#---------------
# Called by fnPARSE_CMDLINE
#
fnVALIDATE_FILENAME()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CHECK=""

  CHECK="$(echo "${REPORT}" | grep -q "^[^-_.A-Za-z0-9/]")"
  if [[ -n "${CHECK}" ]]
  then
    echo
    echo "WARNING: SPECIAL CHARS DETECTED IN FILENAME \"${REPORT}\"" >&2
    echo "Use only A-Z, a-z, 0-9, hyphen (-), underscore (_), period (.), and slash (/)" >&2
    echo
    exit 1
  fi

  if [[ -w "${REPORT}" ]]
  then
    echo "WARNING: FILE EXISTS" >&2
    echo "Will not overwrite existing file." >&2
    echo "Please choose another filename." >&2
    echo
    exit 1
  fi

  if touch "${REPORT}" 2> /dev/null
  then
    true
    # comment/remove the following line when unit testing complete
    # rm "${REPORT}" 2> /dev/null
    # echo "WRITE ACCESS: WRITEABLE"
  else
    echo
    echo "WARNING: PERMISSION DENIED" >&2
    echo "Cannot write file: ${REPORT}" >&2
    echo
    exit 1
  fi
}

#---------------
# Called by mainline
# Calls fnGET_HELP
# Calls fnVERSION
# Calls fnUSAGE
# Calls fnVALIDATE_FILENAME
#
fnPARSE_CMDLINE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local INDEX=""
  local ARG_LIST=""
  local PARSE_STATUS=""

  # Convert the arguments string ($*) to an array and
  # loop through it.  In the loop, current value will
  # be the option and the next one will be the parameter.

  # shellcheck disable=SC2206
  ARG_LIST=(${MY_CMDLINE})

  INDEX=0

  # Something is wrong here.
  # I should be able to use 'for ARGUMENT in ${ARG_LIST}' here,
  # but it only works here, using MY_CMDLINE.
  # :: still scratching my head here ::
  #
  # The following test line correctly shows that the ARG_LIST
  # array ends up with multiple descrete elements...
  #   echo "Number of elements in the array: ${#ARG_LIST[@]}"
  # Yet for some reason, I can't use it in the for loop.
  # Puzzling.  Will have to dig into this a little more, when
  # my brain hurts a little less.  :/

  PARSE_STATUS=NOT_OK

  # for ARGUMENT in ${ARG_LIST}
  for ARGUMENT in ${MY_CMDLINE}
  do
    INDEX=$((INDEX+1))
    case ${ARGUMENT} in
      -h|--help)
        fnGET_HELP
        ;;
      -v|--version)
        fnVERSION
        ;;
      -m|--menu)
        if [[ ${ARG_LIST[INDEX]} -ge 1 ]] && [[ ${ARG_LIST[INDEX]} -le 17 ]]
        then
          MENU="${ARG_LIST[INDEX]}"
        else
          echo "Invalid menu option" >&2
          fnUSAGE
        fi
        PARSE_STATUS=OK
        ;;
      -o|--output)
        if [[ "${ARG_LIST[INDEX]}" = "" ]]
        then
          echo "Missing filename" >&2
          fnUSAGE
        else
          REPORT="${ARG_LIST[INDEX]}"
          fnVALIDATE_FILENAME
        fi
        PARSE_STATUS=OK
        ;;
      *)
        if [[ "${PARSE_STATUS}" = "OK" ]]
        then
          continue
        else
          fnUSAGE
        fi
        ;;
    esac
  done
}

#---------------
# Called by fnPARSE_CMDLINE
#
fnGET_HELP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Thor: "Hey, let's do 'Get Help'.  It's great.  Works every time."
  # Loki: "It's humiliating.  We are not doing 'Get Help'."
  # Thor: "GET HELP!  MY BROTHER'S DYING!"
  clear
  cat <<'EOF' | more -d
SYSTEM_INFO - HELP

  Run without parameters, the script presents a menu, and assigns a default
  filename for the report... ${HOME}/hostname-scriptname-yyyymmdd-hhmmss

  The following parameters and options are supported;
  -h|--help
      You are here.

  -m|--menu <1-17>
      Specifies a menu option to pre-select.  Normally, options chosen from
      the menu are saved in ${HOME}/.system_inforc).  Those saved options
      are recalled and selected next time the script is run.  When the "-m"
      or "--menu" is used, it must be accompanied by a number, 1-17, which
      corresponds to a selection on the menu.  Only one menu option can be
      specified with this parameter.  Use of this flag ignores .system_inforc

  -o|--output <filename>
      Specifies the filename to use for the report.  The script will NOT
      overwrite an existing file, and allows only the following characters
      to be used in the filename:
      A-Z, a-z, 0-9, hyphen (-), underscore (_), period (.), and slash (/)

  -v|--version
      Display version number, and warranty & licensing info.

ADDITIONAL TOOLS FOR DEVELOPMENT...

  The script also supports creation of a pair of reports for development-use.
  These development and testing logs are made available on file descriptors
  3 and 4, and are not meant or required, for normal operation.  They are
  intended to provide valuable troubleshooting data for those who wish to
  modify system_info for their own use.

  See the following for more information about these development options:
  https://github.com/kencormack/system_info/blob/master/DEBUGGING_PROFILING.md

  A Debugging log:
      system_info 3> debug.log

  A profiling log:
      system_info 4> profile.log

  Simultaneous creation of both logs:
      system_info 3> debug.log 4> profile.log

  These do not affect parsing of the commandline parameters described above,
  and each datastream is independent of the other (and, the normal report.)

EOF
  # Thor:  "Classic!"
  # Loki:  "Humiliating."
  # -- 'Thor: Ragnarok'
  exit
}

#---------------
# Called by fnPARSE_CMDLINE
#
fnVERSION()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  clear
  echo "$(basename "${0}") version: ${MY_VERSION}"
  cat <<'EOF' | more -d
Copyright (c) 2020-2021 Ken Cormack

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.

EOF
  exit
}

#---------------
# Called by fnMAIN
#
fnINITIALIZE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Indexed arrays
  declare -a CHOICES
  declare -a OPTIONS

  export PATH="${PATH:+${PATH}:}/usr/sbin:/sbin"
  LC_ALL=C
  LANG=C
  if [[ "${TERM}" = "" ]] || [[ "${TERM}" = "dumb" ]]
  then
    REV=""
    SGR0=""
    BELL=""
  else
    REV="$(tput rev 2>/dev/null)"
    SGR0="$(tput sgr0 2>/dev/null)"
    BELL="$(tput bel 2>/dev/null)"
  fi
  RCFILE="${HOME}/.system_inforc"
  ERROR=" "
  DEG_SYMBOL=$'\xc2\xb0'
  SECTION=""
}

#---------------
# Called by fnMAIN
#
fnDEFINE_OPTIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local INDEX=""

  for INDEX in {0..16}
  do
    CHOICES[${INDEX}]=""
  done

  # The array of menu OPTIONS is defined
  OPTIONS[0]="Pi Hardware"
  OPTIONS[1]="Performance"
  OPTIONS[2]="O/S Config"
  OPTIONS[3]="Memory"
  OPTIONS[4]="Logging"
  OPTIONS[5]="Services"
  OPTIONS[6]="Hardware Busses"
  OPTIONS[7]="Serial & Bluetooth"
  OPTIONS[8]="USB & Other Devices"
  OPTIONS[9]="Filesystems & Storage"
  OPTIONS[10]="Audio & Video"
  OPTIONS[11]="Networking"
  OPTIONS[12]="Network Filesystems"
  OPTIONS[13]="Containers & Virtualization"
  OPTIONS[14]="Modules and Packages"
  OPTIONS[15]="System Security"
  OPTIONS[16]="Run All Of The Above"
}

#---------------
# Called by fnMAIN
#
fnCONFIRM_BASH()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # This guards against people launching this script with an incorrect shell,
  # such as by running 'sh scriptname', overriding the 'shebang'.
  if [[ "${BASH_VERSION}" = "" ]]
  then
    clear
    echo "${BELL}"
    echo "################################################################"
    echo
    echo "ERROR: THE WRONG SHELL IS BEING USED TO RUN THIS SCRIPT."
    echo
    echo "${0} is written for the bash shell only."
    echo "It will not run under sh, ksh, or any other shell but \"bash\"."
    echo
    echo "Please do either this..."
    echo "  $ chmod +x ${0}"
    echo "  $ ./${0}"
    echo
    echo "or this..."
    echo "  $ bash ${0}"
    echo
    echo "...to execute under bash, as intended."
    echo
    echo "################################################################"
    echo
    exit
  fi
}

#---------------
# Called by the mainline
#
fnABORT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Called by a trap, whenever the signals
  # SIGHUP SIGINT SIGQUIT SIGABRT or SIGTERM
  # are received.  We clean up after ourselves.
  echo
  echo "ABORT${BELL}"

  # delete the lshw tmp file
  rm "${TEMPFILE}" 2>/dev/null

  # close the debugging file descriptor
  exec 3>&- 2> /dev/null

  # close the profiling file descriptor
  set +x
  exec 4>&- 2> /dev/null

  # exit the script
  exit
}

#---------------
# Called by fnMAIN and fnDO_INSPECTIONS
#
fnTITLE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo
  echo "               _   VERSION ${MY_VERSION}   _        __"
  echo $' ___ _   _ ___| |_ ___ _ __ ___   (_)_ __  / _| ___'
  echo $'/ __| | | / __| __/ _ \\ \'_ \` _ \\ | | \'_ \\| |_ / _ \\'
  echo $'\__ \ |_| \__ \ ||  __/ | | | | | | | | | |  _| (_) |'
  echo $'|___/\__, |___/\__\___|_| |_| |_| |_|_| |_|_|  \___/'
  echo $'     |___/'
  echo "           RASPBERRY PI SYSTEM INFORMATION REPORT"
  echo
}

#---------------
# Called by multiple functions
#
fnBANNER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo "==============================================================================="
  echo "SYSTEM_INFO(${SECTION}): ${*}"
  echo "==============================================================================="
  echo
}

#---------------
# Called by multiple functions
#
fnSUB_BANNER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo "-------------------------------------------------------"
  echo " ${*}"
  echo
}

#---------------
# Called by multiple functions
#
fnCHECK_COMMAND()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Checks for existence of the command passed in as the function argument.
  # Exit value of 0 when exists, 1 if not exists.
  local CHECK_COMMAND="${1}"

  command -v "${CHECK_COMMAND}" >/dev/null 2>&1
}

#---------------
# Inspect the "mode" (permissions - in octal), owner, and group
# of a specified directory or file.
# Called by passing 4 parameters to the function as follows:
#   fnMOG octal_mode owner group file_or_directory
# Called by fnUSERCHECK and fnCHECK_PERMISSIONS
#
fnMOG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local OCTAL=""
  local OWNER=""
  local GROUP=""
  local CHECKPATH=""
  local COCTAL=""
  local SYMBOLIC=""
  local COWNER=""
  local CGROUP=""

  OCTAL="${1}"      # recommended perms, eg: 755 (rwxr-xr-x)
  OWNER="${2}"      # recommended owner
  GROUP="${3}"      # recommended group
  CHECKPATH="${4}"  # path to check

  if ${SUDO} test -e "${CHECKPATH}"
  then
    # Run commands
    COCTAL="$(${SUDO} stat -L -c %a "${CHECKPATH}")"
    SYMBOLIC="$(${SUDO} stat -L -c %A "${CHECKPATH}")"
    COWNER="$(${SUDO} stat -L -c %U "${CHECKPATH}")"
    CGROUP="$(${SUDO} stat -L -c %G "${CHECKPATH}")"
    # Compare
    echo "[${CHECKPATH}]"
    if [[ "${COCTAL}" != "${OCTAL}" ]]
    then
      echo "  Permissions ... WARN [${COCTAL}] (${SYMBOLIC}) - Recommend [${OCTAL}])"
    else
      echo "  Permissions ... OK [${OCTAL}] (${SYMBOLIC})"
    fi
    if [[ "${COWNER}" != "${OWNER}" ]]
    then
      echo "  Owner ......... WARN [${COWNER}] - Recommend [${OWNER}]"
    else
      echo "  Owner ......... OK [${OWNER}]"
    fi
    if [[ "${CGROUP}" != "${GROUP}" ]]
    then
      echo "  Group ......... WARN [${CGROUP}] - Recommend [${GROUP}]"
    else
      echo "  Group ......... OK [${GROUP}]"
    fi
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnCONFIRM_OS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Written for Raspbian Buster and above.  Stretch and older not supported.
  # if os-release file exists...
  if [[ -f /etc/os-release ]]
  then
    # source the os-release file
    . /etc/os-release 2>/dev/null
    # if Raspbian...
    if [[ "${ID}" = "raspbian" ]]
    then
      # and if older than Buster...
      if [[ "$(echo "${VERSION_ID} < 10" | bc)" -eq 1 ]]
      then
        # too old.
        echo
        fnBANNER "UNSUPPORTED RASPBIAN VERSION"
        echo "This script is designed for Raspbian GNU/Linux 10 (Buster), and above."
        echo "Version ${PRETTY_NAME} is not supported."
        echo
        exit 1
      else
        # if Raspbian, and Buster or newer, then ok.
        echo "OS version check:  ok"
      fi
    else
      # if not Raspbian, then unsupported.
      echo
      fnBANNER "LINUX VERSION UNKNOWN"
      echo "This script is designed for Raspbian GNU/Linux 10 (Buster), and above."
      echo "Unable to identify your version of the operating system... Exiting."
      echo
      exit 1
    fi
  else
    # if os-release file doesn't exist...
    echo
    fnBANNER "LINUX VERSION UNKNOWN"
    echo "This script is designed for Raspbian GNU/Linux 10 (Buster), and above."
    echo "Unable to identify your version of the operating system... Exiting."
    echo
    exit 1
  fi

  if [[ -n "$(readlink /sbin)" ]] && [[ -n "$(readlink /lib)" ]] && [[ -n "$(readlink /bin)" ]]
  then
    PROVENANCE="\"Raspberry Pi OS\""
    RPIOS=1
  else
    PROVENANCE="legacy \"Raspbian\""
    RPIOS=0
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnRING_BUF()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Check that dmesg contains anything we might need.  Examples include the
  # "memory split", "active display driver", "rtc", and several other tests.
  if [[ "$(dmesg | grep "Booting Linux")" = "" ]]
  then
    echo
    fnBANNER "DMESG RING BUFFER HAS WRAPPED - PLEASE REBOOT"
    echo "This script relies on \"dmesg\" to provide some of the data it needs."
    echo
    echo "Kernel messages are stored in a data structure called a ring buffer."
    echo "The buffer is fixed in size, with new data overwriting the oldest data."
    echo "When data we need has already been overwritten, that data is lost to us."
    echo
    echo "Your ring buffer has already wrapped.  Please reboot your system before"
    echo "attempting to re-run this script, to ensure that the buffer contains"
    echo "any data we need."
    echo
    exit 1
  else
    echo "dmesg ring buffer: ok"
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
#
fnSUDO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Disallow direct execution by "root".
  if [[ "${EUID}" -eq 0 ]]
  then
    echo
    echo "ERROR:"
    echo "  Execution directly by \"root\" not permitted."
    echo "  Please run as a normal (non-root) userid."
    echo "  That userid must have \"sudo\" privileges."
    echo
    exit
  fi

  # Set "${SUDO}" so that commands that need
  # root privs will run under sudo
  SUDO=$(type -path sudo)
  if [[ "${EUID}" -ne 0 ]] && [[ "${SUDO}" = "" ]]
  then
    echo
    echo "${0} has not been run as root and sudo is not available, exiting." >&2
    exit 1
  else
    echo "running as user:   $(whoami)"
    if [[ "${EUID}" -ne 0 ]]
    then
      if [[ -n "${SUDO}" ]]
      then
        echo "sudo is available: ok"
      fi
    fi
  fi
}


#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnCHECK_VIRT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(systemd-detect-virt)" = "none" ]]
  then
    echo "virtual machine:   ok"
  else
    echo
    fnBANNER "RUNNING WITHIN A VIRTUAL MACHINE IS NOT SUPPORTED"
    echo "This script does not support running inside a virtual machine."
    echo "Please exit the VM and run the script again."
    echo
    exit 1
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnCHECK_CHROOT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if ${SUDO} systemd-detect-virt --chroot
  then
    echo
    fnBANNER "RUNNING WITHIN A CHROOT'D ENVIRONMENT IS NOT SUPPORTED"
    echo "This script does not support running in a chroot'd environment."
    echo "Please exit the chroot'd environment and run the script again."
    echo
    exit 1
  else
    echo "chroot check:      ok"
  fi
  echo
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnNEW_STYLE_REV_CODES and fnOLD_STYLE_REV_CODES
#
fnGET_REVISION_CODE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PCB_REVISION=""
  local MODEL_NAME=""
  local PROCESSOR=""
  local MANUFACTURER=""
  local MEMORY_SIZE=""
  local ENCODED_FLAG=""
  local WARRANTY_VOID_OLD=""
  local WARRANTY_VOID_NEW=""

  # NOTE: Revision codes, old and new style, are documented here and elsewhere:
  # https://github.com/raspberrypi/documentation/blob/master/hardware/raspberrypi/revision-codes/README.md
  MY_REVISION=$(awk '/^Revision/ { print $NF }' /proc/cpuinfo 2>/dev/null)

  # Force a rev code for testing...
  # MY_REVISION=c03141  ; # CM4
  # MY_REVISION=1000002 ; # Old rev, expired warranty
  # MY_REVISION=0003    ; # Model B w/ mods
  # MY_REVISION=2a020d3 ; # Model 3B+, expired warranty

  ## The following revision-decoding logic was shamelessly borrowed from:
  ## https://raspberrypi.stackexchange.com/questions/100076/what-revisions-does-cat-proc-cpuinfo-return-on-the-new-pi-4-1-2-4gb
  ## I've made only some coding style changes to match the rest of this script,
  ## and accomodated new models released since the original post.

  # These are from the new style revision codes, but we can borrow some
  # of the values, for the old style codes.  The arrays lack the "2.0"
  # board revs, the "Qisda" manufacturer, and the "256/512" MB value used
  # by some of the old-style revision codes.  Rather than modify these
  # arrays, I just use those values directly, in sorting out the old codes.
  PCB_REVISION=("v1.0" "v1.1" "v1.2" "v1.3" "v1.4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
  MODEL_NAME=("A" "B" "A+" "B+" "Pi2B" "Alpha" "CM1" "unknown" "3B" "Zero" "CM3" "unknown" "Zero W" "3B+" "3A+" "internal use only" "CM3+" "4B" "18 ?" "400" "CM4")
  PROCESSOR=("BCM2835" "BCM2836" "BCM2837" "BCM2711" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
  MANUFACTURER=("Sony UK" "Egoman" "Embest" "Sony Japan" "Embest" "Stadium" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
  MEMORY_SIZE=("256 MB" "512 MB" "1024 MB" "2048 MB" "4096 MB" "8192 MB" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
  ENCODED_FLAG=("" "revision is a bit field")
  # This adds a prefix of "1" to the revision code
  WARRANTY_VOID_OLD=("" "warranty void - Pre Pi2")
  # This adds a prefix of "2" to the revision code
  WARRANTY_VOID_NEW=("" "warranty void - Post Pi2")

  # Save as globals so we can make decisions later based on model, ram, etc.
  MY_PCB_REVISION=${PCB_REVISION[$((0x${MY_REVISION}&0xf))]}
  MY_MODEL_NAME=${MODEL_NAME[$((0x${MY_REVISION}>>4&0xff))]}
  MY_PROCESSOR=${PROCESSOR[$((0x${MY_REVISION}>>12&0xf))]}
  MY_MANUFACTURER=${MANUFACTURER[$((0x${MY_REVISION}>>16&0xf))]}
  MY_MEMORY_SIZE=${MEMORY_SIZE[$((0x${MY_REVISION}>>20&7))]}
  MY_ENCODED_FLAG=${ENCODED_FLAG[$((0x${MY_REVISION}>>23&1))]}
  MY_WARRANTY_VOID_OLD=${WARRANTY_VOID_OLD[$((0x${MY_REVISION}>>24&1))]}
  MY_WARRANTY_VOID_NEW=${WARRANTY_VOID_NEW[$((0x${MY_REVISION}>>25&1))]}

  MY_COMMENT=""
  MY_RELEASE_DATE=""

  ENCODED=$((0x${MY_REVISION} >> 23 & 1))

  if [[ ${ENCODED} = 1 ]]
  then
    # NEW STYLE REV CODES
    # See if the rev code has a warranty-void prefix.
    # If yes, a 1-char prefix ("1"=Bit 24, or "2"=Bit 25) is present
    # and the last 6 chars are the actual revision code
    if [[ "${#MY_REVISION}" = 7 ]]
    then
      MY_WARRANTY_VOID_PREFIX="$(echo "${MY_REVISION}" | cut -c1)"
      # Trim off the prefix for other lookups later on.
      MY_BASE_REVISION="$(echo "${MY_REVISION}" | cut -c2-)"
    else
      MY_WARRANTY_VOID_PREFIX=""
      MY_BASE_REVISION="${MY_REVISION}"
    fi
    fnNEW_STYLE_REV_CODES
  else
    # OLD STYLE REV CODES
    # See if the rev code has a warranty-void prefix
    # If yes, the 3-char warranty-void prefix ("100") is present
    # and the last 4 chars are the actual revision code
    if [[ "${#MY_REVISION}" = 7 ]]
    then
      MY_WARRANTY_VOID_PREFIX="$(echo "${MY_REVISION}" | cut -c1-3)"
      # Trim off the prefix for other lookups later on.
      MY_BASE_REVISION="$(echo "${MY_REVISION}" | cut -c4-)"
    else
      # Otherwise, no prefix is present
      MY_WARRANTY_VOID_PREFIX=""
      MY_BASE_REVISION="${MY_REVISION}"
    fi
    fnOLD_STYLE_REV_CODES
  fi

  # Some features of the 4B, also present in later models, allow these
  # to be lumped together for certain processing in this script.  With
  # this, they can all be treated in common fashion without having to
  # check for each model type specifically.
  case "${MY_MODEL_NAME}" in
    4B|CM4|400)
      PI4_FAMILY="1"
      ;;
    *)
      PI4_FAMILY="0"
      ;;
  esac

  # Here, I strip the lead alpha-character from the base revision number,
  # that indicates the amount of RAM present (a=1GB, b=4GB, c=4GB, d=8GB),
  # to get to the data that otherwise designates the model/rev.

  # Pi 4B:
  # Revision [abc]03111 is original board with USB-C power design flaw.
  # Revision [abc]03112 is v1.2 board with fix.
  # (First char, a, b, c or d, refers to 1GB, 2GB, 4GB, or 8GB memory.)
  # Revision [bcd]03114 are the 2/4/8GB v1.4 board, which also has the fix.
  if [[ "$(echo "${MY_REVISION}" | cut -c2-)" = "03111" ]]
  then
    MY_COMMENT="USB-C power design flaw affecting \"Smart\" USB-C cables."
  fi
  # Pi CM4:
  # Educated guesses for the as yet unreleased CM4
  if [[ "$(echo "${MY_REVISION}" | cut -c2-)" = "03141" ]]
  then
    MY_COMMENT="Guessing at this - CM4 rev codes not yet published."
  fi
}

#---------------
# Called by fnGET_REVISION_CODE
#
fnNEW_STYLE_REV_CODES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  case "${MY_BASE_REVISION}" in
    a01040)
      # 2 Model B
      MY_RELEASE_DATE="Unknown"
      ;;
    a01041)
      # 2 Model B
      MY_RELEASE_DATE="Q1 2015"
      ;;
    a21041)
      # 2 Model B
      MY_RELEASE_DATE="Q1 2015"
      ;;
    a22042)
      # 2 Model B (with BCM2837)
      MY_RELEASE_DATE="Q3 2016"
      ;;
    900021)
      # A+
      MY_RELEASE_DATE="Q3 2016"
      ;;
    900032)
      # B+
      MY_RELEASE_DATE="Q2 2016?"
      ;;
    900092)
      # Zero
      MY_RELEASE_DATE="Q4 2015"
      ;;
    900093)
      # Zero
      MY_RELEASE_DATE="Q2 2016"
      ;;
    920093)
      # Zero
      MY_RELEASE_DATE="Q4 2016?"
      ;;
    9000c1)
      # Zero W
      MY_RELEASE_DATE="Q1 2017"
      ;;
    a02082)
      # 3 Model B
      MY_RELEASE_DATE="Q1 2016"
      ;;
    a020a0)
      # CM3 (and CM3 Lite)
      MY_RELEASE_DATE="Q1 2017"
      ;;
    a22082)
      # 3 Model B
      MY_RELEASE_DATE="Q1 2016"
      ;;
    a32082)
      # 3 Model B
      MY_RELEASE_DATE="Q4 2016"
      ;;
    a020d3)
      # 3 Model B+
      MY_RELEASE_DATE="Q1 2018"
      ;;
    9020e0)
      # 3 Model A+
      MY_RELEASE_DATE="Q4 2018"
      ;;
    a02100)
      # CM3+
      MY_RELEASE_DATE="Q1 2019"
      ;;
    [abc]03111)
      # 4 Model B v1.1 - 1/2/4GB
      MY_RELEASE_DATE="Q2 2019"
      ;;
    a03112)
      # 4 Model B v1.2 - 1GB
      MY_RELEASE_DATE="Q1 2020 - Special Order Only"
      ;;
    [bc]03112)
      # 4 Model B v1.2 - 2/4GB
      MY_RELEASE_DATE="Q1 2020"
      ;;
    [bc]03114)
      # 4 Model B v1.4 - 2/4GB
      MY_RELEASE_DATE="Q3 2020"
      ;;
    d03114)
      # 4 Model B v1.4 - 8GB
      MY_RELEASE_DATE="Q1 2020"
      ;;
    c03130)
      # Pi 400
      MY_RELEASE_DATE="Q4 2020"
      ;;
    [abcd]03141)
      # CM4 - 1/2/4/8GB?
      MY_RELEASE_DATE="Q4 2020"
      ;;
    *)
      # No match found
      MY_RELEASE_DATE="Unknown"
      ;;
  esac
}

#---------------
# Called by fnGET_REVISION_CODE
#
fnOLD_STYLE_REV_CODES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  case "${MY_BASE_REVISION}" in
    0002)
      # B 1.0 256MB
      MY_PCB_REVISION=${PCB_REVISION[0]}
      MY_MODEL_NAME=${MODEL_NAME[1]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[1]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
      MY_RELEASE_DATE="Q1 2012"
      ;;
    0003)
      # B 1.0 256MB
      MY_PCB_REVISION=${PCB_REVISION[0]}
      MY_MODEL_NAME=${MODEL_NAME[1]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[1]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
      MY_RELEASE_DATE="Q3 2012"
      MY_COMMENT="Fuses mod and D14 removed"
      ;;
    0004)
      # B 2.0 256MB
      MY_PCB_REVISION="2.0"
      MY_MODEL_NAME=${MODEL_NAME[1]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[0]}
      MY_RELEASE_DATE="Q3 2012"
      MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
      ;;
    0005)
      # B 2.0 256MB
      MY_PCB_REVISION="2.0"
      MY_MODEL_NAME=${MODEL_NAME[1]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER="Qisda"
      MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
      MY_RELEASE_DATE="Q4 2012"
      ;;
    0006)
      # B 2.0 256MB
      MY_PCB_REVISION="2.0"
      MY_MODEL_NAME=${MODEL_NAME[1]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[1]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
      MY_RELEASE_DATE="Q4 2012"
      ;;
    0007)
      # A 2.0 256MB
      MY_PCB_REVISION="2.0"
      MY_MODEL_NAME=${MODEL_NAME[0]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[1]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
      MY_RELEASE_DATE="Q1 2013"
      ;;
    0008)
      # A 2.0 256MB
      MY_PCB_REVISION="2.0"
      MY_MODEL_NAME=${MODEL_NAME[0]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[0]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
      MY_RELEASE_DATE="Q1 2013"
      ;;
    0009)
      # A 2.0 256MB
      MY_PCB_REVISION="2.0"
      MY_MODEL_NAME=${MODEL_NAME[0]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER="Qisda"
      MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
      MY_RELEASE_DATE="Q1 2013"
      ;;
    000d)
      # B 2.0 512MB
      MY_PCB_REVISION="2.0"
      MY_MODEL_NAME=${MODEL_NAME[1]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[1]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
      MY_RELEASE_DATE="Q4 2012"
      ;;
    000e)
      # B 2.0 512MB
      MY_PCB_REVISION="2.0"
      MY_MODEL_NAME=${MODEL_NAME[1]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[0]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
      MY_RELEASE_DATE="Q4 2012"
      ;;
    000f)
      # B 2.0 512MB
      MY_PCB_REVISION="2.0"
      MY_MODEL_NAME=${MODEL_NAME[1]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[1]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
      MY_RELEASE_DATE="Q4 2012"
      ;;
    0010)
      # B+ 1.2 512MB
      MY_PCB_REVISION=${PCB_REVISION[2]}
      MY_MODEL_NAME=${MODEL_NAME[3]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[0]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
      MY_RELEASE_DATE="Q3 2014"
      ;;
    0011)
      # CM1 1.0 512MB
      MY_PCB_REVISION=${PCB_REVISION[0]}
      MY_MODEL_NAME=${MODEL_NAME[6]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[0]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
      MY_RELEASE_DATE="Q2 2014"
      ;;
    0012)
      # A+ 1.1 256MB
      MY_PCB_REVISION=${PCB_REVISION[1]}
      MY_MODEL_NAME=${MODEL_NAME[2]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[0]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[0]}
      MY_RELEASE_DATE="Q4 2014"
      ;;
    0013)
      # B+ 1.2 512MB
      MY_PCB_REVISION=${PCB_REVISION[2]}
      MY_MODEL_NAME=${MODEL_NAME[3]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[2]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
      MY_RELEASE_DATE="Q1 2015"
      ;;
    0014)
      # CM1 1.0 512MB
      MY_PCB_REVISION=${PCB_REVISION[0]}
      MY_MODEL_NAME=${MODEL_NAME[6]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[2]}
      MY_MEMORY_SIZE=${MEMORY_SIZE[1]}
      MY_RELEASE_DATE="Q2 2014"
      ;;
    0015)
      # A+ 1.1 256MB/512MB
      MY_PCB_REVISION=${PCB_REVISION[1]}
      MY_MODEL_NAME=${MODEL_NAME[2]}
      MY_PROCESSOR=${PROCESSOR[0]}
      MY_MANUFACTURER=${MANUFACTURER[2]}
      MY_MEMORY_SIZE="256MB/512MB"
      MY_RELEASE_DATE="?"
      ;;
    *)
      MY_PCB_REVISION="Unknown"
      MY_MODEL_NAME="Unknown"
      MY_PROCESSOR="Unknown"
      MY_MANUFACTURER="Unknown"
      MY_MEMORY_SIZE="Unknown"
      MY_RELEASE_DATE="Unknown"
      ;;
  esac
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnPRINT_DECODED_REV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ ${ENCODED} = 1 ]]
  then
    fnBANNER "NEW STYLE SYSTEM REVISION NUMBER"
  else
    fnBANNER "OLD STYLE SYSTEM REVISION NUMBER"
  fi
  echo "Revision      : ${MY_REVISION}"
  echo "PCB Revision  : ${MY_PCB_REVISION}"
  echo "Model Name    : ${MY_MODEL_NAME}"
  echo "Processor     : ${MY_PROCESSOR}"
  echo "Manufacturer  : ${MY_MANUFACTURER}"
  echo "Memory Size   : ${MY_MEMORY_SIZE}"
  if [[ ${ENCODED} = 1 ]]
  then
    echo "Encoded Flag  : ${MY_ENCODED_FLAG}"
  fi
  if [[ -n "${MY_WARRANTY_VOID_OLD}" ]] || [[ -n "${MY_WARRANTY_VOID_NEW}" ]] || [[ -n "${MY_WARRANTY_VOID_PREFIX}" ]]
  then
    echo "Warranty Void : yes"
  else
    echo "Warranty Void : no"
  fi
  echo

  if [[ -n "${MY_RELEASE_DATE}" ]]
  then
    echo "Release Date  : ${MY_RELEASE_DATE}"
  fi

  if [[ -n "${MY_COMMENT}" ]]
  then
    echo "Model Notes   : ${MY_COMMENT}"
  fi
  echo
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
#
fnCHK_PACKAGES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PKG_MISSING=""
  local REQUIRED=""
  local REQ_HIT=""
  local REQ_MAX=""
  local SUPPLEMENTAL=""
  local SUP_HIT=""
  local SUP_MAX=""

  PKG_MISSING=0
  if fnCHECK_COMMAND dpkg
  then
    #################################
    # First, the required packages
    REQUIRED=$(dpkg -l 2>/dev/null | awk '{ print $2 }' | grep -E -i "^agnostics$|^alsa-utils$|^bc$|^bluez$|^coreutils$|^cron$|^i2c-tools$|^initramfs-tools$|^iproute2$|^libc-bin$|^libraspberrypi-bin$|^lsb-release$|^lshw$|^net-tools$|^procps$|^rpi-eeprom$|^sed$|^systemd$|^util-linux$|^usbutils$|^v4l-utils$|^wireless-tools$")
    REQ_HIT=0
    REQ_MAX=0
    for PACKAGE in agnostics alsa-utils bc bluez coreutils cron i2c-tools initramfs-tools iproute2 libc-bin libraspberrypi-bin lsb-release lshw net-tools procps rpi-eeprom usbutils sed systemd util-linux v4l-utils wireless-tools
    do
      if [[ "${PACKAGE}" = "rpi-eeprom" ]]
      then
        # If the Pi is not a 4B, 400, or CM4, then skip checking for
        # the rpi-eeprom package
        if [[ "${PI4_FAMILY}" != "1" ]]
        then
          continue
        fi
      fi
      # Otherwise, for all packages, on all models...
      # If the package is installed...
      if [[ "$(echo "${REQUIRED}" | grep "${PACKAGE}")" != "" ]]
      then
        (( REQ_HIT++ )) || :
      else
        # Otherwise, tell the user to install it.
        fnBANNER "Required package \"${PACKAGE}\" is not installed." | grep -v "^$" || :
        echo "Install with:"
        echo "  sudo apt install -y ${PACKAGE}"
        PKG_MISSING=1
        echo
      fi
      (( REQ_MAX++ )) || :
    done
    if [[ ${PKG_MISSING} -ne 0 ]]
    then
      fnBANNER "Once any missing packages are installed, re-run this script."
      echo
      exit
    else
      echo "${REQ_HIT} out of ${REQ_MAX} required packages are installed."
      echo "All core inspections will be performed."
      echo

      ######################################
      # Now, the supplemental packages.  If installed, great.
      # If not installed, don't trouble the user to add them.
      SUPPLEMENTAL=$(dpkg -l 2>/dev/null | awk '{ print $2 }' | grep -E -i "^apparmor$|^at$|^auditd$|^chkrootkit$|^clamav$|^cups-client$|^curl$|^dc$|^docker-ce-cli$|^ethtool$|^hdparm$|^lirc$|^lm-sensors$|^lvm2$|^lynis$|^m4$|^mdadm$|^nfs-kernel-server$|^nmap$|^pciutils$|^perl-base$|^pigpiod$|^python3-gpiozero$|^quota$|^rfkill$|^rkhunter$|^rng-tools$|^rpcbind$|^rtl-sdr$|^samba$|^screen$|^smartmontools$|^snort$|^sysbench$|^sysstat$|^systemd-container$|^systemd-coredump$|^tmux|^tripwire$|^ufw$|^unhide$|^watchdog$|^wiringpi$|^x11-xserver-utils$")
      SUP_HIT=0
      SUP_MAX=0
      FOUND_SUPPS=""
      # They also appear as variables here...
      for PACKAGE in apparmor at auditd chkrootkit clamav cups-client curl dc docker-ce-cli ethtool hdparm lirc lm-sensors lvm2 lynis m4 mdadm nfs-kernel-server nmap pciutils perl-base pigpiod python3-gpiozero quota rfkill rkhunter rng-tools rpcbind rtl-sdr samba screen smartmontools snort sysbench sysstat systemd-container systemd-coredump tmux tripwire ufw unhide watchdog wiringpi x11-xserver-utils
      do
        # If wiringpi is installed, it needs to be v2.52 on the Pi 4B
        # See:
        # http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/
        # This script will not support WiringPi on a 400 or CM4.
        if [[ "${PACKAGE}" = "wiringpi" ]]
        then
          WIRINGPI_VERS=$(gpio -v 2>/dev/null | head -1 | awk '{ print $NF }')
          if [[ "${WIRINGPI_VERS}" = "2.52" ]]
          then
            # Exclude these models from wiringpi package check
            if [[ "${MY_MODEL_NAME}" != "400" ]] && [[ "${MY_MODEL_NAME}" != "CM4" ]]
            then
              (( SUP_HIT++ ))
              (( SUP_MAX++ ))
              FOUND_SUPPS="${FOUND_SUPPS} ${PACKAGE}"
              echo "DEBUG: ${PACKAGE} is ${WIRINGPI_VERS}" >&3
              continue
            fi
          fi
          # If not a 4B or later, wiringpi v2.50 from the repositories will do
          if [[ "${PI4_FAMILY}" != "1" ]]
          then
            (( SUP_HIT++ ))
            echo "DEBUG: ${PACKAGE} is ${WIRINGPI_VERS}" >&3
            FOUND_SUPPS="${FOUND_SUPPS} ${PACKAGE}"
          fi
          (( SUP_MAX++ ))
          #FOUND_SUPPS="${FOUND_SUPPS} ${PACKAGE}"
        else
          # Otherwise, for all other packages, on all models...
          # If the package is installed...
          if [[ "$(echo "${SUPPLEMENTAL}" | grep "${PACKAGE}")" != "" ]]
          then
            (( SUP_HIT++ )) || :
            FOUND_SUPPS="${FOUND_SUPPS} ${PACKAGE}"
          else
            echo "DEBUG: PKG ${PACKAGE} NOT installed" >&3
          fi
          (( SUP_MAX++ )) || :
          #FOUND_SUPPS="${FOUND_SUPPS} ${PACKAGE}"
        fi
      done
      echo "${SUP_HIT} out of ${SUP_MAX} supplemental packages are installed."
      if [[ "${SUP_HIT}" -gt 0 ]]
      then
        echo "Some supplemental inspections can be performed."
        echo "DEBUG: Found Supplemental Packages: ${FOUND_SUPPS}" >&3
      else
        echo "No supplemental inspections can be performed."
      fi
      echo
    fi
  else
    echo "Missing utility dpkg, unable to verify package dependencies" >&2
    exit 1
  fi
}

#---------------
# Called by fnDO_INSPECTIONS
# Calls fnBANNER
#
fnSHOW_SUPP_PKGS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n "${FOUND_SUPPS}" ]]
  then
    fnBANNER "THE FOLLOWING INSTALLED PACKAGES ALLOW ADDITIONAL SUPPLEMENTATL INSPECTIONS"
    # Try adding some variant of this, to list found packages in the report...
    echo "${FOUND_SUPPS}" | sed 's/ /\n/g' | column -c 80
    #   or..
    # echo "${FOUND_SUPPS}" | tr ' ' '\n' | column -c 80
    # Note: 'column' is part of package "bsdmainutils".
    # (Is that part of a base install?)
    echo
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
#
fnLSHW_BUSINFO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo -n "One moment, please... "
  TEMPFILE="$(mktemp -p /tmp system_info."${PPID}".XXXXXX)"
  ${SUDO} lshw -businfo >>"${TEMPFILE}" 2>/dev/null
  # The tmpfile negates need to run the above slow command multiple times.
  # We'll grab the next few variables now, for use in later routines.
  LSHW_INPUT=$(grep "input" "${TEMPFILE}" 2>/dev/null | head -1)
  LSHW_STORAGE=$(grep "storage" "${TEMPFILE}" 2>/dev/null | head -1)
  LSHW_GENERIC=$(grep "generic" "${TEMPFILE}" 2>/dev/null | head -1)
  LSHW_MULTIMEDIA=$(grep "multimedia" "${TEMPFILE}" 2>/dev/null | head -1)
  LSHW_COMMUNICATION=$(grep "communication" "${TEMPFILE}" 2>/dev/null | head -1)
  echo "Ready."
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnSYSTEM_ID()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEM IDENTIFICATION"
  echo "Hostname: $(hostname)"
  echo "Serial #: $(awk '/^Serial/ { print $NF }' /proc/cpuinfo 2>/dev/null)"
  echo
}

#---------------
# Called by fnOS
#
fnMODPROBE_CONFIGS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  MODPROBE_CONFIGS=0
  if [[ "$(lsmod | grep "configs")" = "" ]]
  then
    ${SUDO} modprobe configs
    MODPROBE_CONFIGS=1
  fi
}

#---------------
# Called by fnOS
#
fnRMMOD_CONFIGS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(lsmod | grep "configs")" != "" ]] && [[ "${MODPROBE_CONFIGS}" -eq 1 ]]
  then
    ${SUDO} rmmod configs
    MODPROBE_CONFIGS=0
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER, fnMODPROBE_CONFIGS, fnRMMOD_CONFIGS
#
fnOS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local TARGET=""
  local AUTOLOGIN_GUI=""
  local AUTOLOGIN_TTY=""

  fnBANNER "OPERATING SYSTEM"
  echo "OPERATING SYSTEM PROVENANCE:"
  echo "This Pi was built from a ${PROVENANCE} SD image..."
  cat /etc/rpi-issue
  # or... cat /boot/issue.txt
  echo
  echo "NOTE #1:"
  echo "You can append that hash to the end of this URL, to see"
  echo "the exact state of the software that made up that image."
  echo "https://github.com/RPi-Distro/pi-gen/commit/"
  echo
  echo "NOTE #2:"
  echo "If you ever wanted/needed to re-download the exact image"
  echo "that was used to first image this Pi, you could go to the"
  echo "following URL and look for the FIRST SIX characters of"
  echo "the hash reported by this additional provenance info."
  echo
  echo "  https://github.com/RPi-Distro/pi-gen/releases/"
  echo
  echo "If you see those characters listed, you can probably find"
  echo "a copy of that image at the following URL..."
  echo
  echo "  https://downloads.raspberrypi.org/"
  echo

  echo "${PRETTY_NAME}"
  uname -a
  echo

  echo "LSB_RELEASE:"
  lsb_release -a 2>/dev/null
  echo

  echo "HOSTNAMECTL:"
  hostnamectl status 2> /dev/null
  echo

  echo "OSTYPE.............. ${OSTYPE}"
  echo

  if [[ "$(vcgencmd get_config arm_64bit | cut -f2 -d"=")" = "1" ]]
  then
    echo "KERNEL IS........... 64-BIT"
  else
    echo "KERNEL IS........... 32-BIT"
  fi

  if [[ -c /dev/kvm ]]
  then
    echo "KVM SUPPORT......... enabled"
  else
    echo "KVM SUPPORT......... disabled"
  fi

  fnMODPROBE_CONFIGS

  if [[ "$(${SUDO} gunzip -c /proc/config.gz | grep "CONFIG_SECURITY_SELINUX=[ym]")" != "" ]]
  then
    echo "SELINUX............. enabled"
    # HAS_SELINUX="yes"
  else
    echo "SELINUX............. not present in this kernel"
    # HAS_SELINUX="no"
  fi
  if [[ "$(${SUDO} gunzip -c /proc/config.gz | grep "CONFIG_SECURITY_APPARMOR=[ym]")" != "" ]]
  then
    echo "APPARMOR............ enabled"
    HAS_APPARMOR="yes"
  else
    echo "APPARMOR............ not present in this kernel"
    HAS_APPARMOR="no"
  fi
  if [[ "$(${SUDO} gunzip -c /proc/config.gz | grep "CONFIG_AUDIT=[ym]")" != "" ]]
  then
    echo "AUDITD SUPPORT...... enabled"
    HAS_AUDITD="yes"
  else
    echo "AUDITD SUPPORT...... not present in this kernel"
    HAS_AUDITD="no"
  fi
  echo

  fnRMMOD_CONFIGS

  echo -n "DEFAULT BOOT TARGET. "
  TARGET="$(stat /lib/systemd/system/default.target | grep "File:" | awk '{ print $NF }')"
  systemctl list-units --type=target | iconv -f UTF8 -t ASCII//TRANSLIT | grep "${TARGET}" | awk '{ print $5" "$6" "$7" "$8" "$9 }'

  if [[ -f /etc/lightdm/lightdm.conf ]]
  then
    echo -n "GUI AUTOLOGIN....... "
    AUTOLOGIN_GUI="$(grep "^autologin-user=" /etc/lightdm/lightdm.conf | cut -f2 -d"=")"
    if [[ -n "${AUTOLOGIN_GUI}" ]]
    then
      echo "${AUTOLOGIN_GUI}"
    else
      echo "none"
    fi
  fi

  echo -n "TTY AUTOLOGIN....... "
  AUTOLOGIN_TTY="$(grep "^ExecStart=" /lib/systemd/system/getty@.service | grep "autologin" | awk '{ print $3 }')"
  if [[ -n "${AUTOLOGIN_TTY}" ]]
  then
    echo "${AUTOLOGIN_TTY}"
  else
    echo "none"
  fi
  echo

  echo "BASH VERSION........ ${BASH_VERSION}"
  echo

  echo -n "UPTIME.............. "
  uptime -p
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnMAC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "MAC-ADDRESS(ES)"
  ifconfig | grep '[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:' | awk '{print $2}' | tr "a-f" "A-F" | sort
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnMODEL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "MODEL AND FIRMWARE VERSION"
  strings /sys/firmware/devicetree/base/model
  echo
  cat /etc/rpi-issue
  # or... cat /boot/issue.txt
  echo
  vcgencmd version
  echo
  fnBANNER "VIDEO CORE VERSION AND LOG STATUS"
  vcgencmd vcos version
  echo
  vcgencmd vcos log status
  echo
  fnBANNER "VIDEO CORE OUT-OF-MEMORY EVENTS"
  vcgencmd mem_oom
  echo
  fnBANNER "VIDEO CORE RELOCATABLE MEMORY STATS"
  vcgencmd mem_reloc_stats
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnDIAGRAM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND pinout
  then
    fnBANNER "SYSTEM DIAGRAM (***)"
    pinout -m
    echo
  fi
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnCPU()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CPU INFORMATION"
  lscpu
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER, fnSUB_BANNER
#
fnSENSORS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND sensors
  then
    fnBANNER "LM-SENSORS (***)"
    sensors
  fi
  if fnCHECK_COMMAND sensors-detect
  then
    fnSUB_BANNER "Searching for sensors..."
    ${SUDO} sensors-detect --auto
    echo
  fi
  echo " ----------------------------------------------------"
  systemctl status lm-sensors.service | iconv -f UTF8 -t ASCII//TRANSLIT
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
#
fnHOW_BOOT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MY_OTP=""
  local BOOT_TO_USB=""

  # Boot-from-USB mass storage will be handled differently on the Pi 4B,
  # 400, and CM4, versus older models.
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    # The Pi 4B, 400, and CM4 use an EEPROM to control it's boot source.
    fnBANNER "PI MODEL ${MY_MODEL_NAME} EEPROM VERSION"
    vcgencmd bootloader_version
    echo
    if fnCHECK_COMMAND rpi-eeprom-update
    then
      # This command will indicate that an update is required, if the
      # timestamp of the most recent file in the firmware directory
      # (normally /lib/firmware/raspberrypi/bootloader/critical)
      # is newer than that reported by the current bootloader.
      fnBANNER "PI MODEL ${MY_MODEL_NAME} EEPROM UPDATE STATUS"
      ${SUDO} rpi-eeprom-update
      echo
    else
      echo "Missing utility rpi-eeprom-update, skipping eeprom update check" >&2
    fi

    fnBANNER "PI MODEL ${MY_MODEL_NAME} EEPROM CONFIG"
    echo "The meaning of each of these is documented here:"
    echo "https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711_bootloader_config.md"
    echo
    vcgencmd bootloader_config
  else
    # Some older Pi models use OTP (One Time Programable) memory to control
    # whether the Pi can boot from USB mass storage.  Here, we check the
    # model, and then perform the appropriate examination.  OTP-managed
    # USB mass storage boot is available on Pi 2B v1.2, 3A+, 3B, and 3B+
    # models only.  Any other model will skip this test.  The Pi 3B+
    # comes from the factory with boot from USB mass storage enabled.
    # If a Model 2B, make sure it's a v1.2 unit.
    MY_OTP=${MY_MODEL_NAME}
    if [[ "${MY_MODEL_NAME}" = "Pi2B" ]] && [[ "${MY_PROCESSOR}" = "BCM2837" ]]
    then
      MY_OTP="Pi2Bv1.2"
    fi
    case ${MY_OTP} in
      Pi2Bv1.2|3A+|3B|3B+)
        fnBANNER "OTP BOOT-FROM-USB STATUS"
        BOOT_TO_USB=$(vcgencmd otp_dump | grep "^17:")
        if [[ "${BOOT_TO_USB}" = "17:3020000a" ]]
        then
          echo "Boot From USB: Enabled"
        else
          echo "Boot From USB: Available, but not enabled"
        fi
        ;;
      * )
        echo "Boot From USB: Feature not available on this model"
        ;;
    esac
    echo
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnDTOVERLAYS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ACTIVE DEVICE TREE OVERLAYS"
  ${SUDO} vcdbg log msg 2>&1 | grep "Loaded overlay" | cut -f2- -d":"
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnDTPARAMS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ACTIVE DEVICE TREE PARAMS"
  ${SUDO} vcdbg log msg 2>&1 | grep "dtparam:" | cut -f2- -d":"
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnSYSCTL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSCTL KERNEL VARIABLES"
  cat /etc/sysctl.conf /etc/sysctl.d/*.conf | grep -E -v "^$|^#" | sort
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnLEDS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local TRIGGER=""

  # This section needs study for Pi 4B ethernet LEDs...
  # dtparam=eth_led0=4
  # dtparam=eth_led1=4
  #
  # perhaps use "sudo vcdbg log msg" and grep for:
  # dtparam: eth_led0=
  # dtparam: eth_led1=
  # (maybe even "dtparam: act_led_trigger=heartbeat" for ACT LED, below, too.)
  #
  # eth_led0 is green
  # eth_led1 is amber
  #
  # The comments are also hard to decipher (e.g. what's the difference
  # between 0, 2, and 7?):
  # 0=Speed/Activity (default) 1=Speed
  # 2=Flash activity           3=FDX
  # 4=Off                      5=On
  # 6=Alt                      7=Speed/Flash
  # 8=Link                     9=Activity
  #
  # My understanding is:
  #
  # Speed means on for a fast link (probably 1Gb/s), otherwise off.
  #
  # Activity inverts the current state for a short period for every packet,
  # so more traffic means more flicker.
  #
  # Flash activity is like Activity but without the proportionality - the
  # pulses (which could be on or off depending on the other part of the
  # mode) are a fixed width and the gaps are of (the same) minimum width,
  # such that you see a clear flash pattern if there is activity and a steady
  # state if not.
  #
  # It looks like 2 is mislabelled and should just say Flash activity.
  #
  fnBANNER "LED TRIGGERS"
  TRIGGER=""
  if [[ -f /sys/class/leds/led0/trigger ]]
  then
    echo -n "LED0: "
    sed 's/ /\n/g' < /sys/class/leds/led0/trigger | while read -r TRIGGER
    do
      echo "${TRIGGER}" | grep -F "[" || :
    done
  fi
  if [[ -f /sys/class/leds/led1/trigger ]]
  then
    echo -n "LED1: "
    sed 's/ /\n/g' < /sys/class/leds/led1/trigger | while read -r TRIGGER
    do
      echo "${TRIGGER}" | grep -F "[" || :
    done
  fi
  if [[ -f /sys/class/leds/mmc0::/trigger ]]
  then
    echo -n "MMC0: "
    sed 's/ /\n/g' < /sys/class/leds/mmc0::/trigger | while read -r TRIGGER
    do
      echo "${TRIGGER}" | grep -F "[" || :
    done
  fi
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnCMDLINE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CMDLINE.TXT"
  cat /boot/cmdline.txt 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnCONFIGTXT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CONFIG.TXT SETTINGS"
  grep -E -v "^$|^#" < /boot/config.txt 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
#
fnMEMSPLIT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ARM=""
  local GPU=""

  fnBANNER "MEMORY SPLIT"
  # There is a flaw in "vcgencmd get_mem arm" on Pi 4B and later models with
  # more than 1GB of memory.  On those models, the command only considers the
  # first GB of memory.  The technique used here instead, is accurate on all
  # Pi models regardless of memory.
  ARM=$(($(dmesg | grep "Memory:" | grep "available" | cut -f2 -d"/" | cut -f1 -d"K") / 1024 ))
  ARM=$(printf "%4d" "${ARM}")
  echo "ARM: ${ARM} MB"
  GPU="$(vcgencmd get_mem gpu | cut -f2 -d"=" | sed 's/M$//')"
  GPU=$(printf "%4d" "${GPU}")
  echo "GPU: ${GPU} MB"
  echo
  echo "Note: GPU hardware-accelerated codecs will be disabled if \"gpu_mem=16\"."
  echo "At least \"gpu_mem=96\" is required for HW codecs to run correctly."
  echo "At least \"gpu_mem=128\" is required for camera operation."
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnDISPDRV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ACTIVE DISPLAY DRIVER"
  # If two particular modules are not running, it's the Broadcom driver.
  # If the modules are loaded, the "fake" OpenGL driver shows "firmwarekms"
  # in dmesg.  If the modules are loaded, the "full" OpenGL driver does not
  # show "firmwarekms" in dmesg.  An example of why we needed to check for
  # ring buffer wrap earlier.  We need to remember which driver is used -
  # we'll need this info later.
  if [[ "$(lsmod | awk '{ print $1 }' | grep "^vc4")" = "" ]] && [[ "$(lsmod | awk '{ print $1 }' | grep "^drm")" = "" ]]
  then
    DISP_DRIVER="broadcom"
    echo "Broadcom Display Driver"
  else
    if [[ "$(dmesg | grep "firmwarekms")" != "" ]]
    then
      DISP_DRIVER="fake"
      echo "\"Fake\" OpenGL Display Driver"
    else
      DISP_DRIVER="full"
      echo "\"Full\" OpenGL Display Driver"
    fi
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnPROCSPEED()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local FREQ=""
  local MHZ=""

  fnBANNER "PROCESSOR SPEEDS"
  FREQ=$(vcgencmd measure_clock arm | cut -f2 -d"=")
  MHZ=$((FREQ / 1000000))
  MHZ=$(printf "%4d" "${MHZ}")
  echo " CPU: ${MHZ} MHz"
  FREQ=$(vcgencmd measure_clock core | cut -f2 -d"=")
  MHZ=$((FREQ / 1000000))
  MHZ=$(printf "%4d" "${MHZ}")
  echo "CORE: ${MHZ} MHz"
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnOVERCLOCK()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CLOCK_STUFF=""

  # For details see:
  # https://www.raspberrypi.org/documentation/configuration/config-txt/overclocking.md
  CLOCK_STUFF=$(grep -E -v "^$|^#" /boot/config.txt | grep -E -i "^arm_freq=|^gpu_freq=|^core_freq=|^h264_freq=|^isp_freq=|^v3d_freq=|^hevc_freq=|^sdram_freq=|^over_voltage=|^over_voltage_sdram=|^over_voltage_sdram_c=|^over_voltage_sdram_i=|^over_voltage_sdram_p=|^force_turbo=|^initial_turbo=|^arm_freq_min=|^core_freq_min=|^gpu_freq_min=|^h264_freq_min=|^isp_freq_min=|^v3d_freq_min=|^hevc_freq_min=|^sdram_freq_min=|^over_voltage_min=|^temp_limit=|^temp_soft_limit=|^hdmi_enable_4kp60=|^enable_tvout=")

  if [[ -n "${CLOCK_STUFF}" ]]
  then
    fnBANNER "CLOCKSPEED / OVERCLOCKING OPTIONS FOUND IN CONFIG.TXT"
    echo "${CLOCK_STUFF}" | sort
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnRING_OSCILLATOR()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ALL=""
  local C=""
  local F=""

  fnBANNER "RING OSCILLATOR STATS"
  if fnCHECK_COMMAND dc
  then
    # SUPPLEMENTAL CONVERSION to Fahrenheit
    ALL="$(vcgencmd read_ring_osc)"
    C="$(vcgencmd read_ring_osc | cut -f4 -d'(' | cut -f1 -d"'")"
    F="$(echo "2 k 9 5 / ${C} * 32 + p" | dc)"
    echo "${ALL} ($(printf "%3.1f" "${F}")${DEG_SYMBOL}F) (***)"
  else
    vcgencmd read_ring_osc
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnCLOCKFREQ()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CLOCK=""

  fnBANNER "CLOCK FREQUENCIES"
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo "Clocks available across all Pi models..."
  fi
  for CLOCK in arm core h264 isp v3d uart pwm emmc pixel vec hdmi dpi
  do
    echo "${CLOCK}: $(vcgencmd measure_clock "${CLOCK}")" | awk '{ printf("%- 10s %- 28s\n", $1, $2);}' 2>&1
  done
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo
    echo "Additional Model ${MY_MODEL_NAME} clocks..."
    for CLOCK in altscb cam0 cam1 ckl108 clk27 clk54 debug0 debug1 dft dsi0 dsi0esc dsi1 dsi1esc emmc2 genet125 genet250 gisb gpclk0 gpclk1 hevc m2mc otp pcm plla pllb pllc plld pllh pulse smi tectl testmux tsens usb wdog xpt
    do
      echo "${CLOCK}: $(vcgencmd measure_clock "${CLOCK}")" | awk '{ printf("%- 10s %- 28s\n", $1, $2);}' 2>&1
    done
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnVOLTS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local VOLTS=""

  fnBANNER "VOLTAGES"
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo "Voltages available across all Pi models..."
  fi
  for VOLTS in core sdram_c sdram_i sdram_p
  do
    echo "${VOLTS}: $(vcgencmd measure_volts "${VOLTS}")" | awk '{ printf("%- 10s %- 40s\n", $1, $2);}' 2>&1
  done
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo
    echo "Additional Model ${MY_MODEL_NAME} voltages..."
    vcgencmd measure_volts 2711 | sed 's/ /\n/g' | while read -r VOLTS
    do
      echo -e "2711: ${VOLTS}" | awk '{ printf("%- 10s %- 40s\n", $1, $2);}' 2>&1
    done
    for VOLTS in ain1 usb_pd uncached
    do
      echo "${VOLTS}: $(vcgencmd measure_volts "${VOLTS}")" | awk '{ printf("%- 10s %- 40s\n", $1, $2);}' 2>&1
    done
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnTEMPS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local GPU_TEMP=""
  local ARM_TEMP=""
  local PMIC_TEMP=""
  local C=""
  local F=""

  fnBANNER "TEMPERATURE"
  # Pointless venting - I wish bash could do floating point
  # math directly in the shell like ksh can, without needing
  # bc, dc, expr, awk, or other external commands.  Argh!
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo "Temperatures available across all Pi models..."
  fi
  GPU_TEMP=$(vcgencmd measure_temp)
  C=$(echo "${GPU_TEMP}" | cut -f2 -d"=" | cut -f1 -d"'")
  if fnCHECK_COMMAND dc
  then
    # SUPPLEMENTAL CONVERSION to Fahrenheit
    F=$(echo "2 k 9 5 / ${C} * 32 + p" | dc)
    echo " GPU Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C ($(printf "%3.2f" "${F}")${DEG_SYMBOL}F) (***)"
  else
    # Otherwise, show Centigrade/Celcius only
    echo " GPU Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C"
  fi
  ARM_TEMP=$(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null)
  C=$(echo "scale=2;${ARM_TEMP}/1000" | bc)
  if fnCHECK_COMMAND dc
  then
    # SUPPLEMENTAL CONVERSION to Fahrenheit
    F=$(echo "2 k 9 5 / ${C} * 32 + p" | dc)
    echo " ARM Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C ($(printf "%3.2f" "${F}")${DEG_SYMBOL}F) (***)"
  else
    # Otherwise, show Centigrade/Celcius only
    echo " ARM Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C"
  fi

  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo
    echo "Additional Model ${MY_MODEL_NAME} PMIC temperature..."
    PMIC_TEMP=$(vcgencmd measure_temp pmic)
    C=$(echo "${PMIC_TEMP}" | cut -f2 -d"=" | cut -f1 -d"'")
    if fnCHECK_COMMAND dc
    then
      # SUPPLEMENTAL CONVERSION to Fahrenheit
      F=$(echo "2 k 9 5 / ${C} * 32 + p" | dc)
      echo "PMIC Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C ($(printf "%3.2f" "${F}")${DEG_SYMBOL}F) (***)"
    else
      # Otherwise, show Centigrade/Celcius only
      echo "PMIC Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C"
    fi
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnGOV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local GOV=""
  local FORCE=""

  fnBANNER "SCALING GOVERNOR"
  GOV=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null)
  FORCE=$(grep "^force_turbo=" /boot/config.txt 2>/dev/null | cut -f2 -d"=")

  # The possible governor settings are:
  #   performance  - always use max cpu freq
  #   powersave    - always use min cpu freq
  #   ondemand     - change cpu freq depending on cpu load
  #                  (On rasbian, it just switches min and max)
  #   conservative - smoothly change cpu freq depending on cpu load
  #   uesrspace    - allow user space daemon to control cpufreq
  #   schedutil    - wiser about freq. selection than the other governors,
  #                  but not quite there yet
  # All but "performance" are overridden by "force_turbo=1" in config.txt.
  # Both of those mean the same thing - run at max speed, all the time..

  echo "${GOV}"
  if [[ "${GOV}" != "performance" ]] && [[ "${FORCE}" = "1" ]]
  then
    echo "(...but overridden by \"force_turbo=1\" found in config.txt)"
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnTHROTTLES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local UNDERVOLTED=""
  local CAPPED=""
  local THROTTLED=""
  local SOFT_TEMPLIMIT=""
  local HAS_UNDERVOLTED=""
  local HAS_CAPPED=""
  local HAS_THROTTLED=""
  local HAS_SOFT_TEMPLIMIT=""
  local GOOD=""
  local BAD=""
  local STATUS=""

  fnBANNER "DECODED PROCESSOR THROTTLING STATUS"
  # These are what cause the overtemp (thermometer) icon,
  # the undervolt (lightening bolt) icon, etc., to be
  # displayed on a screen, when there's a problem.
  #
  # "vcgencmd get_throttled"
  # Bit Meaning
  # ===============
  #  0 Undervoltage currently detected
  #  1 Arm frequency currently capped
  #  2 Currently throttled
  #  3 Soft temperature limit currently active
  # 16 Under voltage has occured at least once since last boot
  # 17 Arm frequency cap has occured at least once since last boot
  # 18 Throttling has occurred at least once since last boot
  # 19 Soft Temperature limit has occurred at least once since last boot

  #Flag Bits
  UNDERVOLTED=0x1
  CAPPED=0x2
  THROTTLED=0x4
  SOFT_TEMPLIMIT=0x8
  HAS_UNDERVOLTED=0x10000
  HAS_CAPPED=0x20000
  HAS_THROTTLED=0x40000
  HAS_SOFT_TEMPLIMIT=0x80000

  #Output Strings
  GOOD="no"
  BAD="YES"

  #Get Status, extract hex
  STATUS=$(vcgencmd get_throttled)
  STATUS=${STATUS#*=}

  echo -n "Throttle Status: "
  ((STATUS!=0)) && echo "${STATUS}" || echo "${STATUS}"
  echo

  echo "Undervolted:"
  echo -n "    Currently: "
  (((STATUS&UNDERVOLTED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_UNDERVOLTED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
  echo "Throttled:"
  echo -n "    Currently: "
  (((STATUS&THROTTLED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_THROTTLED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
  echo "Frequency Capped:"
  echo -n "    Currently: "
  (((STATUS&CAPPED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_CAPPED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
  echo "Softlimit:"
  echo -n "    Currently: "
  (((STATUS&SOFT_TEMPLIMIT)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_SOFT_TEMPLIMIT)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnULIMIT_CORE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ULIMIT=""
  local HITS=""

  # SUPPLEMENTAL STUFF HERE
  fnBANNER "ULIMIT AND CORE DUMPS (***)"
  ulimit -a
  echo

  ULIMIT=$(ulimit -c)
  case ${ULIMIT} in
    "0")
      echo " Core dumps are disabled..."
      echo "ulimit = 0"
      ;;
    "unlimited")
      echo " Core dumps are enabled..."
      echo "ulimit = unlimited"
      ;;
    *)
      echo " Core dumps are enabled..."
      echo "ulimit = ${ULIMIT}"
      ;;
  esac
  echo

  HITS=$(find /etc/security/limits* -type f -exec grep "core" {} \; | grep -v "^#")
  if [[ -n "${HITS}" ]]
  then
    echo " Core dumps are enabled globally in /etc/security/limits*..."
    echo "${HITS}"
    echo
  fi

  HITS=$(find /etc/systemd/system.conf -type f -exec grep "DefaultLimitCORE" {} \; | grep -v "^#")
  if [[ -n "${HITS}" ]]
  then
    echo " Default global core dump limit in /etc/systemd/system.conf..."
    echo "${HITS}"
    echo
  fi

  if [[ -f /etc/systemd/coredump.conf ]]
  then
    echo " Contents of /etc/systemd/coredump.conf..."
    grep -v "^# " < /etc/systemd/coredump.conf 2>/dev/null | grep -v "^#$" | grep -v "^$" || :
    echo
  fi

  if [[ "$(journalctl -xe | grep "dumped core")" != "" ]]
  then
    echo " journalctl -xe..."
    journalctl -xe | grep "dumped core"
    echo
  fi

  if fnCHECK_COMMAND coredumpctl
  then
    echo " journalctl reports the following core dumps..."
    ${SUDO} coredumpctl list 2>&1 || :
    echo
    echo " Core dumps present in /var/lib/systemd/coredump..."
    ls -l /var/lib/systemd/coredump
    echo
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnQUOTAS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND repquota
  then
    if [[ "$(grep "quota=" /etc/fstab 2>/dev/null | grep -v "^#")" != "" ]]
    then
      fnBANNER "QUOTAS (***)"
      echo " The following filesystems are configured for quotas..."
      grep "quota=" /etc/fstab 2>/dev/null | grep -v "^#" || :
      echo
      ${SUDO} repquota -u -g -v -a -s -t | grep -v "^#" || :
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnOVERLAYFS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MOUNT_STATUS=""

  if [[ "$(grep "boot=overlay" /boot/cmdline.txt)" != "" ]]
  then
    fnBANNER "OVERLAY FILESYSTEM"
    echo "Found \"boot=overlay\" in cmdline.txt"
    echo
    echo "Fhe following initrd.img overlay files are in /boot:"
    find /boot -print | grep "initrd.img"
    echo
    echo "Mounted overlay filesystems:"
    df -Th -t overlay 2>&1
    echo
    echo "Checking fstab for read-only /boot filesystem:"
    grep "/boot" /etc/fstab | grep "ro" | grep -v "^#" || :
    echo
    echo "Current status of /boot filesystem:"
    MOUNT_STATUS="$(mount | grep "/boot" | cut -f2 -d'(' | cut -f1 -d",")"
    case ${MOUNT_STATUS} in
      "rw") echo "/boot is currently read-write"
        ;;
      "ro") echo "/boot is currently read-only"
        ;;
      *)    echo "unknown"
        ;;
    esac
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnCODECS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CODEC=""
  local STATUS=""
  local LIC_STATUS=""

  fnBANNER "HARDWARE-ACCELERATED CODECS"
  # FOR THE PI 4B, 400, and CM4...
  # On theses Pi models, hardware decoding for MPG2 and WVC1
  # is disabled and cannot be enabled even with a license key.
  # These Pis, with their increased processing power compared to
  # earlier models, can decode these in software such as VLC.
  # MPG4, H263, MPG2, and WVC1 hardware decode options have all
  # been dropped, on these Pis.  The ARM cores on the Pi4 are more
  # than capable of decoding those formats at better that real-
  # time.  (There is no real material >1080p using those codecs.)
  #
  # FOR OLDER MODELS...
  # Hardware decoding of MPG2 and WVC1 requires license keys,
  # purchased seperately.
  CODEC=""
  STATUS=""
  for CODEC in AGIF FLAC H263 H264 MJPA MJPB MJPG MPG2 MPG4 MVC0 " PCM" THRA VORB " VP6" " VP8" WMV9 WVC1
  do
    STATUS=$(vcgencmd codec_enabled "${CODEC}" | cut -f2 -d"=")
    # These two codecs...
    if [[ "${CODEC}" = "MPG2" ]] || [[ "${CODEC}" = "WVC1" ]]
    then
      # ...on models other than the 4B...
      # ...OR the installed OS is legacy "Raspbian"...
      if [[ "${PI4_FAMILY}" != "1" ]] && [[ "${RPIOS}" = "0" ]]
      then
        # ...if enabled...
        if [[ "${STATUS}" = "enabled" ]]
        then
          #... are marked as licensed.
          LIC_STATUS="(licensed)"
        else
          # If not enabled on these models, a license is required to enable.
          LIC_STATUS="(license required to enable)"
        fi
        # We then show their status (including whether licensed).
        echo "${CODEC}: ${STATUS} ${LIC_STATUS}"
      else
        # For other codecs, just show their status.
        echo "${CODEC}: ${STATUS}"
      fi
    else
      # Otherwise, show each codec's status, without concern for license.
      echo "${CODEC}: ${STATUS}"
    fi
  done
  echo
  echo "Note 1: VP6, VP8, and MJPG are not handled by the hardware video decoder"
  echo "in the Broadcom BCM2835 processor, but by the VideoCore GPU.  Enable these"
  echo "by running:  sudo raspi-config -> Interfacing Options -> Camera -> Enable"
  echo "or by adding \"start_x=1\" to /boot/config.txt"
  echo
  echo "Note 2: GPU hardware-accelerated codecs will be disabled if \"gpu_mem=16\"."
  echo "At least \"gpu_mem=96\" is required for the codecs to run correctly."
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnV4L2CODECS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "V4L2-CTL CODECS"
  v4l2-ctl -d 10 --list-formats-out
  if [[ "$(v4l2-ctl -d 10 --list-formats-out | grep "Pixel")" = "" ]]
  then
    echo
  fi
  if [[ "${PI4_FAMILY}" = "1" ]]
  then
    echo "Note: The H.265 codec, new w/ the Pi 4B, isn't part of the videocore."
    echo "It's an entirely new block on the chip, so the VC6 knows nothing"
    echo "about it.  Therefore, vcgencmd (which talks to the VC6) also knows"
    echo "nothing about it.  The v4l2-ctl command used here, however, should"
    echo "show the H.265 codec, when enabled, on Pi 4B, 400, and CM4 models."
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnV4LDEV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DEV=""

  # The Pi itself, will have /dev/video10 (decode), /dev/video11 (encode),
  # and /dev/video12 (resize & format conversion) V4L devices.  What we
  # want to look at here is any other V4L device found on the system, such
  # as TV tuners.
  fnBANNER "VIDEO4LINUX DEVICES"
  v4l2-ctl --list-devices 2>/dev/null || :
  for DEV in $(v4l2-ctl --list-devices 2>/dev/null | grep "/dev/")
  do
    fnBANNER "VIDEO4LINUX DEVICE ${DEV}"
    v4l2-ctl -d "${DEV}" --all
    echo
  done
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnCAMERA()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CAMERA (CSI)"
  # Refers to the small cameras that plug into the Pi's CSI connector
  vcgencmd get_camera
  if [[ "$(vcgencmd get_config disable_camera_led | cut -f2 -d"=")" -eq 1 ]]
  then
    echo
    echo "Camera LED is disabled during record."
  fi
  echo
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# RF Wireless Devices blocked/unblocked status
fnRF()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if fnCHECK_COMMAND rfkill
  then
    fnBANNER "WIRELESS DEVICE STATUS (***)"
    rfkill --output-all
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# 1-Wire interface
fn1W()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DRIVER=""

  if [[ -d /sys/bus/w1/devices ]]
  then
    fnBANNER "W1-GPIO (1-WIRE INTERFACE) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep "w1_gpio"
    echo
    echo " Discovered 1-WIRE Drivers..."
    find /sys/bus/w1/drivers -type d | grep -v "^.$" | grep -v "/drivers$" | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
    echo " 1-WIRE Addresses in /sys/bus/w1/devices..."
    ls -1 /sys/bus/w1/devices 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# SPI (Serial Peripheral Interface)
fnSPI()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DRIVER=""

  if [[ "$(lsmod | grep "spi")" != "" ]]
  then
    fnBANNER "SPI (SERIAL PERIPHERAL INTERFACE) DRIVERS"
    if ls -l /dev/spidev* >/dev/null 2>&1
    then
      echo " SPI Devices in /dev..."
      ls -l /dev/spidev*
      echo
    fi

    echo " Loaded Modules..."
    lsmod | grep "spi"
    echo
    echo " Discovered SPI Drivers..."
    find /sys/bus/spi/drivers -type d | grep -v "^.$" | grep -v "/drivers$" | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# I2S (Inter-IC Sound)
fnI2S()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DRIVER=""

  if [[ "$(lsmod | grep "i2s")" != "" ]]
  then
    fnBANNER "I2S (INTER-IC SOUND) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep "i2s"
    echo
    echo " Discovered I2S Drivers..."
    find /sys/bus/platform/drivers/*i2s -maxdepth 0 | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER, fnSUB_BANNER
#
# I2C (Inter-IC Communication)
fnI2C()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DRIVER=""
  local BUS=""
  local NUM=""

  if [[ "$(lsmod | grep "i2c")" != "" ]]
  then
    fnBANNER "I2C (INTER-IC COMMUNICATION) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep "i2c"
    echo
    echo " Discovered I2C Drivers..."
    find /sys/bus/i2c/drivers -type d | grep -E -v "^.$|/drivers$|/dummy$|/stmpe-i2c$" | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
  fi

  # If i2c is enabled, probe for i2c busses
  if [[ "$(grep "^dtparam=i2c_arm=on" /boot/config.txt 2>/dev/null)" != "" ]]
  then
    fnBANNER "I2CDETECT"
    i2cdetect -l 2>&1 | sort
    echo
    i2cdetect -l 2>&1 | sort | awk '{ print $1 }' | cut -f2 -d'-' | while read -r BUS
    do
      echo " I2C BUS: ${BUS}"
      i2cdetect -y "${BUS}" 2>&1 || :
      echo
    done
  fi

  if [[ "$(grep "i2c" /boot/config.txt 2>/dev/null | grep -v "^#")" != "" ]]
  then
    fnSUB_BANNER "I2C-related entries in config.txt"
    grep "i2c" /boot/config.txt 2>/dev/null | grep -v "^#" || :
    echo
  fi

  i2cdetect -l | awk '{ print $1 }' | cut -f2 -d'-' | sort -n | while read -r NUM
  do
    echo "-------------------"
    dtoverlay -h i2c"${NUM}" | grep -v "^$" || :
  done
  echo

  ls -l /dev/i2c*
  echo
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# NVMe (Non-Volatile Memory Express)
fnNVME()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(dmesg | grep "nvme ")" != "" ]]
  then
    fnBANNER "NVME"
    # lspci | grep "Non-Volatile memory controller"
    dmesg | grep -i "nvme " || :
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# PCI (Peripheral Component Interconnect)
fnPCI()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "PCI (***)"
  lspci -k
  echo
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# PCIe (Peripheral Component Interconnect express)
fnPCIE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(dmesg | grep "brcm-pcie " | grep -v "ModemManager")" != "" ]]
  then
    fnBANNER "PCIE"
    dmesg | grep "brcm-pcie "
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# SDHCI (SD Host Controller Interface)
fnSDHCI()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(dmesg | grep -i "sdhci ")" != "" ]]
  then
    fnBANNER "SDHCI (SD HOST CONTROLLER INTERFACE)"
    dmesg | grep -i "sdhci " || :
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# XHCI (Extensible Host Controller Interface)
fnXHCI()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(dmesg | grep -i "xhci ")" != "" ]]
  then
    fnBANNER "XHCI (EXTENSIBLE HOST CONTROLLER INTERFACE)"
    dmesg | grep -i "xhci " || :
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
# eMMC (embedded Multi-Media Controller)
fnEMMC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(dmesg | grep "mmc[01]" | grep -v "ModemManager")" != "" ]]
  then
    fnBANNER "EMMC (EMBEDDED MULTI-MEDIA CONTROLLER)"
    dmesg | grep "mmc[01]" | grep -v "unknown CIS tuple" || :
    echo
    if [[ "$(grep "mmcblk[01]" /var/log/syslog | grep -v "ModemManager")" != "" ]]
    then
      grep "mmcblk[01]" /var/log/syslog | grep -v "ModemManager" || :
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnRTC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # If the user has a realtime clock installed and configured...
  if [[ -c /dev/rtc0 ]] || [[ -L /dev/rtc ]]
  then
    fnBANNER "RTC (REALTIME CLOCK)"
    dmesg | grep "rtc" | grep -v "Modules linked in:" | grep -v "crtc" || :
    echo
    lsmod | grep "rtc"
    echo
    ls -l /dev/rtc*
    echo
    echo "Hardware RTC says:"
    ${SUDO} hwclock
    echo
    echo "Operating System says:"
    date
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnHWRNG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  # If Hardware Random Number Generator is enabled, and daemon is running...
  if [[ -c /dev/hwrng ]] && [[ -n "$(ps -ef | pgrep "rngd")" ]]
  then
    # ...and if the test tool is available...
    if fnCHECK_COMMAND rngtest
    then
      fnBANNER "HARDWARE RANDOM NUMBER GENERATOR (***)"
      ${SUDO} cat /dev/hwrng 2>/dev/null | rngtest -c 1000 2>&1 || :
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnHWWD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DIR=""

  # SUPPLEMENTAL STUFF HERE
  # If the watchdog timer is enabled...
  if [[ "$(systemctl | iconv -f UTF8 -t ASCII//TRANSLIT | grep "watchdog.service")" != "" ]]
  then
    fnBANNER "BROADCOM WATCHDOG TIMER (***)"
    dmesg | grep "watchdog"
    echo
    grep -E -v "^$|^#" < /etc/watchdog.conf 2>/dev/null
    echo
    DIR="$(awk '/^test-directory/ { print $3 }' /etc/watchdog.conf)"
    if [[ -n "${DIR}" ]]
    then
      echo "Contents of ${DIR}:"
      ls -l "${DIR}"
      echo
    fi
    DIR="$(awk '/^log-dir/ { print $3 }' /etc/watchdog.conf)"
    if [[ -n "${DIR}" ]]
    then
      echo "Contents of ${DIR}:"
      ls -l "${DIR}"
      echo
    fi
    systemctl status watchdog.service | iconv -f UTF8 -t ASCII//TRANSLIT | tee /dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnUSB_DEV_INFO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "USB AND OTHER DEVICE INFO"
  lsusb | sort
  echo
  cat "${TEMPFILE}" 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnLSHW_INPUT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n "${LSHW_INPUT}" ]]
  then
    fnBANNER "INPUT DEVICES"
    ${SUDO} lshw -class input 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnLSHW_GENERIC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n "${LSHW_GENERIC}" ]]
  then
    fnBANNER "GENERIC DEVICES"
    ${SUDO} lshw -class generic 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnRTL_SDR()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  # Note: A bug in the Pi 4B's USB (xhci host controllers that don't update
  # endpoint DCS) may affect test results.  The following commands can update
  # your firmware to correct the issue, if needed:
  # sudo apt update
  # sudo apt install rpi-eeprom
  # sudo rpi-eeprom-update -a
  # sudo reboot
  if fnCHECK_COMMAND rtl_eeprom && fnCHECK_COMMAND rtl_test
  then
    if [[ "$(lsmod | grep "rtl2832")" != "" ]]
    then
      fnBANNER "RTL-SDR TUNER (***)"
      rtl_eeprom 2>&1 || :
      echo
      rtl_test -t 2>&1 | grep "^S"
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnLSHW_STORAGE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n "${LSHW_STORAGE}" ]]
  then
    fnBANNER "STORAGE DEVICES"
    ${SUDO} lshw -class storage 2>/dev/null
    echo
    ${SUDO} lshw -short -class disk -class storage -class volume 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
#
fnSMART()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DEV=""
  local MOUNTPOINT=""
  local NOATIME=""

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND smartctl
  then
    fnBANNER "USB ATA/SATA & SCSI/SAS STORAGE WITH SMART TECHNOLOGY (***)"
    if [[ "$(smartctl --scan -d sat | grep -v "aborted")" != "" ]]
    then
      echo "Scanning Devices..."
      smartctl --scan -d sat | grep -v "aborted" || :
      echo
      fnSUB_BANNER "Checking \"noatime\" mount option on ATA/SATA and SCSI/SAS filesystems"
      echo "The \"noatime\" option disables updates to the access timestamp of an inode,"
      echo "whenever a file is accessed (eg: when files are merely read.)  Disabling"
      echo "these updates eliminates a huge number of writes to a device over time,"
      echo "especially on filesystems that host the operating system itself.  This is"
      echo "particularly important for SD & SSD devices, as excessive writes will shorten"
      echo "the lifespan of the device.  Mechanical drives can also benefit, from the"
      echo "ever-so-slight performance gain."
      echo
      echo "This check examines mounted filesystems ONLY."
      echo
      smartctl --scan -d sat | grep -v "aborted" | awk '{ print $1 }' | while read -r DEV
      do
        lsblk --ascii "${DEV}" -o name,mountpoint | grep -v "SWAP" | grep -v "MOUNTPOINT" | grep "/" | awk '{ print $NF }' | sort -u | while read -r MOUNTPOINT
        do
          NOATIME="$(grep -E -v "^#|^$" < /etc/fstab | awk '{ print $2 " " $4 }' | grep "^${MOUNTPOINT} " | grep "noatime")"
          printf "%-16s" "${MOUNTPOINT}"
          if [[ -n "${NOATIME}" ]]
          then
            echo ": noatime is specified for this filesystem, in /etc/fstab"
          else
            echo ": noatime is not specified for this filesystem, in /etc/fstab"
          fi
        done
      done
      echo
      fnSUB_BANNER "Active statements in /etc/smartd.conf:"
      grep -E -v "^#|^$" /etc/smartd.conf || :
      echo
      fnSUB_BANNER "SMARTD.SERVICE"
      systemctl status smartd.service | iconv -f UTF8 -t ASCII//TRANSLIT
      echo
      # smartctl --scan -d sat | grep -v "aborted" | awk '{ print $1 }' | while read -r DEV
      smartctl --scan -d scsi | grep -v "aborted" | awk '{ print $1 }' | while read -r DEV
      do
        fnBANNER "SMART DEVICE: ${DEV}"
        ${SUDO} smartctl -d scsi --info -T permissive -s on "${DEV}" || :
        fnSUB_BANNER "Full Device Details..."
        ${SUDO} smartctl -d scsi --xall -T permissive -s on "${DEV}" || :
        echo
      done
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnQUIRKS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(grep "quirks" /boot/cmdline.txt)" != "" ]]
  then
    fnBANNER "USB STORAGE QUIRKS CHECK"
    echo "USB storage \"quirks\" statement found in cmdline.txt."
    echo "The \"quirks\" directive disables UAS for a given storage device."
    echo "Disabling UAS also disables the trim functions of the device."
    echo "At least one USB storage device may not be capable of \"trim\"."
    echo
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
#
fnTRIM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local FSTRIM_STATUS=""

  if [[ "$(find /etc/udev -type f -exec grep "unmap" {} \; | grep -v "^#")" != "" ]]
  then
    fnBANNER "USB STORAGE WITH TRIM"
    ${SUDO} fstrim --all --dry-run -v 2>/dev/null
    FSTRIM_STATUS=${?}
    case ${FSTRIM_STATUS} in
      0|64)
        echo
        fnSUB_BANNER "UDEV RULES FOR TRIM"
        find /etc/udev -type f -exec grep "unmap" {} \; -print | grep -v "^#" || :
        echo
        fnSUB_BANNER "FSTRIM.TIMER"
        systemctl status fstrim.timer | iconv -f UTF8 -t ASCII//TRANSLIT
        echo
        if [[ "$(grep "discard" /etc/fstab 2>/dev/null)" != "" ]]
        then
          fnSUB_BANNER "DISCARD ENTRIES IN FSTAB"
          grep "discard" /etc/fstab 2>/dev/null
          echo
        fi
        ;;
      *)
        ;;
    esac
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnBLKID()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "DISK CONFIGURATION"
  ${SUDO} blkid | grep -v "zram" | sort
  echo
  lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL,UUID,PARTUUID,MODEL | grep -v "zram" | iconv -f UTF8 -t ASCII//TRANSLIT
  echo
  df -h -T | grep -v "tmpfs" || :
  echo
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
#
fnRAID()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MD=""
  local UUID=""
  local FSTAB=""
  local DEV=""

  # SUPPLEMENTAL STUFF HERE
  if [[ -e /proc/mdstat ]]
  then
    fnBANNER "RAID ARRAY CONFIGURATION (***)"
    grep "^[a-zA-Z]" < /proc/mdstat 2>/dev/null
    echo
    echo "Contents of /etc/mdadm/mdadm.conf..."
    grep -E -v "^$|^#" < /etc/mdadm/mdadm.conf 2>/dev/null
    echo
    grep "^md" < /proc/mdstat 2>/dev/null | awk '{ print $1 }' | while read -r MD
    do
      fnSUB_BANNER "RAID ARRAY DEVICE /dev/${MD} (***)" | tr '[:lower:]' '[:upper:]'
      ${SUDO} mdadm --query /dev/"${MD}" 2>/dev/null | sed 's/ Use mdadm --detail for more detail.//'
      echo
      UUID=$(blkid | grep "/dev/${MD}:" | awk '{ print $2 }' | cut -f2 -d"\"")
      FSTAB=$(grep "${UUID}" /etc/fstab 2>/dev/null || :)
      if [[ -n "${FSTAB}" ]]
      then
        echo "/etc/fstab entry..."
        echo "${FSTAB}"
        echo
        df -h "$(grep "${UUID}" /etc/fstab 2>/dev/null | awk '{ print $2 }')"
        echo
      fi
      ${SUDO} mdadm --detail /dev/"${MD}"
      echo
      ${SUDO} mdadm --detail /dev/"${MD}" | awk '{ print $NF }' | grep "/dev/" | grep -v "/dev/${MD}:" | while read -r DEV
      do
        fnSUB_BANNER "RAID ARRAY DEVICE /dev/${MD} - COMPONENT ${DEV} (***)" | tr '[:lower:]' '[:upper:]'
        ${SUDO} mdadm --query "${DEV}" 2>/dev/null | grep -v "is not an md array" | sed 's/  Use mdadm --examine for more detail.//'
        echo
        ${SUDO} mdadm --examine "${DEV}"
        echo
      done
    done
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
#
fnLVM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND vgdisplay
  then
    if [[ -n "$(${SUDO} vgdisplay 2>/dev/null)" ]]
    then
      fnBANNER "LOGICAL VOLUME MANAGER CONFIGURATION (***)"
      echo "LOGICAL VOLUMES..."
      ${SUDO} lvs 2>&1
      echo
      ${SUDO} lvdisplay 2>&1

      fnSUB_BANNER "VOLUME GROUPS..."
      ${SUDO} vgs 2>&1
      echo
      ${SUDO} vgdisplay 2>&1

      fnSUB_BANNER "PHYSICAL VOLUMES..."
      ${SUDO} pvs 2>&1
      echo
      ${SUDO} pvdisplay 2>&1
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnHDPARM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DEV=""

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND hdparm
  then
    stat /dev/sd? | grep "File:" | awk '{ print $NF }' | while read -r DEV
    do
      fnBANNER "HDPARM ATA/SATA DEVICE PARAMETERS - ${DEV} (***)" | grep -v "^$" || :
      ${SUDO} hdparm -I --verbose "${DEV}" 2>/dev/null
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
#
fnFSTAB()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -f /etc/fstab ]]
  then
    fnBANNER "FSTAB FILE"
    grep -E -v "^$|^#" < /etc/fstab 2>/dev/null
    echo
  else
    # In truth, I can't envision a booted/running system without this file.
    echo "Missing file /etc/fstab" >&2
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnLSHW_MM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n "${LSHW_MULTIMEDIA}" ]]
  then
    fnBANNER "MULTIMEDIA DEVICES"
    ${SUDO} lshw -class multimedia 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnALSA_MOD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -e /proc/asound/modules ]]
  then
    fnBANNER "ALSA MODULES"
    cat /proc/asound/modules 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnALSA_HW()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -e /proc/asound/cards ]]
  then
    fnBANNER "ALSA SOUND HARDWARE"
    cat /proc/asound/cards 2> /dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnALSA_CARD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -e /proc/asound/cards ]]
  then
    grep "^ [0123]" < /proc/asound/cards 2>/dev/null | awk '{ print $1 }' | while read -r CARD_NUM
    do
      fnBANNER "ALSA CARD-${CARD_NUM} INFO"
      amixer -c "${CARD_NUM}" 2>/dev/null
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnALSA_PB_CAP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ALSA PLAYBACK AND CAPTURE DEVICES"
  if [[ "$(aplay -l 2>/dev/null | grep "^card")" != "" ]]
  then
    aplay -l 2>/dev/null
  else
    aplay -l 2>/dev/null | grep "PLAYBACK"
    echo "No playback device found"
  fi
  echo
  if [[ "$(arecord -l 2>/dev/null | grep "^card")" != "" ]]
  then
    arecord -l 2>/dev/null
  else
    arecord -l 2>/dev/null | grep "CAPTURE"
    echo "No capture device found"
  fi
  echo
}

#---------------
# Called by fnGROUP_SERIAL_BT
# Calls fnBANNER
#
fnACM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -c /dev/ttyACM0 ]] || [[ -c /dev/ttyACM1 ]]
  then
    if [[ -n "${LSHW_COMMUNICATION}" ]]
    then
      fnBANNER "ACM COMMUNICATION DEVICES"
      ${SUDO} lshw -class communication 2>/dev/null
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_SERIAL_BT
# Calls fnBANNER, fnSUB_BANNER
#
fnSERIAL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local SERIAL_DEV=""
  local NUM=""
  local UART_TYPE=""
  local DEVICE=""

  fnBANNER "UARTS AND USB SERIAL PORTS"
  # By default, on Raspberry Pis equipped with wireless/Bluetooth module,
  # (Raspberry Pi 3 and Raspberry Pi Zero W), the PL011 UART is connected
  # to the Bluetooth module, while the mini UART is used as the primary
  # UART and will have a Linux console on it.  On all other models, the
  # PL011 is used as the primary UART.
  #
  # In Linux device terms, by default, /dev/ttyS0 refers to the mini UART,
  # and /dev/ttyAMA0 refers to the PL011.  The primary UART is the one
  # assigned to the Linux Console, which depends on the Raspberry Pi model
  # as described above.  There are also symlinks: /dev/serial0, which
  # always refers to the primary UART (if enabled), and /dev/serial1,
  # which similarly always refers to the secondary UART (if enabled.)
  #
  # The Pi 4B allows up to 4 additional hardware UARTS (2 thru 5) to be defined.
  # uart2 uses pins that could conflict with the camera and any kind of "hat"
  # with eeprom.  Also If you enable the handshake, I2C1 has to be disabled.
  # Uart3 use GPIO4 then you should consider to change 1 wire GPIO pin if you
  # need 1 wire.  It also uses GPIO7 if you enable handshake then you need to
  # disable SPI.  Uart4 uses the SPI GPIOs.  SPI needs to be disabled.
  # No conflict with uart5. This is the safest one to use.

  # IN OTHER WORDS:
  # On all Pis, UART0 is a PL011 that appears to Linux as ttyAMA<n>,
  # and UART1 is an 8250 clone that appears as ttyS0.  On a Pi4,
  # UART2-5 are additional PL011s that also appear as ttyAMA<n>.
  # The number starts at 0 for the first enabled PL011 and counts
  # up through all the enabled interfaces.  The numbering is stable
  # for any given combination of UARTs, but enabling or disabling
  # one can change the number assignments of others.
  #
  # Adding "enable_uart=1" to config.txt on a Pi4 enables ttyS0 (UART1)
  # on GPIOs 14 & 15 (Alt5), leaving UART0 driving the Bluetooth
  # interface on 30-33 (Alt3).  Adding "dtoverlay=disable-bt" switches
  # the UART roles so that UART0 is mapped to 14 & 15 (Alt0), leaving
  # UART1 unmapped.

  # Re-worked this a bit due to "shopt -s failglob" causing errors on
  # systems that lacked any ttyACM? device nodes.
  ls -l /dev/tty[AS]* /dev/serial? 2>/dev/null
  echo

  fnSUB_BANNER "On-board (non-USB) serial ports"
  dmesg | grep "MMIO" | awk '{ print $4 }' | while read -r MMIO
  do
    SERIAL_DEV="$(dmesg | grep "${MMIO}" | cut -f2 -d':' | cut -f2 -d')' | sed 's/is a//')"
    printf '%8s: %s\n' "${MMIO}" "${SERIAL_DEV}"
  done
  echo

  if [[ "$(grep "uart" /boot/config.txt 2>/dev/null | grep -v "^#")" != "" ]]
  then
    fnSUB_BANNER "UART-related entries in config.txt"
    grep "uart" /boot/config.txt 2>/dev/null | grep -v "^#" || :
    echo
  fi

  grep "^dtoverlay=uart" /boot/config.txt 2>/dev/null | cut -f2 -d'=' | cut -f1 -d',' | cut -c 5 | while read -r NUM
  do
    fnSUB_BANNER "${MY_MODEL_NAME} UART #${NUM}"
    dtoverlay -h uart"${NUM}" | grep -v "^$" || :
    echo
    raspi-gpio get 0-15 | grep -v "PUT" | awk '{ print $1" "$2" "$6 }' | grep "${NUM}$"
    echo
  done

  for NUM in {0..7}
  do
    if [[ -c /dev/ttyACM${NUM} ]]
    then
      UART_TYPE=$(dmesg | grep "ttyACM${NUM}" | cut -f4 -d':' | cut -c2-)
      DEVICE=": $(systemctl list-units --all | iconv -f UTF8 -t ASCII//TRANSLIT | grep "dev-ttyACM${NUM}.device" | sed 's/plugged/plugged:/' | cut -f2- -d':' | sed 's/   //')"
      fnSUB_BANNER "/dev/ACM${NUM}... ${UART_TYPE}${DEVICE}"
      stty -a -F /dev/ttyACM"${NUM}"
      echo
    fi
  done
  for NUM in {0..7}
  do
    if [[ -c /dev/ttyAMA${NUM} ]]
    then
      fnSUB_BANNER "/dev/ttyAMA${NUM}..."
      stty -a -F /dev/ttyAMA"${NUM}"
      echo
    fi
  done
  for NUM in {0..7}
  do
    if [[ -c /dev/ttyS${NUM} ]]
    then
      fnSUB_BANNER "/dev/ttyS${NUM}..."
      stty -a -F /dev/ttyS"${NUM}"
      echo
    fi
  done
}

#---------------
# Called by fnGROUP_SERIAL_BT
# Calls fnBANNER
#
fnBT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PS_BT=""
  local BTMAC_OUT=""
  local BTDEFAULT=""
  local BTMAC=""
  local BTSHOW_OUT=""
  local BTPAIRED_OUT=""

  # Make sure bluetoothd is running, because if not,
  # the bluetoothctl commands used here will hang.
  PS_BT=$(pgrep "bluetoothd")
  if [[ -n "${PS_BT}" ]]
  then
    #---------------
    fnBANNER "BLUETOOTH CONTROLLERS"
    hciconfig
    BTMAC_OUT="$(echo list | ${SUDO} bluetoothctl 2>/dev/null)"
    BTDEFAULT=$(echo "${BTMAC_OUT}" | grep "^Controller" | grep "default" | awk '{ print $2 }')
    BTMAC=""
    echo "${BTMAC_OUT}" | grep "^Controller" | awk '{ print $2 }' | while read -r BTMAC
    do
      if [[ "${BTDEFAULT}" = "${BTMAC}" ]]
      then
        echo "Default BT Controller..."
      else
        echo "Additional (Non-default) BT Controller..."
      fi
      BTSHOW_OUT="$(echo show "${BTMAC}" | ${SUDO} bluetoothctl 2>/dev/null)"
      echo "${BTSHOW_OUT}" | grep -v -F "[" | grep -v "^$" | grep -v "Agent registered" | grep -v "Device registered not available"
      echo
    done
    #---------------
    fnBANNER "BLUETOOTH DEVICES (paired w/ default controller)"
    BTPAIRED_OUT="$(echo paired-devices | ${SUDO} bluetoothctl 2>/dev/null | grep -v "paired-devices")"
    if [[ -n "${BTPAIRED_OUT}" ]]
    then
      echo "${BTPAIRED_OUT}" | grep -v -F "[" | awk '{ print $2 }' | while read -r BTMAC
      do
        echo "info ${BTMAC}" \
          | ${SUDO} bluetoothctl 2>/dev/null \
          | grep -v -F "[" \
          | grep -v "^$" \
          | grep -v "Agent registered" \
          | grep -v "Device registered not available" \
          || :
        echo
      done
    else
      echo "None detected."
      echo
    fi
  else
    #---------------
    fnBANNER "bluetoothd daemon not running"
    echo
  fi
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
#
fnMEMSWAP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "MEMORY AND SWAP"
  free -h
  echo
  swapon --summary
  echo
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
#
fnMEMINFO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local NAME=""
  local BYTES=""
  local SUFFIX=""

  if [[ -e /proc/meminfo ]]
  then
    fnBANNER "MEMINFO"
    while read -r NAME BYTES SUFFIX
    do
      printf '%-16s %10d %s\n' "${NAME}" "${BYTES}" "${SUFFIX}"
    done < /proc/meminfo
    echo
  fi
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
#
fnIPC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "IPC STATUS"
  lsipc
  echo
  ipcs -u
  ipcs -m
  ipcs -q
  ipcs -s
  ipcs -l
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
#
fnDMESG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "DMESG - WARNINGS"
  dmesg | grep -i "warn"
  echo
  fnBANNER "DMESG - FAILURES"
  dmesg | grep -i "fail"
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSTEMD_CHAIN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMD-ANALYZE CRITICAL-CHAIN"
  systemctl list-jobs | iconv -f UTF8 -t ASCII//TRANSLIT
  echo
  systemd-analyze time | iconv -f UTF8 -t ASCII//TRANSLIT
  echo
  systemd-analyze critical-chain | iconv -f UTF8 -t ASCII//TRANSLIT
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSTEMD_BLAME()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMD-ANALYZE BLAME"
  # the tee eliminates the pause every screenfull
  systemd-analyze blame | iconv -f UTF8 -t ASCII//TRANSLIT | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSTEMD_SECURITY()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMD-ANALYZE SECURITY"
  # the tee eliminates the pause every screenfull
  # and gets rid of the color
  systemd-analyze security | iconv -f UTF8 -t ASCII//TRANSLIT | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSCTL_STATUS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMCTL STATUS"
  # the tee eliminates the pause every screenfull
  systemctl status | iconv -f UTF8 -t ASCII//TRANSLIT | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSCTL_FAIL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMCTL UNIT FAILURES"
  systemctl list-units --failed --all | iconv -f UTF8 -t ASCII//TRANSLIT | grep -v "list-unit-files" || :
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnSYSCTL_LIST()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEMCTL LIST-UNIT-FILES"
  # the tee eliminates the pause every screenfull
  systemctl list-unit-files | iconv -f UTF8 -t ASCII//TRANSLIT | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
#
fnJOURNAL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -d /var/log/journal ]]
  then
    if [[ "$(stat /var/log/journal | grep "Access" | grep "2755" | grep "root" | grep "systemd")" != "" ]]
    then
      fnBANNER "PERSISTENT JOURNALING"
      echo "Persistent Journaling is configured"
      ls -ld /var/log/journal
      echo
      ${SUDO} journalctl --sync
      ${SUDO} journalctl --flush
      ${SUDO} journalctl -b | grep "System journal"  | tail -1 | cut -f4- -d":"
      ${SUDO} journalctl -b | grep "Runtime journal" | tail -1 | cut -f4- -d":" | sed 's/^ //'
      echo
      echo "Journaled boots..."
      journalctl --list-boots
      echo
      journalctl --disk-usage
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
#
fnRSYSLOG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PERL_SCRIPT=""

  # SUPPLEMENTAL STUFF HERE
  # Logic in this module is shamelessly based on syslogconf,
  # by Michael Hill, Lockheed Martin Astronotics, Denver, CO
  # Perl is used here because bash sucks at nesting associative arrays.
  if fnCHECK_COMMAND perl && fnCHECK_COMMAND m4
  then
    fnBANNER "RSYSLOG.CONF ANALYSIS (***)"
    echo "This module creates a comprehensive listing of rsyslog.conf event logging."
    echo "The selector selects all messages of equal or higher severity.  For example,"
    echo "news.err really means news.err, news.crit, news.alert, news.emerg.  And"
    echo "mail,uucp.alert means mail.alert, mail.emerg, uucp.alert, and uucp.emerg."
    echo
    echo "Some versions of syslog allow an = character before the level specifier"
    echo "(as in news.=err) to act only on messages of that level."
    echo
    echo "The output below interprets the directives to show where things are going."
    echo

    PERL_SCRIPT=$(cat <<'EOF'
select (STDERR); $| = 1;        # Turn off buffered I/O
select (STDOUT); $| = 1;
($progname = $0) =~ s/.*\///;
chop ($uname = `uname -nsr`);
@uname = split (' ', $uname);

sub fatal {
  local ($errMesg, $errCode) = (@_);

  printf (STDERR "$progname:  %s\n", $errMesg);
  exit ($errCode);
}

$rsyslogconf = '/etc/rsyslog.conf';
$loghost = '';
@facilities = ('kern', 'user', 'mail', 'daemon',
  'auth', 'lpr', 'news', 'uucp', 'cron', 'local0',
  'local1', 'local2', 'local3', 'local4', 'local5',
  'local6', 'local7', 'mark');
@levels = ('emerg', 'alert', 'crit', 'err', 'warning',
  'notice', 'info', 'debug');

for $facil (@facilities) {
  for $lev (@levels) {
    $event_type{"$facil.$lev"} = 'no action';
  }
}
for $i ($[ .. $#levels) {
  $severity{$levels[$i]} = $i;
}

($name) = gethostbyname ('loghost');
if ($name eq $hostname) {
  # we're running on 'loghost'
  $loghost = '-DLOGHOST';
}

open (SYSLOGCONF, "m4 $loghost $rsyslogconf |") ||
  &fatal ("can't open 'm4 $rsyslogconf'", 2);

while (<SYSLOGCONF>) {
  local (%eventlist);

  next if (/^\s*$/ || /^\s*#/);
  chop;

  %eventlist = ( );
  ($events, $action) = split (/\t+/);
  next if ($action eq '');

  # parse for multiple events
  @events = split (';', $events);
  for $event (@events) {
    local ($thislev, $evt);

    ($facils, $level) = split ('\.', $event);
    $thislev = $severity{$level};

    # parse for multiple facility specifications
    if ($facils eq '*') {
      @facils = grep (! /mark/, @facilities);
    } else {
      @facils = split (',', $facils);
    }
    if ($level eq 'none') {
      @levs = @levels;
    } else {
      @levs = grep ($severity{$_} <= $thislev, @levels);
    }
    for $facil (@facils) {
      for $lev (@levs) {
        if ($level eq 'none') {         # delete entry
          delete ($eventlist{"$facil.$lev"})
            if ($eventlist{"$facil.$lev"});
        } else {                        # add entry
          $eventlist{"$facil.$lev"} = 1;
        }
      }
    }
  }
  for $evt (keys (%eventlist)) {
    if ($event_type{$evt} eq 'no action') {
      $event_type{$evt} = $action;
    } else {
      $event_type{$evt} .= ", $action";
    }
  }
}

close (SYSLOGCONF);

for $key (sort (keys (%event_type))) {
  printf ("Event:  %-16s\tAction:  %s\n", $key,
    $event_type{$key});
}

exit (0);
EOF
    )
    perl -e "${PERL_SCRIPT}"
    echo
  fi
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
#
fnLOGROTATE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "LOGROTATE"
  echo " Contents of /etc/logrotate.conf:"
  grep -v "^$" /etc/logrotate.conf || :
  echo
  echo " ----------------------------------------------------"
  echo " logrotate config files in /etc/logrotate.d ..."
  ls /etc/logrotate.d
  echo
  if [[ "$(systemctl | grep "logrotate.timer")" != "" ]]
  then
    echo " ----------------------------------------------------"
    systemctl status logrotate.timer | iconv -f UTF8 -t ASCII//TRANSLIT
    echo
  fi
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
#
fnRCLOCAL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -f /etc/rc.local ]]
  then
    fnBANNER "CONTENTS OF RC.LOCAL"
    grep -E -v "^$|^#" < /etc/rc.local 2>/dev/null
    echo
  else
    echo "Missing file /etc/rc.local" >&2
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnLOCALE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -f /etc/default/locale ]] && [[ -f /etc/default/keyboard ]] && [[ -f /etc/default/console-setup ]] && [[ -f /etc/timezone ]]
  then
    fnBANNER "LOCALIZATION SETTINGS"
    . /etc/default/locale
    . /etc/default/keyboard
    . /etc/default/console-setup
    echo "Language : ${LANG}"
    echo "KB Model : ${XKBMODEL}"
    echo "KB Layout: ${XKBLAYOUT}"
    echo "Char. Map: ${CHARMAP}"
    echo "Timezone : $(cat /etc/timezone 2>/dev/null)"
    echo
  else
    echo "Unable to determine locale settings on this Pi.  Skipping."
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER, fnSUB_BANNER
#
fnLIRC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local LIRC=""
  local SERVICE=""

  # SUPPLEMENTAL STUFF HERE
  if [[ -c /dev/lirc0 ]]
  then
    fnBANNER "LIRC - LINUX INFRA-RED COMMUNICATION DEVICES (***)"
    lsmod | grep "ir_" | sort
    echo

    fnSUB_BANNER "LIRC-related entries in config.txt"
    grep "gpio-ir" /boot/config.txt 2>/dev/null | grep -v "^#" || :
    echo

    fnSUB_BANNER "LIRC config files"
    find /etc/lirc* -print | grep "conf$" || :
    echo

    fnSUB_BANNER "LIRC device nodes"
    find /dev/lirc* -print | while read -r LIRC
    do
      ls -l "${LIRC}"
    done
    echo

    fnSUB_BANNER "LIRC device tree overlays"
    if [[ -c /dev/lirc0 ]]
    then
      dtoverlay -h gpio-ir 2> /dev/null | grep -v "^$" || :
      echo
    fi
    if [[ -c /dev/lirc1 ]]
    then
      dtoverlay -h gpio-ir-tx 2> /dev/null | grep -v "^$" || :
      echo
    fi

    fnSUB_BANNER "LIRC dmesg log entries"
    dmesg | grep "lirc" | cut -f2- -d"]"
    echo

    fnSUB_BANNER "LIRC service status entries"
    for SERVICE in $(systemctl | iconv -f UTF8 -t ASCII//TRANSLIT | grep "lirc" | awk '{ print $1 }')
    do
      systemctl status "${SERVICE}" | iconv -f UTF8 -t ASCII//TRANSLIT
      echo
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
#
fnPRINTER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CUPS_RUNNING=""

  # SUPPLEMENTAL STUFF HERE
  # Not everyone has "cups" installed, so "lpstat" (part of the cups-client
  # package) is not a required dependency for this script.  If they have it,
  # great.  If not, it's no big deal.
  if fnCHECK_COMMAND lpstat
  then
    CUPS_RUNNING="$(lpstat -r 2>/dev/null)"
    if [[ "${CUPS_RUNNING}" = "scheduler is running" ]]
    then
      fnBANNER "PRINTER STATUS {***)"
      lpstat -t
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnTOUCH()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "OFFICIAL 7\" TOUCHSCREEN"

  if dmesg | grep -q "raspberrypi-ts" || dmesg | grep -q -i "ft5406"
  then
    echo "detected"
  else
    echo "not detected"
  fi
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER, fnSUB_BANNER
#
fnDISPLAY()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DISP_NUM=""
  local TVSTATUS=""
  local TV_OFF=""
  local DEV_ID=""
  local DEV_AUDIO=""
  local TVGROUP=""

  fnBANNER "DISPLAY POWER UP STATUS"
  echo "DISPLAY         ID  STATUS"
  echo "--------------------------"
  echo -e -n "Main LCD        0"
  case $(vcgencmd display_power -1 0 | cut -f2 -d"=") in
    "0") echo "   off"
      ;;
    "1") echo "   ON"
      ;;
    *) echo "   undetected"
      ;;
  esac
  echo -e -n "Secondary LCD   1"
  case $(vcgencmd display_power -1 1 | cut -f2 -d"=") in
    "0") echo "   off"
      ;;
    "1") echo "   ON"
      ;;
    *) echo "   undetected"
      ;;
  esac
  echo -e -n "HDMI 0          2"
  case $(vcgencmd display_power -1 2 | cut -f2 -d"=") in
    "0") echo "   off"
      ;;
    "1") echo "   ON"
      ;;
    *) echo "   undetected"
      ;;
  esac
  echo -e -n "Composite       3"
  case $(vcgencmd display_power -1 3 | cut -f2 -d"=") in
    "0") echo "   off"
      ;;
    "1") echo "   ON"
      ;;
    *) echo "   undetected"
      ;;
  esac
  echo -e -n "HDMI 1          7"
  case $(vcgencmd display_power -1 7 | cut -f2 -d"=") in
    "0") echo "   off"
      ;;
    "1") echo "   ON"
      ;;
    *) echo "   undetected"
      ;;
  esac
  echo

  # Unfortunately, tvservice is useless with vc4-kms-v3d(-pi4),
  # but ok with broadcom and "fake" gl driver.
  if [[ "${DISP_DRIVER}" = "broadcom" ]] || [[ "${DISP_DRIVER}" = "fake" ]]
  then
    fnBANNER "HDMI & LCD DISPLAY DATA"
    vcgencmd dispmanx_list 2>&1
    echo
    tvservice -l 2>/dev/null
    echo
    tvservice -l 2>/dev/null | grep "Display Number" | awk '{ print $3 }' | cut -f1 -d"," | while read -r DISP_NUM
    do
      TVSTATUS="$(tvservice -s -v "${DISP_NUM}" 2>/dev/null | strings)"
      TV_OFF="$(echo "${TVSTATUS}" | awk '{ print $2 }')"
      if [[ "${TV_OFF}" = "0x120000" ]]
      then
        echo "Display ${DISP_NUM} is not HDMI... Skipping."
        echo
        continue
      else
        if [[ "${TV_OFF}" = "0x2" ]]
        then
          echo "Display ${DISP_NUM} TV is Off... Skipping."
          echo
          continue
        fi
      fi
      fnSUB_BANNER "DISPLAY NUMBER : ${DISP_NUM}"
      echo "DISPLAY STATUS : ${TVSTATUS}"

      DEV_ID="$(tvservice -n -v "${DISP_NUM}" 2>/dev/null | strings )"
      if [[ "${DEV_ID}" = "" ]]
      then
        DEV_ID="No Device Present"
      fi
      echo "EDID DEVICE ID : ${DEV_ID}"

      DEV_AUDIO="$(tvservice -a -v "${DISP_NUM}" 2>/dev/null | strings | sed 's/^     //')"
      if [[ "${DEV_AUDIO}" = "" ]]
      then
        DEV_AUDIO="No Device Present"
      fi
      echo "SUPPORTED AUDIO: ${DEV_AUDIO}"
      echo

      # Group is usually either DMT (monitors - group 2) or CEA (TV sets -
      # group 1).  This forces "custom" modes to be listed (I hope) as DMT,
      # mode 87
      TVGROUP="$(echo "${TVSTATUS}" | awk '{ print $4 }')"
      if [[ "${TVGROUP}" != "DMT" ]] && [[ "${TVGROUP}" != "CEA" ]]
      then
        TVGROUP=DMT
      fi
      tvservice --modes="${TVGROUP}" -v "${DISP_NUM}" 2>/dev/null
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnROWS_COLS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ROWS=""
  local COLS=""

  fnBANNER "CURRENT ROWS & COLUMNS"
  echo "Term type is: ${TERM}"
  echo
  if [[ "${TERM}" = "" ]] || [[ "${TERM}" = "dumb" ]]
  then
    echo "Environment variable TERM not defined."
    echo "Unable to determine rows and columns."
  else
    ROWS=$(tput lines 2>/dev/null)
    COLS=$(tput cols 2>/dev/null)
    echo "Screen is ${ROWS} rows X ${COLS} columns"
    echo
    echo "Term type characteristics from infocomp"
    echo "---------------------------------------"
    infocmp -I "${TERM}"
    echo
    echo "Term type characteristics from termcap"
    echo "---------------------------------------"
    infocmp -C "${TERM}"
  fi
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnRESOLUTION()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # 'vcgencmd get_lcd_info' is useless with vc4-kms-v3d(-pi4), but
  # ok with broadcom and "fake" gl driver.
  if [[ "${DISP_DRIVER}" = "broadcom" ]] || [[ "${DISP_DRIVER}" = "fake" ]]
  then
    fnBANNER "CURRENT SCREEN RESOLUTION"
    echo "HORIZONTAL : $(vcgencmd get_lcd_info | awk '{ print $1 }') pixels"
    echo "VERTICAL   : $(vcgencmd get_lcd_info | awk '{ print $2 }') pixels"
    echo "COLOR DEPTH: $(vcgencmd get_lcd_info | awk '{ print $3 }') bits"
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnSCREEN_SESSIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if fnCHECK_COMMAND screen
  then
    fnBANNER "\"SCREEN\" SESSIONS (***)"
    screen -v 2>&1 | sed "s/\r//"
    echo
    if [[ -e "${HOME}/.screenrc" ]]
    then
      echo "CONTENTS OF ${HOME}/.screenrc"
      cat "${HOME}/.screenrc"
      echo
    fi
    screen -list 2>&1 | sed "s/\r//"
    if screen -list >/dev/null 2>&1
    then
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnTMUX()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if fnCHECK_COMMAND tmux
  then
    fnBANNER "\"TMUX\" SESSIONS (***)"
    tmux -V 2>&1
    echo

    if tmux list-clients >/dev/null 2>&1
    then
      echo "CLIENTS..."
      tmux list-clients
      #/dev/pts/0: 0 [168x44 xterm] (utf8)
      echo

      echo "SESSIONS..."
      tmux list-sessions
      #0: 1 windows (created Wed Dec 23 20:18:40 2020) [168x43] (attached)
      echo

      echo "PANES..."
      tmux list-panes
      #0: [84x43] [history 0/2000, 0 bytes] %0
      #1: [83x43] [history 0/2000, 0 bytes] %1 (active)
      echo

      echo "WINDOWS..."
      tmux list-windows
      #0: bash* (2 panes) [168x43] [layout 5d9f,168x43,0,0{84x43,0,0,0,83x43,85,0,1}] @0 (active)
      echo
    else
      tmux list-clients 2>&1 || :
      echo
    fi

    # Default tmux configuration file.
    echo " Contents of ${HOME}/.tmux.conf ..."
    if [[ -e "${HOME}/.tmux.conf" ]]
    then
      cat "${HOME}/.tmux.conf"
    else
      echo "file not found"
    fi
    echo

    # System-wide configuration file.
    echo " Contents of /etc/tmux.conf ..."
    if [[ -e "/etc/tmux.conf" ]]
    then
      cat /etc/tmux.conf
    else
      echo "file not found"
    fi
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
#
fnXWINDOWS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MY_DISPLAY="${DISPLAY:-}"

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND xrandr
  then
    if [[ -n "${MY_DISPLAY}" ]]
    then
      fnBANNER "X-WINDOWS (***)"
      Xorg -version 2>&1 | grep "^X"
      echo
      echo "\$DISPLAY=${MY_DISPLAY}"
      echo
      echo "x-session-manager ........ $(update-alternatives --display x-session-manager | grep "currently" | awk '{ print $NF }')"
      echo "x-window-manager ......... $(update-alternatives --display x-window-manager | grep "currently" | awk '{ print $NF }')"
      echo "default-display-manager .. $(cat /etc/X11/default-display-manager)"
      echo
      # xrandr is part of package "x11-xserver-utils"
      xrandr --verbose 2>&1 | grep -v "xrandr: Failed to get size of gamma for output default" || :
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
fnWIRINGPI()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  # Do not run on Pi 4B 8GB, 400, or CM4 models.
  # All other Pi 4Bs (1/2/4GB) require WiringPi version 2.52.
  # The 4B 8GB, 400 and CM4 models appeared after deprication of WiringrPpi.
  # All older Pi models can run the versions in the repositories.
  if fnCHECK_COMMAND gpio
  then
    # If it's a v1.4 4B, or a 400, or a CM4, then get out.
    if [[ "${MY_REVISION}" = "[bcd]03114" ]] || [[ "${MY_MODEL_NAME}" = "400" ]] || [[ "${MY_MODEL_NAME}" = "CM4" ]]
    then
      return 0
    fi

    # If it's a 4B 1-4GB, but WiringPi is not 2.5, then get out.
    if [[ "${MY_MODEL_NAME}" = "4B" ]] && [[ "${WIRINGPI_VERS}" != "2.52" ]]
    then
      return 0
    fi

    fnBANNER "GPIO PIN STATUS via WIRINGPI (***)"
    gpio readall
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
#
fnPIGPIOD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PY3_SCRIPT=""

  # SUPPLEMENTAL STUFF HERE
  # See: http://www.raspberrypi.org/forums/viewtopic.php?t=254071
  # for post entitled "GPIO Readall Code", by user "Milliways"
  # requires python3-pigpio be installed.
  # requires "/usr/bin/pigpiod" be running (systemctl enable pigpiod.service)
  # Unfortunately, some older 26-pin Model A and B Pis may be out of luck.
  if [[ -n "$(pgrep "pigpiod")" ]]
  then
    fnBANNER "GPIO PIN STATUS via PIGPIOD (***)"
    PY3_SCRIPT=$(cat <<'EOF'
"""
Read all GPIO
"""
import sys, os, time
import pigpio

MODES = ["IN", "OUT", "ALT5", "ALT4", "ALT0", "ALT1", "ALT2", "ALT3"]
HEADER = ('3.3v', '5v', 2, '5v', 3, 'GND', 4, 14, 'GND', 15, 17, 18, 27, 'GND', 22, 23, '3.3v', 24, 10, 'GND', 9, 25, 11, 8, 'GND', 7, 0, 1, 5, 'GND', 6, 12, 13, 'GND', 19, 16, 26, 20, 'GND', 21)
GPIOPINS = 40

FUNCTION = {
'Pull': ('High', 'High', 'High', 'High', 'High', 'High', 'High', 'High', 'High', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low'),
'ALT0': ('SDA0', 'SCL0', 'SDA1', 'SCL1', 'GPCLK0', 'GPCLK1', 'GPCLK2', 'SPI0_CE1_N', 'SPI0_CE0_N', 'SPI0_MISO', 'SPI0_MOSI', 'SPI0_SCLK', 'PWM0', 'PWM1', 'TXD0', 'RXD0', 'FL0', 'FL1', 'PCM_CLK', 'PCM_FS', 'PCM_DIN', 'PCM_DOUT', 'SD0_CLK', 'SD0_XMD', 'SD0_DATO', 'SD0_DAT1', 'SD0_DAT2', 'SD0_DAT3'),
'ALT1': ('SA5', 'SA4', 'SA3', 'SA2', 'SA1', 'SAO', 'SOE_N', 'SWE_N', 'SDO', 'SD1', 'SD2', 'SD3', 'SD4', 'SD5', 'SD6', 'SD7', 'SD8', 'SD9', 'SD10', 'SD11', 'SD12', 'SD13', 'SD14', 'SD15', 'SD16', 'SD17', 'TE0', 'TE1'),
'ALT2': ('PCLK', 'DE', 'LCD_VSYNC', 'LCD_HSYNC', 'DPI_D0', 'DPI_D1', 'DPI_D2', 'DPI_D3', 'DPI_D4', 'DPI_D5', 'DPI_D6', 'DPI_D7', 'DPI_D8', 'DPI_D9', 'DPI_D10', 'DPI_D11', 'DPI_D12', 'DPI_D13', 'DPI_D14', 'DPI_D15', 'DPI_D16', 'DPI_D17', 'DPI_D18', 'DPI_D19', 'DPI_D20', 'DPI_D21', 'DPI_D22', 'DPI_D23'),
'ALT3': ('SPI3_CE0_N', 'SPI3_MISO', 'SPI3_MOSI', 'SPI3_SCLK', 'SPI4_CE0_N', 'SPI4_MISO', 'SPI4_MOSI', 'SPI4_SCLK', '_', '_', '_', '_', 'SPI5_CE0_N', 'SPI5_MISO', 'SPI5_MOSI', 'SPI5_SCLK', 'CTS0', 'RTS0', 'SPI6_CE0_N', 'SPI6_MISO', 'SPI6_MOSI', 'SPI6_SCLK', 'SD1_CLK', 'SD1_CMD', 'SD1_DAT0', 'SD1_DAT1', 'SD1_DAT2', 'SD1_DAT3'),
'ALT4': ('TXD2', 'RXD2', 'CTS2', 'RTS2', 'TXD3', 'RXD3', 'CTS3', 'RTS3', 'TXD4', 'RXD4', 'CTS4', 'RTS4', 'TXD5', 'RXD5', 'CTS5', 'RTS5', 'SPI1_CE2_N', 'SPI1_CE1_N', 'SPI1_CE0_N', 'SPI1_MISO', 'SPIl_MOSI', 'SPI1_SCLK', 'ARM_TRST', 'ARM_RTCK', 'ARM_TDO', 'ARM_TCK', 'ARM_TDI', 'ARM_TMS'),
'ALT5': ('SDA6', 'SCL6', 'SDA3', 'SCL3', 'SDA3', 'SCL3', 'SDA4', 'SCL4', 'SDA4', 'SCL4', 'SDA5', 'SCL5', 'SDA5', 'SCL5', 'TXD1', 'RXD1', 'CTS1', 'RTS1', 'PWM0', 'PWM1', 'GPCLK0', 'GPCLK1', 'SDA6', 'SCL6', 'SPI3_CE1_N', 'SPI4_CE1_N', 'SPI5_CE1_N', 'SPI6_CE1_N')
}

def pin_state(g):
    mode = pi.get_mode(g)
    if(mode<2):
        name = 'GPIO{}'.format(g)
    else:
        name = FUNCTION[MODES[mode]][g]
    return name, MODES[mode], pi.read(g)

if len(sys.argv) > 1:
    pi = pigpio.pi(sys.argv[1])
else:
    pi = pigpio.pi()

if not pi.connected:
    sys.exit(1)
rev = pi.get_hardware_revision()
if rev < 16 :
    GPIOPINS = 26

print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
print('| BCM |    Name    | Mode | V |  Board   | V | Mode | Name      | BCM |')
print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
for h in range(1, GPIOPINS, 2):
# odd pin
    hh = HEADER[h-1]
    if(type(hh)==type(1)):
        print('|{0:4} | {1[0]:<10} | {1[1]:<4} | {1[2]} |{2:3} '.format(hh, pin_state(hh), h), end='|| ')
    else:
        print('|     |  {:18}   | {:2}'.format(hh, h), end=' || ')
# even pin
    hh = HEADER[h]
    if(type(hh)==type(1)):
        print('{0:2} | {1[2]:<2}| {1[1]:<5}| {1[0]:<10}|{2:4} |'.format(h+1, pin_state(hh), hh))
    else:
        print('{:2} |             {:9}|     |'.format(h+1, hh))
print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
print('| BCM |    Name    | Mode | V |  Board   | V | Mode | Name      | BCM |')
print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
EOF
    )
    python3 -c "${PY3_SCRIPT}"
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnMPSTAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND mpstat
  then
    fnBANNER "MPSTAT (***)"
    # 3 samples, 3 seconds apart, to get an average
    mpstat 3 3
    echo
  else
    echo "Missing utility mpstat (part of sysstat), skipping mpstat display" >&2
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnIOSTAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND iostat
  then
    fnBANNER "IOSTAT (***)"
    iostat -x
  else
    echo "Missing utility iostat (part of sysstat), skipping iostat display" >&2
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnIPS_FQDNS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local IPV4LL=""
  local IPV6LL=""
  local IPV4=""
  local IPV6=""
  local NAMES=""

  fnBANNER "ISP-PROVIDED EXTERNAL IP (***)"
  if fnCHECK_COMMAND curl && fnCHECK_COMMAND nslookup
  then
    # get the external ip provided by your isp...
    EXT_IP=$(curl --silent ifconfig.me/ip)
    echo "Your External IP Address..."
    echo "  ${EXT_IP}"
    echo
    EXT_NAME=$(nslookup "${EXT_IP}" | grep "name =" | awk '{ print $NF }')
    echo "Your External DNS Name..."
    echo "  ${EXT_NAME}"
    echo
  fi

  if fnCHECK_COMMAND hostname
  then
    fnBANNER "LINK-LOCAL ADDRESSES"
    echo "IPv4 link-local..."
    if ! grep -q " using IPv4LL address " /var/log/syslog
    then
      echo "  No IPv4 link-local addresses present"
    else
      awk '/ using IPv4LL address / { print $NF }' /var/log/syslog | sort -u | while read -r IPV4LL
      do
        echo "  ${IPV4LL}"
      done
    fi
    echo

    echo "IPv6 link-local..."
    if ! ip addr show | grep -q "scope link"
    then
      echo "  No IPv6 link-local addresses present"
    else
      ip addr show | grep "scope link" | awk '{ print $2 }' | cut -f1 -d"/" | sort -u | while read -r IPV6LL
      do
        echo "  ${IPV6LL}"
      done
    fi
    echo

    fnBANNER "LOCAL IPV4 ADDRESSES"
    ifconfig | grep "inet " | grep -v link | awk '{ print $2 }' | sort -u -n -t. -k 1,1  -k 2,2  -k 3,3  -k 4,4 | while read -r IPV4
    do
      echo "  ${IPV4}"
    done

    echo
    fnBANNER "LOCAL IPV6 ADDRESSES"
    ifconfig | grep "inet6 " | grep -v link | awk '{ print $2 }' | sort -u | while read -r IPV6
    do
      echo "  ${IPV6}"
    done
    echo

    fnBANNER "YOUR RESOLVABLE NAMES..."
    for NAMES in $(hostname -A | sort -u)
    do
      echo "  ${NAMES}"
    done
    echo

    echo "NOTES ABOUT THE ABOVE..."
    echo "  Not every ip address above may resolve to a name.  Also,"
    echo "  if you've inappropriately used IP addresses on your Pi"
    echo "  that are not RFC1918 compliant, the results you see here"
    echo "  may not be what you expect (your \"inside\" ip addresses"
    echo "  may resolve to external DNS names)."
    echo
    echo "  You might also see instances where your ISP resolves"
    echo "  perfectly RFC-legal private ip addresses to names for"
    echo "  their own network support people to quickly identify"
    echo "  subnets that match the IP addresses you chose to use,"
    echo "  and you (or some software such as docker, which creates"
    echo "  additional virtual interfaces on your machine) happened"
    echo "  to just pick an address that overlaps with something"
    echo "  your ISP has allocated/exposed to name resolution."
    echo
    echo "  Depending on how your Pi is configured to resolve names"
    echo "  (via hosts file, dns, domain search paths, and so on),"
    echo "  the results above may be incomplete, or again, not what"
    echo "  you expect."
    echo
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnIP6STAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "$(grep "ipv6.disable=1" /boot/cmdline.txt 2>/dev/null)" != "" ]]
  then
    fnBANNER "IPV6 DISABLED"
    echo "IPv6 has been disabled in cmdline.txt"
    echo
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnNET_FILES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local HITS=""

  if [[ -f /etc/resolv.conf ]]
  then
    fnBANNER "RESOLV.CONF"
    grep -E -v "^$|^#" < /etc/resolv.conf 2>/dev/null
    echo
  else
    echo "Missing file /etc/resolv.conf" >&2
  fi

  if [[ -f /etc/hosts ]]
  then
    fnBANNER "HOSTS FILE"
    grep -E -v "^$|^#" < /etc/hosts 2>/dev/null
    echo
  else
    echo "Missing file /etc/hosts" >&2
  fi

  if [[ -f /etc/networks ]]
  then
    fnBANNER "NETWORKS FILE"
    grep -E -v "^$|^#" < /etc/networks 2>/dev/null
    echo
  else
    echo "Missing file /etc/networks" >&2
  fi

  if [[ -f /etc/iptables.up.rules ]]
  then
    fnBANNER "IPV4 FIREWALL RULES"
    grep -E -v "^$|^#" < /etc/iptables.up.rules 2>/dev/null
    echo
  else
    echo "Missing file /etc/iptables.up.rules" >&2
  fi

  if [[ -f /etc/ip6tables.up.rules ]]
  then
    fnBANNER "IPV6 FIREWALL RULES"
    grep -E -v "^$|^#" < /etc/ip6tables.up.rules 2>/dev/null
    echo
  else
    echo "Missing file /etc/ip6tables.up.rules" >&2
  fi

  if [[ -f /etc/hosts.deny ]]
  then
    fnBANNER "TCPWRAPPERS: HOSTS.DENY"
    HITS=$(grep -E -v "^$|^#" < /etc/hosts.deny 2>/dev/null | grep -c . || :)
    if [[ "${HITS}" -ne 0 ]]
    then
      grep -E -v "^#|^$" < /etc/hosts.deny 2>/dev/null
    else
      echo "file is empty"
    fi
    echo
  else
    echo "Missing file /etc/hosts.deny" >&2
  fi

  if [[ -f /etc/hosts.allow ]]
  then
    fnBANNER "TCPWRAPPERS: HOSTS.ALLOW"
    HITS=$(grep -E -v "^#|^$" < /etc/hosts.allow 2>/dev/null | grep -c . || :)
    if [[ "${HITS}" -ne 0 ]]
    then
      grep -E -v "^#|^$" < /etc/hosts.allow 2>/dev/null
    else
      echo "file is empty"
    fi
    echo
  else
    echo "Missing file /etc/hosts.allow" >&2
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnROUTES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "ROUTE TABLE - IPV4"
  route -4 2> /dev/null
  echo
  fnBANNER "ROUTE TABLE - IPV6"
  route -6 2>/dev/null || :
  echo
  #KPC
  # Maybe show the default gateway to the internet?
  # ip route get 8.8.8.8 | grep " via " | awk '{ print $3 }'
  # 8.8.8.8 via 192.168.43.1 dev wlan0 src 192.168.43.11 uid 0
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnNET_ADAPTERS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "NETWORK ADAPTERS"
  ${SUDO} lshw -class network 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnETHTOOL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ETH=""

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND ethtool
  then
    ifconfig | grep "flags=" | grep -v "lo:" | cut -f1 -d":" | while read -r ETH
    do
      fnBANNER "ETHTOOL ${ETH} (***)"
      echo "Found ${ETH}..."
      echo
      ${SUDO} ethtool -i "${ETH}"
      echo
      ${SUDO} ethtool "${ETH}" || :
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnIFCONFIG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "IFCONFIG"
  ifconfig
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnARP_CACHE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "IP NEIGHBORS (ARP CACHE)"
  ip neigh
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnSUPPLICANT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -f /etc/wpa_supplicant/wpa_supplicant.conf ]]
  then
    fnBANNER "WPA_SUPPLICANT FILE (Passwords will not be displayed)"
    ${SUDO} grep -v "^$" /etc/wpa_supplicant/wpa_supplicant.conf 2>/dev/null \
      | sed 's/psk=.*/psk=**PASSWORD_HIDDEN**/' \
      | sed 's/wep_key0=.*/wep_key0=**PASSWORD_HIDDEN**/' \
      | sed 's/password=.*/password=**PASSWORD_HIDDEN**/' \
      | sed 's/passwd=.*/passwd=**PASSWORD_HIDDEN**/'
    echo
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnIWCONFIG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local WLAN=""

  fnBANNER "IWCONFIG"
  ip -s link | grep "wlan[0-3]" | awk '{ print $2 }' | cut -f1 -d":" | while read -r WLAN
  do
    iwconfig "${WLAN}" 2>/dev/null
  done
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnWIFI_AP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "VISIBLE WIFI ACCESS POINTS"
  iwlist scan 2>/dev/null | grep -v "^$" | grep -v "Unknown:" || :
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
#
fnNETSTAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "NETSTAT"
  netstat -n 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_NET_FS
# Calls fnBANNER
#
fnRPC_NFS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PS_RPC=""

  # SUPPLEMENTAL STUFF HERE
  # Another supplemental test.  If they have the portmapper and NFS running,
  # we'll show some information along with a list of any exports.
  PS_RPC=$(pgrep "rpcbind")
  if [[ -n "${PS_RPC}" ]]
  then
    if fnCHECK_COMMAND rpcinfo
    then
      fnBANNER "PORTMAPPER - RPCINFO (***)"
      rpcinfo localhost
      echo
    else
      echo "Missing utility rpcinfo, skipping rpcinfo display" >&2
    fi

    #---------------
    # SUPPLEMENTAL STUFF HERE
    if fnCHECK_COMMAND showmount
    then
      fnBANNER "EXPORTED NFS DIRS (***)"
      showmount -e localhost
      echo
    else
      echo "Missing utility showmount, skipping nfs exports display" >&2
    fi

    #---------------
    # SUPPLEMENTAL STUFF HERE
    fnBANNER "MOUNTED NFS DIRS (***)"
    if [[ "$(df -hT --type=nfs --type=nfs4)" != "" ]]
    then
      df -hT --type=nfs --type=nfs4
      echo
      if fnCHECK_COMMAND nfsiostat
      then
        fnBANNER "NFSIOSTAT (***)" | grep -v "^$" || :
        nfsiostat
      else
        echo "Missing nfsiostat, skipping nfsiostat display" >&2
      fi
    else
      echo "No NFS shares mountted"
    fi
    echo
  fi
}

#---------------
# Called by fnGROUP_NET_FS
# Calls fnBANNER
#
fnSMB_CIFS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PS_SMB=""

  # SUPPLEMENTAL STUFF HERE
  # Another supplemental test.  If they have smb running,
  # we'll show some samba stats
  PS_SMB=$(pgrep "smbd")
  if [[ -n "${PS_SMB}" ]]
  then
    if fnCHECK_COMMAND smbstatus
    then
      fnBANNER "SMBSTATUS - REMOTE SYSTEMS CONNECTED TO US (***)" | grep -v "^$" || :
      ${SUDO} smbstatus
    else
      echo "Missing utility smbstatus, skipping smbstatus display" >&2
    fi
  fi

  fnBANNER "MOUNTED CIFS DIRS"
  if [[ -n "$(df -hT --type=cifs 2>/dev/null)" ]]
  then
    df -hT --type=cifs 2>/dev/null
  else
    echo "No remote CIFS/Windows shares mounted"
  fi
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnERRNO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND perl && fnCHECK_COMMAND m4
  then
    fnBANNER "OPERATING SYSTEM ERROR NUMBERS (***)"
    echo " NUM SYMBOLIC_NAME    DESCRIPTION"
    echo " ----------------------------------------------------"
    # Ordinarily the codes don't go as high as 255, but allowing for
    # such here is hoped to future-proof the command in the event
    # new error numbers appear with future releases of the kernel.
    # The following only prints valid errnos that exist in the kernel.
    perl -MErrno -e 'my %e= map { Errno->$_()=>$_ } keys(%!); print grep !/unknown error/i, map sprintf("%4d %-16s %s".$/,$_,$e{$_},$!=$_), 1..255'
    echo
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnSIGNALS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "EVENT SIGNALS"
  trap -l
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnCRON()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "JOB SCHEDULING - CRON"
  echo " Contents of /etc/crontab:"
  if [[ -f /etc/crontab ]]
  then
    cat /etc/crontab
  else
    echo " File /etc/crontab is missing!"
  fi
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.d ..."
  ls /etc/cron.d
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.hourly ..."
  ls /etc/cron.hourly
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.daily ..."
  ls /etc/cron.daily
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.weekly ..."
  ls /etc/cron.weekly
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.monthly ..."
  ls /etc/cron.monthly
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /var/spool/cron/crontabs:"
  ${SUDO} ls /var/spool/cron/crontabs
  echo
  echo " ----------------------------------------------------"
  echo " Contents of /etc/cron.allow:"
  if [[ -f /etc/cron.allow ]]
  then
    cat /etc/cron.allow
  else
    echo " File /etc/cron.allow not configured"
  fi
  echo
  echo " ----------------------------------------------------"
  echo " Contents of /etc/cron.deny:"
  if [[ -f /etc/cron.deny ]]
  then
    cat /etc/cron.deny
  else
    echo " File /etc/cron.deny not configured"
  fi
  echo
  echo " ----------------------------------------------------"
  systemctl status cron.service | iconv -f UTF8 -t ASCII//TRANSLIT
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
#
fnAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND at
  then
    fnBANNER "JOB SCHEDULING - AT (***)"
    if [[ -f /etc/at.allow ]]
    then
      echo " Contents of /etc/at.allow:"
      ${SUDO} cat /etc/at.allow 2>/dev/null
      echo
    else
      echo " File /etc/at.allow not configured"
      echo
    fi
    echo " ----------------------------------------------------"
    if [[ -f /etc/at.deny ]]
    then
      echo " Contents of /etc/at.deny:"
      ${SUDO} cat /etc/at.deny 2>/dev/null
      echo
    else
      echo " File /etc/at.deny not present"
      echo
    fi
    echo " ----------------------------------------------------"
    echo " at files in /var/spool/cron/atjobs:"
    ${SUDO} ls /var/spool/cron/atjobs
    echo
    echo " ----------------------------------------------------"
    echo " at files in /var/spool/cron/atspool:"
    ${SUDO} ls /var/spool/cron/atspool
    echo
    echo " ----------------------------------------------------"
    echo " Checking atq for any jobs..."
    if [[ -n "$(${SUDO} atq)" ]]
    then
      ${SUDO} atq
    else
      echo " No jobs found"
    fi
    echo
    echo " ----------------------------------------------------"
    systemctl status atd.service | iconv -f UTF8 -t ASCII//TRANSLIT
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnAGNOSTICS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "AGNOSTICS MEDIA SPEED TEST"
  /bin/sh /usr/share/agnostics/sdtest.sh
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnSYSBENCH_CPU()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND sysbench
  then
    fnBANNER "SYSBENCH CPU BENCHMARK (***)"
    sysbench --num-threads=4 --test=cpu --cpu-max-prime=20000 --validate run
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnSYSBENCH_MEM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND sysbench
  then
    fnBANNER "SYSBENCH MEMORY READ/WRITE BENCHMARK (***)"
    sysbench --test=memory run --memory-total-size=2G
    echo " ----------------------------------------------------"
    sysbench --test=memory run --memory-total-size=2G --memory-oper=read
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
#
fnSYSBENCH_IO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  # This only gets called if the touchfile "${HOME}/.system_info_io" exists
  if fnCHECK_COMMAND sysbench
  then
    fnBANNER "SYSBENCH FILEIO BENCHMARK (***)"
    if [[ -e "${HOME}/.system_info_io" ]]
    then
      echo -e " Touchfile \"${HOME}/.system_info_io\" detected."
      echo " Executing the sysbench File I/O benchmark."
      echo "=================================================="
      echo
      sysbench --test=fileio --file-total-size=2G prepare
      sysbench --test=fileio --file-total-size=2G --file-test-mode=rndrw --init-rng=on --max-time=300 --max-requests=0 run
      sysbench --test=fileio --file-total-size=2G cleanup
      echo
      echo "=================================================="
      echo " To prevent system_info from running this test,"
      echo " delete the touchfile with the following command:"
      echo "   rm ${HOME}/.system_info_io"
      echo
    else
      echo -e " Touchfile \"${HOME}/.system_info_io\" not detected."
      echo " Skipping sysbench File I/O benchmark."
      echo
      echo " To have system_info run this test, create the"
      echo " touchfile with the following command:"
      echo "   touch ${HOME}/.system_info_io"
      echo
      echo " To prevent system_info from running this test,"
      echo " delete the touchfile with the following command:"
      echo "   rm ${HOME}/.system_info_io"
      echo
      echo " Note that enabling this test creates, writes, reads"
      echo " and deletes 128 test files, 16Mb each (2GB total)."
      echo " Most people will NOT want to do that much writing to"
      echo " their wear-sensitive media (mainly SD cards and USB-"
      echo " attached SSD drives), on a regular basis."
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnMODULES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "LOADED MODULES"
  lsmod | head -1
  lsmod | sort | grep -v "Used by" || :
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnMOD_DETAILS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MODULE=""

  fnBANNER "MODULE DETAILS"
  lsmod | awk '{ print $1 }' | grep -v "^Module" | sort | while read -r MODULE
  do
    echo "===================="
    modinfo "${MODULE}"
    echo
  done
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnSHOW_REPOS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local REPO=""

  fnBANNER "CONFIGURED REPOSITORIES"
  echo "The following binary repositories are configured..."
  grep --recursive --include '*.list' '^deb ' /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null | while read -r REPO
  do
    echo "  ${REPO}"
  done
  echo
  echo "The following source repositories are configured..."
  grep --recursive --include '*.list' '^deb-src ' /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null | while read -r REPO
  do
    echo "  ${REPO}"
  done
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnUPGRADABLES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CHECKING REPOSITORIES"
  # confirm that we can connect to the internet...
  if ping www.yahoo.com -c 3 >/dev/null 2>&1
  then
    echo "This script will *NOT* upgrade any of your packages."
    echo "It will only see if package upgrades are available."
    echo "Any package updates listed here are your responsibility"
    echo "to upgrade.  This script makes no changes to your system."
    echo
    echo "Fetching available package lists from the repositories..."
    ${SUDO} apt update 2>/dev/null
    echo
    echo "Any available upgrades will appear here..."
    ${SUDO} apt list --upgradable 2>/dev/null
    echo
  else
    echo "Unable to reach the Internet.  Are you connected?"
    echo
  fi
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnDEPENDENCY_CHECK()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CHECK FOR BROKEN DEPENDENCIES"
  ${SUDO} apt-get check
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnON_HOLD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Packages can be placed "on hold" to prevent upgrading a package
  # in question.  While on hold, apt, apt-get, dpkg, aptitude and so on
  # will all refuse to upgrade the on-hold package.  Here, we remind
  # the admin of any packages they may have placed "on hold".
  #
  # To place a package on hold to prevent upgrade:
  #   sudo apt-mark hold <package_name>
  # To release a package from hold to allow upgrade:
  #   sudo apt-mark unhold <package_name>
  # To view list of packages currently on hold:
  #   sudo dpkg --get-selections | grep "hold"
  fnBANNER "PACKAGES ON HOLD TO DISALLOW UPGRADE"
  if [[ "$(${SUDO} dpkg --get-selections | grep "hold$")" = "" ]]
  then
    echo "No packages placed on hold"
    echo
  else
    ${SUDO} dpkg --get-selections | grep "hold$"
  fi
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnPACKAGES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "INSTALLED PACKAGE LIST"
  dpkg -l 2>/dev/null | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
#
fnPKG_DETAILS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PACKAGE=""

  fnBANNER "PACKAGE DETAILS"
  apt list 2>/dev/null | cut -f1 -d"/" | sort | while read -r PACKAGE
  do
    echo "===================="
    apt show "${PACKAGE}" 2>/dev/null
  done
}

#---------------
# Called by fnGROUP_OTHER
# Calls fnBANNER, fnSUB_BANNER
#
fnDOCKER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local SERVICE=""

  # SUPPLEMENTAL STUFF HERE
  if [[ -n "$(pgrep "dockerd")" ]] || [[ -n "$(pgrep "docker")" ]]
  then
    fnBANNER "DOCKER (***)"
    ${SUDO} docker version 2>/dev/null
    echo
    echo "-------------------------------"
    ${SUDO} docker info 2>/dev/null

    if [[ -f /etc/containerd/config.toml ]]
    then
      fnSUB_BANNER "Contents of /etc/containerd/config.toml"
      grep -E -v "^#|^$" < /etc/containerd/config.toml
      echo
    fi

    systemctl | iconv -f UTF8 -t ASCII//TRANSLIT | grep "docker" | awk '{ print $1 }' | while read -r SERVICE
    do
      fnSUB_BANNER "Docker Service..." | grep -v "^$" || :
      systemctl status "${SERVICE}" | iconv -f UTF8 -t ASCII//TRANSLIT
    done
    echo

    fnSUB_BANNER "ALL CONTAINERS" | grep -v "^$" || :
    ${SUDO} docker ps -a 2>/dev/null
    echo
    fnSUB_BANNER "RUNNING CONTAINERS" | grep -v "^$" || :
    ${SUDO} docker ps 2>/dev/null
    echo
    fnSUB_BANNER "ALL IMAGES"
    ${SUDO} docker images 2>/dev/null
    echo

    if [[ "$(docker images 2>/dev/null | awk '{ print $1 }' | grep "^hello-world")" != "" ]]
    then
      fnSUB_BANNER "Docker \"Hello World\"" | grep -v "^$" || :
      ${SUDO} docker run --rm -it hello-world 2>/dev/null | sed 's/\r//'
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_OTHER
# Calls fnBANNER
#
fnNSPAWN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local NSPAWNPKG=""
  local NSPAWN=""

  # SUPPLEMENTAL STUFF HERE
  if [[ -n "$(pgrep "systemd-nspawn")" ]]
  then
    fnBANNER "SYSTEMD-NSPAWN (***)"
    echo "NSPAWN-RELATED PACKAGES INSTALLED:"
    echo
    dpkg -l | grep -i "nspawn" | awk '{ print $2 }' | while read -r NSPAWNPKG
    do
      apt show "${NSPAWNPKG}" 2>/dev/null
      echo "-------------------------------"
      echo
    done
    echo "CONTAINERS FOUND IN: /var/lib/machines"
    ${SUDO} find /var/lib/machines/ -maxdepth 1 -mindepth 1 -type d -exec basename {} \;
    echo
    echo "-------------------------------"
    ${SUDO} systemctl list-machines | iconv -f UTF8 -t ASCII//TRANSLIT
    echo
    machinectl list
    echo
    echo "-------------------------------"
    if fnCHECK_COMMAND ds64-shell
    then
      echo "DS64-SHELL..."
      ds64-shell --version 2>/dev/null | sed 's/\r//'
      echo
      echo "-------------------------------"
    fi
    systemctl | iconv -f UTF8 -t ASCII//TRANSLIT | grep "nspawn" | awk '{ print $1 }' | while read -r NSPAWN
    do
      systemctl status "${NSPAWN}" | iconv -f UTF8 -t ASCII//TRANSLIT
      echo
      echo "-------------------------------"
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnMOG
#
fnUSERCHECK()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local PW_REC=""
  local PW_USR=""
  local PW_NUM=""
  local PW_GRP=""
  local GRP_GRP=""
  local HOMEDIR=""
  local GRP_REC=""

  fnBANNER "ROOT - AND REGULAR (NON-SYSTEM) USER ACCOUNTS"
  sort -u -n -t: -k 3.1 /etc/passwd | while read -r PW_REC
  do
    PW_USR="$(echo "${PW_REC}" | cut -f1 -d":")"
    PW_NUM="$(echo "${PW_REC}" | cut -f3 -d":")"
    PW_GRP="$(echo "${PW_REC}" | cut -f4 -d":")"
    GRP_GRP="$(grep ":${PW_GRP}:" /etc/group | cut -f1 -d":")"
    if [[ "${PW_NUM}" -ge 1000 ]] && [[ "${PW_USR}" != "nobody" ]] || [[ "${PW_NUM}" -eq 0 ]]
    then
      echo "--------------------"
      echo -n "USER NAME ................... "
      echo "${PW_USR}"

      echo -n "NUMERIC UID ................. "
      echo "${PW_REC}" | cut -f3 -d":"

      echo -n "USER'S PRIMARY GROUP ........ "
      grep ":${PW_GRP}:" /etc/group | cut -f1 -d":"

      echo -n "HOME DIRECTORY .............. "
      HOMEDIR=$(grep "^${PW_USR}:" /etc/passwd | cut -f6 -d":")
      if [[ -d "${HOMEDIR}" ]]
      then
        fnMOG 700 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}"
      else
        echo -n "${HOMEDIR}"
        echo " <-- *** WARNING: SPECIFIED DIRECTORY DOES NOT EXIST ***"
      fi

      echo -n "THE USER'S SHELL ............ "
      grep "^${PW_USR}:" /etc/passwd | cut -f7 -d":"

      echo -n "MEMBER OF GROUPS ............ "
      if [[ "$(grep -E "^${PW_USR}:|:${PW_USR}$|:${PW_USR},|,{PW_USR},|,${PW_USR}$" /etc/group | cut -f1 -d":" | head -1)" != "" ]]
      then
        grep -E "^${PW_USR}:|:${PW_USR}$|:${PW_USR},|,{PW_USR},|,${PW_USR}$" /etc/group | cut -f1 -d":" | sort | while read -r GRP_REC
        do
          echo -n "${GRP_REC} "
        done
        echo
      else
        echo "Account is not a member of any groups"
      fi

      echo -n "PASSWORD STATUS ............. "
      case "$(${SUDO} passwd --status "${PW_USR}" | awk '{ print $2 }')" in
        NP)
          echo "<-- *** NO PASSWORD (THIS IS BAD) ***"
          ;;
        L)
          echo "<-- *** ADMINISTRATIVELY LOCKED ***"
          ;;
        P)
          echo "VALID - OK"
          ;;
        *)
          echo "<-- *** UNDEFINED ERROR FOUND (THIS IS BAD) ***"
          ;;
      esac

      echo -n "PASSWORD LAST CHANGED ....... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -1
      echo -n "PASSWORD EXPIRES ............ "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -2 | tail -1
      echo -n "PASSWORD INACTIVE ........... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -3 | tail -1
      echo -n "ACCOUNT EXPIRES ............. "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -4 | tail -1
      echo -n "MIN PASSWORD LIFE (DAYS) .... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -5 | tail -1
      echo -n "MAX PASSWORD LIFE (DAYS) .... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -6 | tail -1
      echo -n "WARN BEFORE CHANGE (DAYS) ... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -7 | tail -1

      if ${SUDO} test -d "${HOMEDIR}/.ssh"
      then
        echo "USER'S .ssh SETUP:"
        fnMOG 700 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh"
        if ${SUDO} test -f "${HOMEDIR}/.ssh/authorized_keys"
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/authorized_keys"
        fi
        if ${SUDO} test -f "${HOMEDIR}/.ssh/known_hosts"
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/known_hosts"
        fi
        if ${SUDO} test -f "${HOMEDIR}/.ssh/config"
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/config"
        fi
        if ${SUDO} test -f "${HOMEDIR}/.ssh/id_dsa"
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_dsa"
        fi
        if ${SUDO} test -f "${HOMEDIR}/.ssh/id_dsa.pub"
        then
          fnMOG 644 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_dsa.pub"
        fi
        if ${SUDO} test -f "${HOMEDIR}/.ssh/id_rsa"
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_rsa"
        fi
        if ${SUDO} test -f "${HOMEDIR}/.ssh/id_rsa.pub"
        then
          fnMOG 644 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_rsa.pub"
        fi
      fi
      echo
    fi
  done
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnLOGIN_DEFS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SYSTEM LOGIN DEFAULTS"
  grep -E -v "^$|^#" /etc/login.defs
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnSUB_BANNER
#
fnLAST_LOGINS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "LAST LOGINS"
  last
  echo
  lastlog
  echo
  fnSUB_BANNER "LOGIN FAILURES"
  ${SUDO} lastb
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnW()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "CURRENTLY LOGGED ON"
  w
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnSUDOERS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnBANNER "SUDOERS SYNTAX CHECK"
  ${SUDO} visudo --check --strict
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnMOG
#
fnCHECK_PERMISSIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local DIR=""

  fnBANNER "CHECKING BASIC CRITICAL DIRECTORY PERMISSIONS"
  # 755
  for DIR in / /bin /boot /dev /etc /home /lib /media /mnt /opt /run /sbin /srv /usr /var
  do
    fnMOG 755 root root "${DIR}"
  done
  # 555
  for DIR in /proc /sys
  do
    fnMOG 555 root root "${DIR}"
  done
  # OTHER
  fnMOG 700 root root /root
  fnMOG 1777 root root /tmp
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnCHKROOTKIT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND chkrootkit
  then
    fnBANNER "CHECKING FOR ROOTKITS - CHKROOTKIT (***)"
    ${SUDO} chkrootkit -e -n 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnCLAM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CLAM_SVC=""

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND clamscan
  then
    fnBANNER "CLAMAV ANTI-VIRUS SCANNER (***)"
    echo "CLAMSCAN.... $(clamscan --version 2>/dev/null)"

    if fnCHECK_COMMAND freshclam
    then
      echo "FRESHCLAM... $(freshclam --version 2>/dev/null)"
    else
      echo "FRESHCLAM... not found"
    fi

    if fnCHECK_COMMAND clamd
    then
      echo "CLAMD....... $(clamd --version 2>/dev/null)"
    else
      echo "CLAMD....... not found"
    fi

    if fnCHECK_COMMAND clamdscan
    then
      echo "CLAMDSCAN... $(clamdscan --version 2>/dev/null)"
    else
      echo "CLAMDSCAN.... not found"
    fi

    echo

    if fnCHECK_COMMAND clamconf
    then
      echo " ----------------------------------------------------"
      clamconf -n 2>/dev/null
      echo
    fi

    if [[ "$(systemctl | iconv -f UTF8 -t ASCII//TRANSLIT | grep "clamav")" != "" ]]
    then
      systemctl | iconv -f UTF8 -t ASCII//TRANSLIT | grep "clamav" | awk '{ print $1 }' | while read -r CLAM_SVC
      do
        echo " ----------------------------------------------------"
        systemctl status "${CLAM_SVC}" | iconv -f UTF8 -t ASCII//TRANSLIT
        echo
      done
    else
      echo " ----------------------------------------------------"
      echo "No clamav-related systemd services running."
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnTRIPWIRE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND tripwire
  then
    fnBANNER "TRIPWIRE (***)"
    tripwire || :
    echo
    echo " ----------------------------------------------------"

    if [[ -f /etc/tripwire/tw.cfg ]]
    then
      echo -e " Default Config File ...... /etc/tripwire/tw.cfg"
    fi

    if [[ -f /etc/tripwire/tw.pol ]]
    then
      echo -e " Default Policy File ...... /etc/tripwire/tw.pol"
    fi

    if [[ -f /var/lib/tripwire/"${HOSTNAME}".twd ]]
    then
      echo -e " Default Database File .... /var/lib/tripwire/${HOSTNAME}.twd"
    fi

    if [[ -f /etc/tripwire/site.key ]]
    then
      echo -e " Default Site Key ......... /etc/tripwire/site.key"
    fi

    if [[ -f /etc/tripwire/"${HOSTNAME}"-local.key ]]
    then
      echo -e " Default Local Key ........ /etc/tripwire/${HOSTNAME}-local.key"
    fi

    if [[ -d /var/lib/tripwire/report ]]
    then
      echo -e " Default Report Directory . /var/lib/tripwire/report"
    fi

    echo " ----------------------------------------------------"
    echo
    if [[ -f /var/lib/tripwire/"${HOSTNAME}".twd ]]
    then
      ${SUDO} tripwire --check || :
    fi
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnNMAP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local MY_IP=""

  # SUPPLEMENTAL STUFF HERE
  # Not everyone has, or needs, nmap.  So, it's not a required dependency
  # for this script.  However, if we do find that it is available, we can
  # make use of it here.
  if fnCHECK_COMMAND nmap
  then
    # IPV4
    ifconfig | grep "inet " | awk '{ print $2 }' | sort -u -n -t. -k 1,1  -k 2,2  -k 3,3  -k 4,4 | while read -r MY_IP
    do
      fnBANNER "SCANNING FOR SERVICES ON IPV4: ${MY_IP} (***)"
      nmap -Pn -sV -T4 -p 1-65535 --version-light "${MY_IP}" | grep -E "^PORT|^[1-9][0-9]"
      echo
    done
    # IPV6
    ifconfig | grep "inet6 " | grep -v "inet6 ....::" | awk '{ print $2 }' | sort | while read -r MY_IP
    do
      fnBANNER "SCANNING FOR SERVICES ON IPV6: ${MY_IP} (***)"
      nmap -6 -Pn -sV -T4 -p 1-65535 --version-light "${MY_IP}" | grep -E "^PORT|^[1-9][0-9]"
      echo
    done
  fi

}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnSUB_BANNER
#
fnSNORT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND snort
  then
    fnBANNER "SNORT IDS (***)"
    snort -V 2>&1
    echo
    if [[ -f /etc/snort/snort.conf ]]
    then
      fnSUB_BANNER "SNORT CONFIGURATION TEST..."
      ${SUDO} snort -T -c /etc/snort/snort.conf 2>&1
      echo
    fi
    echo " ----------------------------------------------------"
    systemctl status snort.service | iconv -f UTF8 -t ASCII//TRANSLIT
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnLYNIS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND lynis
  then
    fnBANNER "LYNIS (***)"
    # The 'sed' strips some nuisance ansi color codes from the output
    ${SUDO} lynis update info --cronjob 2> /dev/null | sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g'
    echo " ----------------------------------------------------"
    ${SUDO} lynis update check --cronjob 2> /dev/null
    echo
    echo " ----------------------------------------------------"
    ${SUDO} lynis show profiles --cronjob 2> /dev/null
    echo
    echo " ----------------------------------------------------"
    ${SUDO} lynis audit system --cronjob 2> /dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnUFW()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND ufw
  then
    fnBANNER "UFW (***)"
    ${SUDO} ufw version
    echo
    echo " ----------------------------------------------------"
    ${SUDO} ufw status verbose
    echo
    echo " ----------------------------------------------------"
    systemctl status ufw.service | iconv -f UTF8 -t ASCII//TRANSLIT
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnRKHUNTER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND rkhunter
  then
    fnBANNER "CHECKING FOR ROOTKITS - RKHUNTER (***)"
    ${SUDO} rkhunter --versioncheck --nocolors
    echo
    echo " ----------------------------------------------------"
    ${SUDO} rkhunter --update --nocolors
    echo
    echo " ----------------------------------------------------"
    if ${SUDO} rkhunter --config-check
    then
      ${SUDO} rkhunter -c --enable all --rwo --sk --nocolors || :
    fi
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnUNHIDE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND unhide
  then
    fnBANNER "UNHIDE (***)"
    ${SUDO} unhide sys
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnAUDITD()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND auditctl && [[ "${HAS_AUDITD}" = "yes" ]]
  then
    fnBANNER "AUDITD (***)"
    ${SUDO} auditctl -l
    echo
    echo " ----------------------------------------------------"
    ${SUDO} ls -alR /etc/audit
    echo
    echo " ----------------------------------------------------"
    ${SUDO} aureport
    echo
    echo " ----------------------------------------------------"
    ${SUDO} ls -alR /var/log/audit
    echo
    echo " ----------------------------------------------------"
    systemctl status auditd.service | iconv -f UTF8 -t ASCII//TRANSLIT
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
# This function is an optimistic placeholder, should the
# kernel one day be provided with SELINUX support compiled in.
# It presently does nothing but return to where it was called.
#
# fnSELINUX()
# {
#   fnDEBUG
#
#   # SUPPLEMENTAL STUFF HERE
#   if [[ "${HAS_SELINUX}" = "yes" ]]
#   then
#     fnBANNER "SELINUX (***)"
#     # If SELINUX support ever shows up in the repo kernels,
#     # I'll add stuff here, to report on it.
#   fi
#   return 0
# }

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
#
fnAPPARMOR()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # SUPPLEMENTAL STUFF HERE
  if fnCHECK_COMMAND aa-status && [[ "${HAS_APPARMOR}" = "yes" ]] && [[ "$(grep "apparmor=1" /boot/cmdline.txt)" != "" ]]
  then
    fnBANNER "APPARMOR (***)"
    echo -n "Apparmor enabled: "
    aa-enabled
    echo
    ${SUDO} aa-status
    echo
  fi
}

#----------------------------------- INITIALIZATION - RUN BEFORE MENU
# Called by fnMAIN
# Calls several functions
#
fnCONFIRM_PREREQS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnSUDO
  fnCONFIRM_OS
  fnRING_BUF
  fnCHECK_VIRT
  fnCHECK_CHROOT
  fnGET_REVISION_CODE
  fnCHK_PACKAGES
  fnLSHW_BUSINFO
}

##################################################
# THE INDIVIDUAL FUNCTIONS DEFINED ABOVE NOW GET GROUPED TOGETHER
# BY MENU SELECTION. It beats moving whole blocks or code around.
##################################################

#----------------------------------- Pi Hardware
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_HARDWARE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   /|      Menu Option 1'
  echo '__)|__\__ | |\__/| \|    |      PI HARDWARE'
  echo
  SECTION="1"
  fnPRINT_DECODED_REV
  fnSYSTEM_ID
  fnMAC
  fnMODEL
  fnDIAGRAM
  fnCPU
  fnSENSORS
  fnHOW_BOOT
}

#----------------------------------- Performance
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_PERFORMANCE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __        __      '
  echo '(_ |_ /   | |/  \|\ |    _)     Menu Option 2'
  echo '__)|__\__ | |\__/| \|   /__     PERFORMANCE'
  echo
  SECTION="2"
  fnPROCSPEED
  fnOVERCLOCK
  fnRING_OSCILLATOR
  fnCLOCKFREQ
  fnVOLTS
  fnTEMPS
  fnGOV
  fnTHROTTLES
  fnMPSTAT
  fnIOSTAT
  fnAGNOSTICS
  fnSYSBENCH_CPU
  fnSYSBENCH_MEM
  fnSYSBENCH_IO
}

#----------------------------------- O/S Config
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_OS_CONFIG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __        __      '
  echo '(_ |_ /   | |/  \|\ |    _)     Menu Option 3'
  echo '__)|__\__ | |\__/| \|   __)     OS CONFIG'
  echo
  SECTION="3"
  fnOS
  fnLOCALE
  fnCMDLINE
  fnCONFIGTXT
  fnDTOVERLAYS
  fnDTPARAMS
  fnSYSCTL
  fnLEDS
  fnULIMIT_CORE
  fnERRNO
  fnSIGNALS
  fnCRON
  fnAT
}

#----------------------------------- Memory
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_MEMORY()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   |__|    Menu Option 4'
  echo '__)|__\__ | |\__/| \|      |    MEMORY'
  echo
  SECTION="4"
  fnMEMSPLIT
  fnMEMSWAP
  fnMEMINFO
  fnIPC
}

#----------------------------------- Logging
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_LOGGING()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   |_      Menu Option 5'
  echo '__)|__\__ | |\__/| \|   __)     LOGGING'
  echo
  SECTION="5"
  fnDMESG
  fnJOURNAL
  fnRSYSLOG
  fnLOGROTATE
}

#----------------------------------- Services
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_OS_SERVICES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   /__     Menu Option 6'
  echo '__)|__\__ | |\__/| \|   \__)    SERVICES'
  echo
  SECTION="6"
  fnSYSTEMD_CHAIN
  fnSYSTEMD_BLAME
  fnSYSTEMD_SECURITY
  fnSYSCTL_STATUS
  fnSYSCTL_FAIL
  fnSYSCTL_LIST
  fnRCLOCAL
}

#----------------------------------- H/W Busses
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_HW_BUSSES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __        ___     '
  echo '(_ |_ /   | |/  \|\ |     /     Menu Option 7'
  echo '__)|__\__ | |\__/| \|    /      HARDWARE BUSSES'
  echo
  SECTION="7"
  fnRF
  fn1W
  fnSPI
  fnI2S
  fnI2C
  fnNVME
  fnPCI
  fnPCIE
  fnSDHCI
  fnXHCI
  fnEMMC
  fnWIRINGPI
  fnPIGPIOD
}

#----------------------------------- Serial & Bluetooth
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_SERIAL_BT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   (__)    Menu Option 8'
  echo '__)|__\__ | |\__/| \|   (__)    SERIAL & BLUETOOTH'
  echo
  SECTION="8"
  fnACM
  fnSERIAL
  fnBT
}

#----------------------------------- USB & Other Devices
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_DEVICES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   (__\    Menu Option 9'
  echo '__)|__\__ | |\__/| \|    __/    USB & OTHER DEVICES'
  echo
  SECTION="9"
  fnUSB_DEV_INFO
  fnLSHW_INPUT
  fnLSHW_GENERIC
  fnRTL_SDR
  fnRTC
  fnHWRNG
  fnHWWD
  fnLIRC
  fnPRINTER
}

#----------------------------------- Filesystems & Storage
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_FS_STORAGE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __            __  '
  echo '(_ |_ /   | |/  \|\ |   /| /  \ Menu Option 10'
  echo '__)|__\__ | |\__/| \|    | \__/ FILESYSTEMS & STORAGE'
  echo
  SECTION="10"
  fnFSTAB
  fnLSHW_STORAGE
  fnHDPARM
  fnSMART
  fnQUIRKS
  fnTRIM
  fnBLKID
  fnRAID
  fnLVM
  fnQUOTAS
  fnOVERLAYFS
}

#----------------------------------- Audio & Video
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_AV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   /| /|   Menu Option 11'
  echo '__)|__\__ | |\__/| \|    |  |   AUDIO & VIDEO'
  echo
  SECTION="11"
  fnLSHW_MM
  fnALSA_MOD
  fnALSA_HW
  fnALSA_CARD
  fnALSA_PB_CAP
  fnCAMERA
  fnCODECS
  fnV4L2CODECS
  fnV4LDEV
  fnTOUCH
  fnDISPDRV
  fnDISPLAY
  fnROWS_COLS
  fnRESOLUTION
  fnSCREEN_SESSIONS
  fnTMUX
  fnXWINDOWS
}

#----------------------------------- Networking
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_NETWORK()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __           __   '
  echo '(_ |_ /   | |/  \|\ |   /|  _)  Menu Option 12'
  echo '__)|__\__ | |\__/| \|    | /__  NETWORKING'
  echo
  SECTION="12"
  fnIPS_FQDNS
  fnIP6STAT
  fnNET_FILES
  fnROUTES
  fnNET_ADAPTERS
  fnETHTOOL
  fnIFCONFIG
  fnARP_CACHE
  fnSUPPLICANT
  fnIWCONFIG
  fnWIFI_AP
  fnNETSTAT
}

#----------------------------------- Network Filesystems
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_NET_FS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __           __   '
  echo '(_ |_ /   | |/  \|\ |   /|  _)  Menu Option 13'
  echo '__)|__\__ | |\__/| \|    | __)  NETWORK FILESYSTEMS'
  echo
  SECTION="13"
  fnRPC_NFS
  fnSMB_CIFS
}

#----------------------------------- Containers & Virtualization
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_OTHER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   /| |__| Menu Option 14'
  echo '__)|__\__ | |\__/| \|    |    | CONTAINERS & VIRTUALIZATION'
  echo
  SECTION="14"
  fnDOCKER
  fnNSPAWN
}

#----------------------------------- Modules and Packages
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_MODS_PKGS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __            __  '
  echo '(_ |_ /   | |/  \|\ |   /| |_   Menu Option 15'
  echo '__)|__\__ | |\__/| \|    | __)  MODULES AND PACKAGES'
  echo
  SECTION="15"
  fnMODULES
  # This next function generates information about each loaded module listed
  # by fnMODULES, above.  The amount of information can be significant,
  # depending upon how many modules are running.  Uncomment if you'ld like,
  # but it may give more information than you are willing to scroll through.
  # fnMOD_DETAILS

  fnSHOW_REPOS
  fnUPGRADABLES
  fnDEPENDENCY_CHECK
  fnON_HOLD
  fnPACKAGES
  # This next function will likely never see the light of day.  It generates
  # information about every installed package on a system.  You're better
  # off running "apt show" against a single package of interest only, than
  # having this script loop through every package.  (You could have thousands
  # of packages installed, and this would loop through every one of them!)
  # fnPKG_DETAILS
}

#----------------------------------- Security
# Called by fnACTIONS
# Calls several functions
#
fnGROUP_SECURITY()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo ' __ __ _____  __            __  '
  echo '(_ |_ /   | |/  \|\ |   /| /__  Menu Option 16'
  echo '__)|__\__ | |\__/| \|    | \__) SYSTEM SECURITY'
  echo
  SECTION="16"
  fnUSERCHECK
  fnLOGIN_DEFS
  fnLAST_LOGINS
  fnW
  fnSUDOERS
  fnCHECK_PERMISSIONS
  fnCHKROOTKIT
  fnRKHUNTER
  fnCLAM
  fnTRIPWIRE
  fnNMAP
  fnUFW
  fnSNORT
  fnLYNIS
  fnUNHIDE
  # fnSELINUX
  fnAPPARMOR
  fnAUDITD
}

#---------------
# Called by fnFINISH_UP
#
fnEND_OF_REPORT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo
  echo    "==============================================================================="
  echo    ' __     __    __  __   __  __ __  __  __ ___ '
  echo -n '|_ |\ ||  \  /  \|_   |__)|_ |__)/  \|__) |  '
  echo "SYSTEM_INFO"
  echo -n '|__| \||__/  \__/|    | \ |__|   \__/| \  |  '
  echo "VER: ${MY_VERSION}"
  echo
}

##################################################
# HERE, WE ACTUALLY CALL THE GROUPS ABOVE, WHEN THE
# REPORT IS RUN, DEPENDING ON YOUR MENU SELECTIONS
#---------------
# Called by fnDO_INSPECTIONS
# Calls several functions
#
fnACTIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ -n ${CHOICES[16]} ]]
  then
    fnGROUP_HARDWARE
    fnGROUP_PERFORMANCE
    fnGROUP_OS_CONFIG
    fnGROUP_MEMORY
    fnGROUP_LOGGING
    fnGROUP_OS_SERVICES
    fnGROUP_HW_BUSSES
    fnGROUP_SERIAL_BT
    fnGROUP_DEVICES
    fnGROUP_FS_STORAGE
    fnGROUP_AV
    fnGROUP_NETWORK
    fnGROUP_NET_FS
    fnGROUP_OTHER
    fnGROUP_MODS_PKGS
    fnGROUP_SECURITY
    # If user selects to do all, do all only once
    return 0
  fi
  if [[ -n ${CHOICES[0]} ]]
  then
    fnGROUP_HARDWARE
  fi
  if [[ -n ${CHOICES[1]} ]]
  then
    fnGROUP_PERFORMANCE
  fi
  if [[ -n ${CHOICES[2]} ]]
  then
    fnGROUP_OS_CONFIG
  fi
  if [[ -n ${CHOICES[3]} ]]
  then
    fnGROUP_MEMORY
  fi
  if [[ -n ${CHOICES[4]} ]]
  then
    fnGROUP_LOGGING
  fi
  if [[ -n ${CHOICES[5]} ]]
  then
    fnGROUP_OS_SERVICES
  fi
  if [[ -n ${CHOICES[6]} ]]
  then
    fnGROUP_HW_BUSSES
  fi
  if [[ -n ${CHOICES[7]} ]]
  then
    fnGROUP_SERIAL_BT
  fi
  if [[ -n ${CHOICES[8]} ]]
  then
    fnGROUP_DEVICES
  fi
  if [[ -n ${CHOICES[9]} ]]
  then
    fnGROUP_FS_STORAGE
  fi
  if [[ -n ${CHOICES[10]} ]]
  then
    fnGROUP_AV
  fi
  if [[ -n ${CHOICES[11]} ]]
  then
    fnGROUP_NETWORK
  fi
  if [[ -n ${CHOICES[12]} ]]
  then
    fnGROUP_NET_FS
  fi
  if [[ -n ${CHOICES[13]} ]]
  then
    fnGROUP_OTHER
  fi
  if [[ -n ${CHOICES[14]} ]]
  then
    fnGROUP_MODS_PKGS
  fi
  if [[ -n ${CHOICES[15]} ]]
  then
    fnGROUP_SECURITY
  fi
}

##################################################
# A FEW REMAINING SUPPORTING FUNCTIONS DEALING
# WITH THE REPORT, THE SAVING/RECALLING OF MENU
# SELECTIONS, ETC.
#---------------
# Called by fnDO_INSPECTIONS and fnFINISH_UP
#
fnREPORT_ACTIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local CHOICE_MADE=""

  echo "The following Menu Options were selected, to generate this report:"
  if [[ -n ${CHOICES[16]} ]]
  then
    echo "  Option 17: Run All Sections - (This option overrides any/all other selections)"
    echo
    return 0
  fi
  if [[ -n ${CHOICES[0]} ]]
  then
    echo "  Option  1: Pi Hardware"
    CHOICE_MADE="Y"
  fi
  if [[ -n ${CHOICES[1]} ]]
  then
    echo "  Option  2: Performance"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[2]} ]]
  then
    echo "  Option  3: O/S Config"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[3]} ]]
  then
    echo "  Option  4: Memory"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[4]} ]]
  then
    echo "  Option  5: Logging"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[5]} ]]
  then
    echo "  Option  6: Services"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[6]} ]]
  then
    echo "  Option  7: Hardware Busses"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[7]} ]]
  then
    echo "  Option  8: Serial & Bluetooth"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[8]} ]]
  then
    echo "  Option  9: USB & Other Devices"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[9]} ]]
  then
    echo "  Option 10: Filesystems & Storage"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[10]} ]]
  then
    echo "  Option 11: Audio & Video"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[11]} ]]
  then
    echo "  Option 12: Networking"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[12]} ]]
  then
    echo "  Option 13: Network Filesystems"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[13]} ]]
  then
    echo "  Option 14: Containers & Virtualization"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[14]} ]]
  then
    echo "  Option 15: Modules and Packages"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ -n ${CHOICES[15]} ]]
  then
    echo "  Option 16: Security"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ "$(echo "${CHOICE_MADE}" | grep "Y")" = "" ]]
  then
    echo "  No Menu Options were selected"
  fi
  echo
}

#---------------
# Called by fnOVERRIDE_RCFILE
#
fnREAD_RCFILE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local NUM=""
  local BOOLEAN=""

  # NOTE:  Because the array is 0-16, and the menu is presented as
  # options 1-17, the keys in the rc file are 1 lower than the menu
  # numbers they represent.  For example, menu option 1 is stored as
  # a key of 0, option 2 is stored as a key of 1, and so on.

  # RCFILE format is:
  #   menu option number (minus 1), a colon (:), and a boolean (0 or 1)
  #   0=not selected
  #   1=selected
  #
  #   example...
  #   0:1
  #   1:0
  #   2:0
  #   3:1
  #   ...
  #   17:0
  #
  #   The numeric options described above are then followed by flags
  #   that tell the script whether to run specific tests (or not), in
  #   the presence of the relevent supplemental packages.  For example,
  #   a user may have tripwire installed and configured, but may not
  #   want this script to perform a "tripwire --check".
  if [[ -f "${RCFILE}" ]]
  then
    # Numeric menu options
    for NUM in "${!OPTIONS[@]}"
    do
      BOOLEAN="$(grep "^${NUM}:" "${RCFILE}" 2>/dev/null | cut -f2 -d":")"
      if [[ "${BOOLEAN}" = "1" ]]
      then
        CHOICES[NUM]="${REV}+${SGR0}"
      fi
    done
  fi
}

#---------------
# Called by fnFINISH_UP
#
fnWRITE_RCFILE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local NUM=""

  for NUM in "${!OPTIONS[@]}"
  do
    if [[ -n "${CHOICES[NUM]}" ]]
    then
      echo "${NUM}:1"
    else
      echo "${NUM}:0"
    fi
  done
}

#---------------
# Called by fnFINISH_UP
#
fnREPORT_RCFILE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo "These menu selections have been saved in the file:"
  echo "  ${RCFILE}"
  echo
  echo "They will be auto-selected next time this script is run by user \"$(whoami)\"."
  echo
}

#---------------
# Menu function
# Called by fnMENU_LOOP
#
fnMENU()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local SCR_ROW=""
  local SCR_COL=""

  echo "RASPBERRY PI SYSTEM INFORMATION REPORT v${MY_VERSION} - MAIN MENU"
  SCR_ROW=2
  SCR_COL=2
  for NUM in "${!OPTIONS[@]}"
  do
    if [[ "${SCR_ROW}" -gt 10 ]]
    then
      SCR_ROW=2
      SCR_COL=38
    fi
    tput cup "${SCR_ROW}" "${SCR_COL}" 2>/dev/null
    echo "[""${CHOICES[NUM]:- }""]" $(( NUM+1 ))") ${OPTIONS[NUM]}"
    (( SCR_ROW++ ))
  done
  (( SCR_ROW++ ))
  tput cup "${SCR_ROW}" 0 2>/dev/null
  echo "${ERROR}"
  echo "Type a number and press [ENTER] to select.  Again, to deselect."
  echo "Multiple selections can be made before any tests are executed."
}

#---------------
# Called by fnMAIN
# Calls fnREAD_RCFILE
#
fnOVERRIDE_RCFILE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Force the execution of a specific menu selection when testing.
  # Make sure any parameter is numeric, and between 1 and 17.
  if [[ -n "${MENU}" ]] 2>/dev/null
  then
    # Align a 1-17 parameter with 0-16 array elements
    ((CMDLINE_CHOICE=MENU-1))
    CHOICES[${CMDLINE_CHOICE}]="${REV}+${SGR0}"
  else
    fnREAD_RCFILE
  fi
}

#---------------
# Called by fnMAIN
# Calls fnMENU
#
fnMENU_LOOP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local SELECTION=""

  # Main Menu loop
  while fnMENU && read -r -e -p "Press [ENTER] by itself when ready.  Use Q [ENTER] or Ctrl-C to quit: " -n3 SELECTION && [[ -n "${SELECTION}" ]]
  do
    clear 2>/dev/null
    if [[ "${SELECTION}" = *[[:digit:]]* && ${SELECTION} -ge 1 && ${SELECTION} -le ${#OPTIONS[@]} ]]
    then
      (( SELECTION-- ))
      if [[ "${CHOICES[SELECTION]:-}" = "${REV}+${SGR0}" ]]
      then
        CHOICES[SELECTION]=""
      else
        CHOICES[SELECTION]="${REV}+${SGR0}"
      fi
      ERROR=" "
    else
      if [[ "${SELECTION}" = "q" ]] || [[ "${SELECTION}" = "Q" ]]
      then
        exit
      else
        ERROR="Invalid option: ${SELECTION}"
      fi
    fi
  done
}

#---------------
# Called by fnMAIN
# Calls several functions
#
fnDO_INSPECTIONS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Call all the inspections selected.
  clear 2>/dev/null
  SECONDS=0
  true > "${REPORT}"
  fnTITLE | tee -a "${REPORT}"
  fnSHOW_SUPP_PKGS | sed 's/SYSTEM_INFO(): //' | tee -a "${REPORT}"
  fnREPORT_ACTIONS | sed 's/\r//' | tee -a "${REPORT}"
  fnACTIONS | tee -a "${REPORT}"
}

#---------------
# Called by fnMAIN
# Calls several functions
#
fnFINISH_UP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local ELAPSED=""
  local RUNTIME=""

  # Closing Screen
  # Everything from here down happens after the inspections are complete.
  rm "${TEMPFILE}" 2>/dev/null
  ELAPSED=${SECONDS}
  RUNTIME="$((ELAPSED / 60)) minutes and $((ELAPSED % 60)) seconds."
  fnEND_OF_REPORT | tee -a "${REPORT}"
  fnBANNER "TIME REQUIRED TO GENERATE REPORT:  ${RUNTIME}" | sed 's/SYSTEM_INFO(): //' | tee -a "${REPORT}"
  fnREPORT_ACTIONS | sed 's/\r//' | tee -a "${REPORT}"
  if [[ "${CMDLINE_CHOICE}" = "" ]]
  then
    # The ">|" syntax overrides "set -o noclobber", allowing
    # an existing rc file to be updated/overwritten.
    fnWRITE_RCFILE >| "${RCFILE}"
    fnREPORT_RCFILE | tee -a "${REPORT}"
  fi
  fnBANNER "REPORT SAVED AS: $(readlink -f "${REPORT}")" | sed 's/SYSTEM_INFO(): //' | tee -a "${REPORT}"

  # If file descriptor 3 has been redirected to a debugging log file,
  # or file descriptor 4 has been redirected to a profiling log file,
  # show the names of those logs at the bottom of the system_info report.
  if [[ "${DEBUG_LOG}" != "/dev/null" ]]
  then
    echo "DEBUG LOG ..... $(readlink -f "${DEBUG_LOG}")" | tee -a "${REPORT}"
  fi
  if [[ "${PROFILE_LOG}" != "/dev/null" ]]
  then
    echo "PROFILE LOG ... $(readlink -f "${PROFILE_LOG}")" | tee -a "${REPORT}"
  fi

  echo "${BELL}"
}

#---------------
# Called by the mainline, below
# Calls several functions
#
fnMAIN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  local FOO=""

  clear 2>/dev/null
  fnINITIALIZE
  fnCONFIRM_BASH
  fnTITLE
  fnCONFIRM_PREREQS
  fnDEFINE_OPTIONS
  echo -n "PRESS ENTER FOR MENU... "
  # shellcheck disable=SC2034
  read -r FOO
  echo
  clear 2>/dev/null
  fnOVERRIDE_RCFILE
  fnMENU_LOOP
  fnDO_INSPECTIONS
  fnFINISH_UP
}

##################################################
# MAINLINE
##################################################

#---------------
readonly MY_VERSION="3.1.1"

#---------------
# Prevent output redirection using ‘>’, ‘>&’, and ‘<>’ from
# overwriting existing files.
set -C

#---------------
# Turn on privileged mode. In this mode, the $BASH_ENV and $ENV files
# are not processed, shell functions are not inherited from the
# environment, and the SHELLOPTS, BASHOPTS, CDPATH and GLOBIGNORE
# variables, if they appear in the environment, are ignored.
set -p

#---------------
# Prevent any redirection from overwriting an existing file.
set -o noclobber
# Treat unset variables as an error, and immediately exit.
#set -u
# Make globs that don't get expanded cause errors, rather than getting
# passed to the command with the * intact.
shopt -s failglob

#---------------
# "IT'S A TRAP!"
# -- Admiral Ackbar
#
# THE FOLLOWING "SET", "TRAP", AND "EXEC" COMMANDS ALL FACILITATE
# COLLECTION OF DATA USEFUL FOR DEBUGGING.  SEE THE FILE "DEBUGGING.md"
# ON THE GITHUB PAGE, FOR MORE INFORMATION.

#---------------
# Setup the file descriptor for debugging, and send a brief header to it.
[[ -e /proc/self/fd/3 ]] || exec 3> /dev/null
echo "SYSTEM_INFO v${MY_VERSION} - DEBUG LOG" >&3
echo -e "==============================\n" >&3

#---------------
# Setup the file descriptor for profiling, and send a brief header to it.
[[ -e /proc/self/fd/4 ]] || exec 4> /dev/null
echo "SYSTEM_INFO v${MY_VERSION} - PROFILING LOG" >&4
echo -e "==================================\n" >&4
BASH_XTRACEFD="4"
# Using PS4, "\011" is a tab, and "\t" is a current hh:mm:ss timestamp
# (I don't need subsecond accuracy here.)
PS4='+\011\t ${LINENO}\011'
# Enclose any section of code we want to profile with "set -x"... "set +x".
# Profiling data will be sent to the fd whenever "set -x" is in effect.
set -x

#---------------
# This line figures out if fd3 above, has been redirected to a file.
# If yes, determine the name of the debug log.  We'll report it later,
# at the bottom of the system_info report, in the function "fnFINISH_UP".
DEBUG_LOG="$(readlink /proc/self/fd/3 2>/dev/null)"

#---------------
# This line figures out if fd4 above, has been redirected to a file.
# If yes, determine the name of the profile log.  We'll report it later,
# at the bottom of the system_info report, in the function "fnFINISH_UP".
PROFILE_LOG="$(readlink /proc/self/fd/4 2>/dev/null)"

#---------------
# Ensure that ERR traps are inherited by functions, command substitutions,
# and subshell environments.
set -o errtrace
# Ensure that DEBUG and RETURN traps are inherited by functions, command substitutions,
# and subshell environments.  (The -E causes errors within functions to bubble up.)
set -E -o functrace

#---------------
# Call fnABORT to cleanup, if we abort, or are killed, for any reason.
trap fnABORT SIGHUP SIGINT SIGQUIT SIGABRT SIGTERM

#---------------
# This trap writes each line to be executed, just before it is executed, to the debug log
trap 'echo -e "line#: ${LINENO}...\t${BASH_COMMAND}" >&3' DEBUG

#---------------
# This trap will log all non-0 return codes.
# To prevent some commands from tripping an ERR trap, by returning a non-0 return code,
# I'm imediately following those commands with "|| :" ("or true").
# An example would be a grep that doesn't find it's search string (return code 1).
# In other words, not all non-0 return codes are "errors" per se, but the trap will
# spot and report them.  You can quickly find them in your debugging log by grepping
# for the string "^NON-0" in the log.  These can then be investigated to determine
# if an actual error has occurred.
trap 'echo -e "NON-0: LINE ${LINENO}: RETURN CODE: ${?}\t${BASH_COMMAND}" >&3' ERR

#---------------
# Log the completion of each function, upon return.
# It's a shame there is no corresponding logging of the entry INTO a function, only
# the return FROM a function.  This is why each function in this script begins with an
# explicit command to add a log entry showing entry into the function.
trap 'echo -e "leave: ${FUNCNAME} -> back to ${FUNCNAME[1]}\n" >&3' RETURN

#---------------
# Any equal signs (--output=foofile) passed on the commandline are replaced w/ spaces,
# so that the option, and it's parameter, are two separate elements in the array we'll
# be using in fnPARSE_CMDLINE.
MY_CMDLINE="${*//=/ }"

#---------------
REPORT=""
if [[ -n "${MY_CMDLINE}" ]]
then
  fnPARSE_CMDLINE
fi
if [[ "${REPORT}" = "" ]]
then
  # Set a default output filename here, in case no
  # user-specified filename is given by the user.
  # There were too many hyphens in the legacy format,
  # so I've eliminated a few from the date and time.
  # Format is now "hostname-scriptname-YYYYMMDD-HHMMSS"
  STAMP="$(date +%F+%T | sed 's/[-:]//g' | sed 's/+/-/g')"
  REPORT="${HOME}/${HOSTNAME}-system_info-${STAMP}"
fi

#---------------
fnMAIN

#---------------
# Close the file descriptors.
# These commands are also present in function "fnABORT".
exec 3>&- 2> /dev/null
set +x
exec 4>&- 2> /dev/null
